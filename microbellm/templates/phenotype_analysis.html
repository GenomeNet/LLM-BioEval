{% extends "base.html" %}

{% block title %}Phenotype Analysis - LLM-BioEval{% endblock %}

{% block extra_head %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/article_styles.css') }}">
<style>
    /* Hero Header Section - inherits base styles from layout.css */
    .hero-header {
        position: relative;
        overflow: hidden;
        margin-bottom: 0; /* Reset margin since section-full handles spacing */
    }

    /* Header animation canvas */
    .hero-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        opacity: 0.15;
        z-index: 1;
    }

    /* Color transition overlay */
    .hero-header::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(135deg, 
            rgba(34, 197, 94, 0.1) 0%,
            rgba(132, 204, 22, 0.08) 25%,
            rgba(16, 185, 129, 0.1) 50%,
            rgba(5, 150, 105, 0.08) 75%,
            rgba(34, 197, 94, 0.1) 100%);
        z-index: 2;
        animation: colorShift 15s ease-in-out infinite;
    }

    @keyframes colorShift {
        0%, 100% { 
            background: linear-gradient(135deg, 
                rgba(34, 197, 94, 0.1) 0%,
                rgba(132, 204, 22, 0.08) 25%,
                rgba(16, 185, 129, 0.1) 50%,
                rgba(5, 150, 105, 0.08) 75%,
                rgba(34, 197, 94, 0.1) 100%);
        }
        50% { 
            background: linear-gradient(135deg, 
                rgba(5, 150, 105, 0.12) 0%,
                rgba(34, 197, 94, 0.1) 25%,
                rgba(132, 204, 22, 0.08) 50%,
                rgba(16, 185, 129, 0.1) 75%,
                rgba(250, 204, 21, 0.12) 100%);
        }
    }

    /* Hero content */
    .hero-content {
        position: relative;
        z-index: 3;
        text-align: left;
        color: var(--gray-900);
    }

    .hero-title {
        font-size: 48px;
        font-weight: 800;
        line-height: 1.1;
        margin-bottom: var(--spacing-element);
        letter-spacing: -0.02em;
        color: var(--gray-900);
    }

    /* Hero author styling moved to article_styles.css - using .hero-author--green */

    .hero-subtitle {
        font-size: 20px;
        font-weight: 400;
        line-height: 1.6;
        color: var(--gray-600);
        max-width: 700px;
        margin: 0;
    }

    /* Background animation canvas */
    .background-canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 300px;
        height: 100%;
        pointer-events: none;
        opacity: 0.03;
        z-index: 0;
    }

    /* Article sections, titles, text and headers moved to article_styles.css */

    /* Overview section uses section-callout--green from article_styles.css */

    .overview-cards {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: var(--spacing-element);
        margin-top: var(--spacing-component);
    }

    .overview-card {
        background: var(--bg-primary);
        border: 1px solid var(--gray-200);
        border-radius: 12px;
        padding: var(--spacing-element);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
        transition: all 0.3s ease;
    }

    .overview-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    /* Removed icon styling - no longer using emojis */

    .overview-title {
        font-size: 16px;
        font-weight: 600;
        color: var(--gray-900);
        margin-bottom: calc(var(--spacing-small) * 0.75);
    }

    .overview-description {
        font-size: 14px;
        color: var(--gray-600);
        line-height: 1.6;
    }

    /* Callout styles moved to article_styles.css */

    /* Phenotype categories animation */
    .phenotype-categories-animated {
        margin-top: calc(var(--spacing-element) * 0.833);
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: var(--spacing-small);
    }

    .phenotype-item {
        display: flex;
        align-items: center;
        position: relative;
        padding: var(--spacing-small) calc(var(--spacing-element) * 0.833);
        background: white;
        border: 1px solid var(--gray-200);
        border-radius: 8px;
        transition: all 0.3s ease;
        opacity: 0;
        transform: translateY(10px);
        animation: fadeInUp 0.5s forwards;
        overflow: hidden;
    }
    
    .phenotype-item:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        border-color: var(--gray-300);
    }

    .phenotype-item:nth-child(1) { animation-delay: 0.1s; }
    .phenotype-item:nth-child(2) { animation-delay: 0.2s; }
    .phenotype-item:nth-child(3) { animation-delay: 0.3s; }
    .phenotype-item:nth-child(4) { animation-delay: 0.4s; }
    .phenotype-item:nth-child(5) { animation-delay: 0.5s; }
    .phenotype-item:nth-child(6) { animation-delay: 0.6s; }

    @keyframes fadeInUp {
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .phenotype-category-indicator {
        position: absolute;
        left: 0;
        top: 0;
        width: 4px;
        height: 100%;
        border-radius: 8px 0 0 8px;
    }

    .phenotype-name {
        font-weight: 600;
        color: var(--gray-900);
        font-size: 14px;
    }

    .phenotype-values {
        font-size: 13px;
        color: var(--gray-500);
        font-weight: 400;
    }

    /* Model Analysis Section */
    .model-analysis-section {
        margin-top: var(--spacing-section);
    }

    /* Data Tables */
    .data-table {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 18px;
        font-size: 14px;
        background: var(--bg-primary);
        border: 1px solid var(--gray-200);
        border-radius: 8px;
        overflow: hidden;
    }
    
    .data-table th,
    .data-table td {
        padding: 12px 16px;
        text-align: left;
        border-bottom: 1px solid var(--gray-200);
    }
    
    .data-table th {
        background: var(--gray-50);
        font-weight: 600;
        color: var(--gray-900);
        font-size: 13px;
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }
    
    .data-table tr:last-child td {
        border-bottom: none;
    }
    
    
    /* Model name cell styling */
    .model-name-cell {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-weight: 600;
        font-size: 13px;
        color: var(--gray-700);
    }

    /* Loading States */
    .loading-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: var(--spacing-element);
        padding: calc(var(--spacing-section) * 1.25) var(--spacing-component);
    }

    .loading-spinner {
        width: 40px;
        height: 40px;
        border: 4px solid rgba(255, 255, 255, 0.3);
        border-top: 4px solid var(--bg-primary);
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    .loading-progress {
        width: 300px;
        height: 6px;
        background-color: rgba(255, 255, 255, 0.2);
        border-radius: 3px;
        overflow: hidden;
        position: relative;
    }

    .loading-progress-bar {
        height: 100%;
        background: linear-gradient(90deg, var(--bg-primary), rgba(255, 255, 255, 0.8));
        border-radius: 3px;
        animation: progress-slide 2s ease-in-out infinite;
        width: 30%;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    @keyframes progress-slide {
        0% { transform: translateX(-100%); }
        50% { transform: translateX(250%); }
        100% { transform: translateX(-100%); }
    }

    .loading-text {
        font-size: 16px;
        color: var(--bg-primary);
        font-weight: 500;
    }

    .empty-state {
        text-align: center;
        padding: calc(var(--spacing-section) * 1.25);
        color: var(--gray-600);
    }

    .empty-state h3 {
        color: var(--gray-900);
        margin-bottom: calc(var(--spacing-small) * 0.625);
    }

    /* Sidebar and TOC styles */
    .toc-card {
        background: var(--bg-primary);
        border: 1px solid var(--gray-200);
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
    }
    
    .toc-header {
        background: linear-gradient(to bottom, #f8f9fa, #f1f3f5);
        padding: 16px 20px;
        border-bottom: 1px solid var(--gray-200);
    }
    
    .toc-title {
        font-size: 14px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: var(--gray-700);
        margin: 0;
    }
    
    .toc-content {
        padding: 20px;
    }
    
    .paper-doi-link:hover {
        background: #059669 !important;
    }

    /* Footer */
    .footer {
        padding: 48px 0;
        border-top: 1px solid var(--gray-200);
        margin-top: 80px;
        background: var(--gray-50);
    }

    .footer-content {
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .footer-text {
        color: var(--gray-500);
        font-size: 14px;
    }

    .footer-links {
        display: flex;
        gap: 24px;
    }

    .footer-link {
        color: var(--gray-600);
        text-decoration: none;
        font-size: 14px;
        transition: color 0.2s;
    }

    .footer-link:hover {
        color: var(--gray-900);
    }

    @media (max-width: 768px) {
        :root {
            --padding-container: 24px;
        }
        
        .footer-content {
            flex-direction: column;
            gap: 24px;
            text-align: center;
        }
        
        .hero-title {
            font-size: 36px;
        }
        
        .hero-subtitle {
            font-size: 18px;
        }
        
        .overview-cards {
            grid-template-columns: 1fr;
        }
        
        .phenotype-categories-animated {
            grid-template-columns: 1fr;
        }
        
        .phenotype-grid {
            grid-template-columns: 1fr;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="main-content page-content">
    <!-- Hero Header with Gradient -->
    <section class="hero-header">
        <canvas id="phenotype-hero-canvas" class="hero-canvas"></canvas>
        <div class="hero-content">
            <h1 class="hero-title">Phenotype Prediction Patterns</h1>
            <p class="hero-author hero-author--green">by Philipp C. Münch</p>
            <p class="hero-subtitle">
                Comprehensive analysis of how language models predict fundamental microbial characteristics,
                from gram staining to pathogenicity, revealing distinct prediction patterns across different models.
            </p>
        </div>
    </section>

    <!-- Article Content -->
    <article class="article-container">
        <div class="article-main">
            <div class="article-content">

            <!-- Introduction Section -->
            <section class="article-section">
                <h2 class="main-section-title">Understanding Phenotype Predictions</h2>
                
                <p class="article-text">
                    Large language models have shown remarkable capabilities in understanding and generating scientific text, 
                    but their performance on specialized microbiology tasks remains largely unexplored. This analysis evaluates 
                    how different models predict fundamental bacterial characteristics—from gram staining to pathogenicity—revealing 
                    distinct patterns in their biological knowledge representation and confidence levels.
                </p>
                
                <p class="article-text">
                    Microbial phenotypes represent fundamental characteristics that define how bacteria interact with their environment. 
                    These traits range from structural properties like cell wall composition to functional capabilities such as oxygen 
                    requirements and pathogenicity. Understanding how well language models predict these characteristics provides insights 
                    into their biological knowledge representation.
                </p>
            </section>
            
            <!-- Additional Research Context -->
            <section class="article-section">
                <h2 class="section-title">Research Applications</h2>
                
                <p class="article-text">
                    Understanding how language models predict bacterial phenotypes has significant implications for computational 
                    microbiology and bioinformatics research. These predictions can accelerate initial bacterial characterization, 
                    guide experimental design, and provide insights into knowledge gaps in current biological databases.
                </p>
                
                <div class="callout callout-phenotype">
                    <div class="callout-content">
                        <h4 style="margin-top: 0; margin-bottom: 12px; color: var(--gray-900); font-size: 16px;">Clinical Relevance</h4>
                        <p style="margin: 0; line-height: 1.6;">
                            Accurate phenotype predictions are crucial for clinical microbiology, where rapid identification of 
                            bacterial characteristics can inform treatment decisions. Models that excel at predicting pathogenicity 
                            and antibiotic resistance markers could serve as valuable preliminary screening tools.
                        </p>
                    </div>
                </div>
                
                <p class="article-text">
                    Future research directions include fine-tuning models on curated microbiological datasets, developing 
                    ensemble approaches that combine multiple model predictions, and creating specialized benchmarks for 
                    evaluating biological prediction accuracy across diverse bacterial taxa.
                </p>
            </section>
            
            </div>
        </div>
    </article>

    <!-- Overview Section - Full Width Callout -->
    <section class="section-callout section-callout--green">
        <div class="section-callout__content">
            <div class="section-callout__header">
                <h3 class="section-callout__title">Key Phenotype Categories</h3>
                <p class="section-callout__text">Our analysis evaluates model predictions across essential microbial characteristics that form the foundation of bacterial classification and identification in clinical and research settings.</p>
            </div>
            
            <div class="overview-cards">
                <div class="overview-card">
                    <h4 class="overview-title">Gram Staining</h4>
                    <p class="overview-description">Fundamental bacterial classification based on cell wall structure, determining staining properties and antibiotic susceptibility.</p>
                </div>
                <div class="overview-card">
                    <h4 class="overview-title">Motility</h4>
                    <p class="overview-description">Ability of bacteria to move independently using flagella, pili, or other mechanisms, affecting colonization and virulence.</p>
                </div>
                <div class="overview-card">
                    <h4 class="overview-title">Oxygen Requirements</h4>
                    <p class="overview-description">Metabolic relationship with oxygen, from obligate aerobes to anaerobes, determining growth conditions and habitat.</p>
                </div>
                <div class="overview-card">
                    <h4 class="overview-title">Temperature Range</h4>
                    <p class="overview-description">Optimal growth temperatures defining psychrophiles, mesophiles, and thermophiles, indicating environmental adaptations.</p>
                </div>
                <div class="overview-card">
                    <h4 class="overview-title">Metabolism</h4>
                    <p class="overview-description">Energy generation pathways including fermentation, respiration, and photosynthesis, defining nutritional requirements.</p>
                </div>
                <div class="overview-card">
                    <h4 class="overview-title">Pathogenicity</h4>
                    <p class="overview-description">Ability to cause disease in hosts, from harmless commensals to obligate pathogens, crucial for clinical applications.</p>
                </div>
            </div>
        </div>
    </section>

    <!-- Standard Article Section -->
    <article class="article-container">
        <div class="article-main">
            <div class="article-content">
                <section class="article-section">
                    <p class="article-text">
                        Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. 
                        Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
                    </p>
                    
                    <div class="callout callout-phenotype">
                        <div class="callout-content" id="dynamicStatsText">
                            <!-- This will be populated by JavaScript -->
                        </div>
                    </div>
                    
                    <p class="article-text">
                        Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. 
                        Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
                    </p>
                </section>
            </div>
        </div>
    </article>

    <!-- Continue with article content -->
    <article class="article-container">
        <div class="article-main">
            <div class="article-content">

            <!-- Analysis Methodology -->
            <section class="article-section">
                <h2 class="section-title">Analysis Methodology</h2>
                
                <p class="article-text">
                    We queried multiple state-of-the-art language models with a comprehensive list of bacterial species names, 
                    asking them to predict phenotypic characteristics. The models were evaluated on their ability to provide 
                    specific predictions versus acknowledging uncertainty with "NA" responses.
                </p>

                <div class="callout callout-methodology">
                    <div class="callout-content">
                        <h4 style="margin-top: 0; margin-bottom: 12px; color: var(--gray-900); font-size: 16px;">Prediction Distribution Analysis</h4>
                        <p style="margin: 0; line-height: 1.6;">
                            The visualizations below reveal how each model balances between making specific phenotype predictions and 
                            admitting uncertainty. Models with higher NA rates may be more conservative, while those with specific 
                            predictions demonstrate either greater confidence or potential overconfidence in their biological knowledge.
                        </p>
                    </div>
                </div>

                <p class="article-text">
                    The distribution patterns help identify which models are more likely to provide actionable predictions for 
                    microbiological research and which tend to be more cautious in their assessments. This balance between 
                    specificity and uncertainty is crucial for practical applications in microbiology.
                </p>
                
                <div class="callout callout-phenotype">
                    <div class="callout-content">
                        <canvas id="phenotype-categories-canvas" style="width: 100%; height: 200px;"></canvas>
                        <div class="phenotype-categories-animated">
                            <div class="phenotype-item">
                                <div class="phenotype-category-indicator" style="background: linear-gradient(to bottom, #10b981, #059669);"></div>
                                <div>
                                    <div class="phenotype-name">Gram Staining</div>
                                    <div class="phenotype-values">Positive, Negative, Variable</div>
                                </div>
                            </div>
                            <div class="phenotype-item">
                                <div class="phenotype-category-indicator" style="background: linear-gradient(to bottom, #3b82f6, #2563eb);"></div>
                                <div>
                                    <div class="phenotype-name">Motility</div>
                                    <div class="phenotype-values">Motile, Non-motile</div>
                                </div>
                            </div>
                            <div class="phenotype-item">
                                <div class="phenotype-category-indicator" style="background: linear-gradient(to bottom, #a855f7, #9333ea);"></div>
                                <div>
                                    <div class="phenotype-name">Oxygen Requirements</div>
                                    <div class="phenotype-values">Aerobic, Anaerobic, Facultative</div>
                                </div>
                            </div>
                            <div class="phenotype-item">
                                <div class="phenotype-category-indicator" style="background: linear-gradient(to bottom, #f59e0b, #d97706);"></div>
                                <div>
                                    <div class="phenotype-name">Temperature Range</div>
                                    <div class="phenotype-values">Psychrophile, Mesophile, Thermophile</div>
                                </div>
                            </div>
                            <div class="phenotype-item">
                                <div class="phenotype-category-indicator" style="background: linear-gradient(to bottom, #ef4444, #dc2626);"></div>
                                <div>
                                    <div class="phenotype-name">Metabolism</div>
                                    <div class="phenotype-values">Fermentative, Respiratory, Mixed</div>
                                </div>
                            </div>
                            <div class="phenotype-item">
                                <div class="phenotype-category-indicator" style="background: linear-gradient(to bottom, #6366f1, #4f46e5);"></div>
                                <div>
                                    <div class="phenotype-name">Pathogenicity</div>
                                    <div class="phenotype-values">Pathogenic, Non-pathogenic, Opportunistic</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            </div>
        </div>
    </article>

    <!-- Model Analysis Section - Full Width Callout -->
    <section class="section-callout section-callout--purple">
        <div class="section-callout__content">
            <div class="section-callout__header">
                <h3 class="section-callout__title">Model Phenotype Predictions</h3>
                <p class="section-callout__text">Comprehensive analysis of how different language models predict bacterial phenotypes, revealing patterns in biological knowledge representation.</p>
            </div>
            
            <div id="phenotypeContent">
                <div class="loading-container">
                    <div class="loading-spinner"></div>
                    <div class="loading-progress">
                        <div class="loading-progress-bar"></div>
                    </div>
                    <div class="loading-text">Loading phenotype prediction data...</div>
                </div>
            </div>
        </div>
    </section>

    <!-- Standard Article Section for Hidden Phenotypes -->
    <article class="article-container">
        <div class="article-main">
            <div class="article-content">
                <section class="article-section">
                    <p class="article-text">
                        Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. 
                        Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
                    </p>
                    
                    <div id="hiddenPhenotypesSection" style="margin: 24px 0;">
                        <!-- This will be populated by JavaScript -->
                    </div>
                    
                    <p class="article-text">
                        Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. 
                        Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
                    </p>
                </section>
            </div>
        </div>
        
    </article>
</div>

<!-- Footer -->
<footer class="footer">
    <div class="footer-content">
        <div class="footer-text">
            © 2025 - LLM-BioEval Team
        </div>
        <div class="footer-links">
                <a href="/about" class="footer-link">About</a>
                <a href="/about#contact" class="footer-link">Contact</a>
                <a href="https://github.com/GenomeNet/microbeLLM" class="footer-link">GitHub</a>
                <a href="/privacy" class="footer-link">Privacy</a>
            </div>
        </div>
    </footer>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
    // Initialize phenotype animation from index.html
    function initPhenotypeAnimation() {
        const canvas = document.getElementById('phenotype-hero-canvas');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        let width, height;
        let bacteria = [];
        let animationId;
        
        const colors = [
            { r: 34, g: 197, b: 94 },   // Green
            { r: 16, g: 185, b: 129 },  // Teal
        ];
        
        function resizeCanvas() {
            width = canvas.width = canvas.offsetWidth;
            height = canvas.height = canvas.offsetHeight;
            initBacteria();
        }
        
        function initBacteria() {
            bacteria = [];
            const numBacteria = 35;
            
            for (let i = 0; i < numBacteria; i++) {
                bacteria.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    length: 15 + Math.random() * 35,
                    width: 4 + Math.random() * 8,
                    angle: Math.random() * Math.PI * 2,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    speed: 0.08 + Math.random() * 0.25,
                    rotationSpeed: (Math.random() - 0.5) * 0.015,
                    shape: Math.random() > 0.3 ? 'bacillus' : 'coccus'
                });
            }
        }
        
        function drawBacterium(bacterium) {
            ctx.save();
            ctx.translate(bacterium.x, bacterium.y);
            ctx.rotate(bacterium.angle);
            
            ctx.fillStyle = `rgba(${bacterium.color.r}, ${bacterium.color.g}, ${bacterium.color.b}, 1)`;
            
            if (bacterium.shape === 'bacillus') {
                ctx.beginPath();
                ctx.moveTo(-bacterium.length/2 + bacterium.width/2, 0);
                ctx.lineTo(bacterium.length/2 - bacterium.width/2, 0);
                ctx.arc(bacterium.length/2 - bacterium.width/2, 0, bacterium.width/2, -Math.PI/2, Math.PI/2);
                ctx.lineTo(-bacterium.length/2 + bacterium.width/2, bacterium.width);
                ctx.arc(-bacterium.length/2 + bacterium.width/2, bacterium.width/2, bacterium.width/2, Math.PI/2, Math.PI * 1.5);
                ctx.closePath();
                ctx.fill();
            } else {
                ctx.beginPath();
                ctx.arc(0, 0, bacterium.width, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        function animate() {
            ctx.clearRect(0, 0, width, height);
            
            bacteria.forEach(bacterium => {
                bacterium.x += Math.cos(bacterium.angle) * bacterium.speed;
                bacterium.y += Math.sin(bacterium.angle) * bacterium.speed;
                bacterium.angle += bacterium.rotationSpeed;
                
                if (bacterium.x < -50) bacterium.x = width + 50;
                if (bacterium.x > width + 50) bacterium.x = -50;
                if (bacterium.y < -50) bacterium.y = height + 50;
                if (bacterium.y > height + 50) bacterium.y = -50;
                
                drawBacterium(bacterium);
            });
            
            animationId = requestAnimationFrame(animate);
        }
        
        resizeCanvas();
        animate();
        
        window.addEventListener('resize', () => {
            clearTimeout(window.resizeTimeout);
            window.resizeTimeout = setTimeout(resizeCanvas, 250);
        });
    }

    // Initialize animations on page load
    document.addEventListener('DOMContentLoaded', function() {
        initPhenotypeAnimation();
        initPhenotypeCategoriesAnimation();
    });
    
    // Phenotype categories animation
    function initPhenotypeCategoriesAnimation() {
        const canvas = document.getElementById('phenotype-categories-canvas');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;
        
        let particles = [];
        const colors = [
            'rgba(16, 185, 129, 0.6)',
            'rgba(59, 130, 246, 0.6)',
            'rgba(168, 85, 247, 0.6)',
            'rgba(245, 158, 11, 0.6)',
            'rgba(239, 68, 68, 0.6)',
            'rgba(99, 102, 241, 0.6)'
        ];
        
        // Create floating particles
        for (let i = 0; i < 30; i++) {
            particles.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                radius: Math.random() * 3 + 1,
                color: colors[Math.floor(Math.random() * colors.length)],
                vx: (Math.random() - 0.5) * 0.5,
                vy: (Math.random() - 0.5) * 0.5
            });
        }
        
        function animateParticles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            particles.forEach(particle => {
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                ctx.fillStyle = particle.color;
                ctx.fill();
                
                particle.x += particle.vx;
                particle.y += particle.vy;
                
                // Bounce off edges
                if (particle.x < 0 || particle.x > canvas.width) particle.vx = -particle.vx;
                if (particle.y < 0 || particle.y > canvas.height) particle.vy = -particle.vy;
            });
            
            requestAnimationFrame(animateParticles);
        }
        
        animateParticles();
    }

    // The phenotype analysis variables and functions are defined below
</script>

<!-- Additional orphaned CSS styles that need to be properly wrapped -->
<style>
    .category-name {
        font-weight: 600;
        color: #2c3e50;
    }
    
    .category-values {
        color: #6c757d;
        font-size: 12px;
        font-style: italic;
    }
    
    .interpretation-note {
        margin-top: 20px;
        padding: 15px;
        background: #e3f2fd;
        border: 1px solid #bbdefb;
        border-radius: 6px;
        font-size: 13px;
        line-height: 1.6;
        color: #0c5460;
    }
    
    /* Phenotype Analysis Styles */
    .phenotype-analysis-container {
        margin-bottom: 20px;
    }
    
    /* Grid layout for phenotype cards */
    .phenotype-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 24px;
        margin-bottom: 32px;
        width: 100%;
    }
    
    @media (max-width: 1200px) {
        .phenotype-grid {
            grid-template-columns: 1fr;
        }
    }
    
    .phenotype-card {
        background: var(--bg-primary);
        border: 1px solid var(--gray-200);
        border-radius: 12px;
        padding: 20px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
    }
    
    .phenotype-card-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 16px;
        padding-bottom: 12px;
        border-bottom: 1px solid var(--gray-200);
    }
    
    .phenotype-card-title {
        font-size: 18px;
        font-weight: 600;
        color: var(--gray-900);
        margin: 0;
    }
    
    .phenotype-analysis-table {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 18px;
        font-size: 14px;
    }
    
    .phenotype-analysis-table th,
    .phenotype-analysis-table td {
        padding: 8px 12px;
        border: 1px solid var(--gray-200);
        text-align: left;
    }
    
    .phenotype-analysis-table th {
        background: var(--gray-50);
        font-weight: 600;
    }
    
    .phenotype-card .phenotype-analysis-table th:first-child {
        text-align: left;
    }
    
    .phenotype-card .phenotype-analysis-table th:nth-child(2) {
        text-align: center;
    }
    
    .phenotype-card .phenotype-analysis-table th:last-child {
        text-align: center;
        width: 100px;
    }
    
    .model-name-cell {
        background-color: var(--gray-50);
        font-weight: 600;
        color: var(--gray-700);
        text-align: left;
        padding-left: 10px;
        font-size: 11px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    }
    
    .chart-cell {
        width: 100%;
        max-width: 500px;
        padding: 4px 8px;
    }
    
    .phenotype-card .chart-cell {
        max-width: none;
    }
    
    .no-data {
        text-align: center;
        color: var(--gray-500);
        font-style: italic;
        font-size: 11px;
    }
    
    /* Dynamic Stats Text */
    .dynamic-stats {
        background: linear-gradient(135deg, 
            rgba(34, 197, 94, 0.05) 0%,
            rgba(16, 185, 129, 0.03) 50%,
            rgba(5, 150, 105, 0.05) 100%);
        border: 1px solid rgba(34, 197, 94, 0.1);
        border-radius: 12px;
        padding: 20px 28px;
        margin-bottom: 48px;
        font-size: 16px;
        line-height: 1.8;
        color: var(--gray-700);
    }
    
    .stat-value {
        display: inline-block;
        font-weight: 700;
        color: var(--gray-900);
        background: rgba(34, 197, 94, 0.1);
        border-radius: 6px;
        margin: 0 2px;
        padding: 2px 6px;
        font-size: inherit;
    }
    
    .model-highlight {
        display: inline-block;
        font-weight: 700;
        color: #059669;
        background: rgba(34, 197, 94, 0.1);
        border-radius: 6px;
        padding: 2px 8px;
        font-size: inherit;
    }
    
    .model-lowlight {
        display: inline-block;
        font-weight: 700;
        color: #dc2626;
        background: rgba(239, 68, 68, 0.1);
        border-radius: 6px;
        padding: 2px 8px;
        font-size: inherit;
    }
    
    /* CSS Variables from layout.css */
    :root {
        --container-standard: 1500px;
        --padding-container: 48px;
    }
    
    /* Phenotype section styling */
    .phenotype-section {
        width: 100%;
    }
    
    .phenotype-grid-container {
        width: 100%;
    }
    
    /* Field type badges */
    .field-type-badge {
        display: inline-block;
        font-size: 11px;
        font-weight: 500;
        padding: 2px 8px;
        border-radius: 4px;
        margin-left: 8px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }
    
    .field-type-binary {
        background: rgba(99, 102, 241, 0.1);
        color: #6366f1;
    }
    
    .field-type-categorical {
        background: rgba(34, 197, 94, 0.1);
        color: #059669;
    }
    
    .field-type-multi-select {
        background: rgba(251, 146, 60, 0.1);
        color: #ea580c;
    }
    
    .single-bar-chart {
        width: 100%;
        height: 16px;
    }
    
    .single-stacked-bar {
        width: 100%;
        height: 16px;
        display: flex;
        border: 1px solid #dee2e6;
        border-radius: 2px;
        overflow: hidden;
        background: #f8f9fa;
    }
    
    .bar-segment {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        font-weight: 600;
        position: relative;
        min-width: 16px;
    }
    
    .bar-number {
        font-size: 11px;
        font-weight: 600;
        z-index: 1;
        pointer-events: none;
    }
    
    /* Phenotype value colors */
    .bar-segment.value-positive {
        background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
        color: #155724;
    }
    
    .bar-segment.value-negative {
        background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
        color: #721c24;
    }
    
    .bar-segment.value-true {
        background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
        color: #155724;
    }
    
    .bar-segment.value-false {
        background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
        color: #721c24;
    }
    
    .bar-segment.value-na {
        background: linear-gradient(135deg, #e2e3e5 0%, #d6d8db 100%);
        color: #383d41;
    }
    
    .bar-segment.value-invalid {
        background-color: #ffcdd2;
        color: #c62828;
        border: 1px dashed #c62828;
    }
    
    .bar-segment.value-other {
        background: linear-gradient(135deg, #d1ecf1 0%, #bee5eb 100%);
        color: #0c5460;
    }
    
    .phenotype-header {
        margin-top: 0;
        margin-bottom: 15px;
        color: #495057;
        font-size: 16px;
        font-weight: 600;
        display: flex;
        align-items: center;
    }
    
    .phenotype-section {
        background: #f8f9fa;
        border: 1px solid #e9ecef;
        border-radius: 6px;
        padding: 15px;
        margin-bottom: 15px;
    }
    
    .loading-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        padding: 60px 40px;
    }
    
    .loading-spinner {
        width: 40px;
        height: 40px;
        border: 4px solid #e9ecef;
        border-top: 4px solid #007bff;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }
    
    .loading-progress {
        width: 300px;
        height: 6px;
        background-color: #e9ecef;
        border-radius: 3px;
        overflow: hidden;
        position: relative;
    }
    
    .loading-progress-bar {
        height: 100%;
        background: linear-gradient(90deg, #007bff, #0056b3);
        border-radius: 3px;
        animation: progress-slide 2s ease-in-out infinite;
        width: 30%;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    @keyframes progress-slide {
        0% { transform: translateX(-100%); }
        50% { transform: translateX(250%); }
        100% { transform: translateX(-100%); }
    }
    
    .loading-text {
        font-size: 16px;
        color: #495057;
        font-weight: 500;
    }
    
    .empty-state {
        text-align: center;
        padding: 60px;
        color: #6c757d;
    }
    
    .empty-state h3 {
        color: #495057;
        margin-bottom: 10px;
    }
    
    /* Statistics cards */
    .analysis-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
    }
    
    .stat-card {
        background: white;
        border: 2px solid #e9ecef;
        border-radius: 8px;
        padding: 20px;
        text-align: center;
    }
    
    .stat-card.positive {
        border-color: #28a745;
        background-color: #f8fff9;
    }
    
    .stat-card.negative {
        border-color: #dc3545;
        background-color: #fff8f8;
    }
    
    .stat-card.neutral {
        border-color: #6c757d;
        background-color: #f8f9fa;
    }
    
    .stat-number {
        font-size: 28px;
        font-weight: 700;
        color: #2c3e50;
        margin-bottom: 5px;
    }
    
    .stat-label {
        font-size: 14px;
        color: #6c757d;
        font-weight: 500;
    }
    
    .model-name {
        background: linear-gradient(135deg, #f8f9fa, #e9ecef);
        color: #495057;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-weight: 600;
        font-size: 13px;
        padding: 2px 6px;
        border-radius: 4px;
        border: 1px solid #dee2e6;
    }
    
    /* Phenotype specific value colors */
    .bar-segment.gram-positive {
        background-color: #d4edda;
        color: #155724;
    }
    
    .bar-segment.gram-negative {
        background-color: #f8d7da;
        color: #721c24;
    }
    
    .bar-segment.gram-variable {
        background-color: #fff3cd;
        color: #856404;
    }
    
    .bar-segment.aerobic {
        background-color: #cce5ff;
        color: #004085;
    }
    
    .bar-segment.anaerobic {
        background-color: #e2e3e5;
        color: #383d41;
    }
    
    .bar-segment.facultative {
        background-color: #d1ecf1;
        color: #0c5460;
    }
    
    .bar-segment.aerotolerant {
        background-color: #e7e8ea;
        color: #495057;
    }
    
    /* Biosafety level colors */
    .bar-segment.biosafety-1 {
        background-color: #d4edda;
        color: #155724;
    }
    
    .bar-segment.biosafety-2 {
        background-color: #fff3cd;
        color: #856404;
    }
    
    .bar-segment.biosafety-3 {
        background-color: #ffeaa7;
        color: #b8860b;
    }
    
    .bar-segment.biosafety-4 {
        background-color: #f8d7da;
        color: #721c24;
    }
    
    /* Health association colors */
    .bar-segment.health-beneficial {
        background-color: #d4edda;
        color: #155724;
    }
    
    .bar-segment.health-neutral {
        background-color: #e2e3e5;
        color: #6c757d;
    }
    
    .bar-segment.health-pathogenic {
        background-color: #f8d7da;
        color: #721c24;
    }
    
    .bar-segment.health-opportunistic {
        background-color: #fff3cd;
        color: #856404;
    }
    
    /* Hemolysis colors */
    .bar-segment.hemolysis-alpha {
        background-color: #cce5ff;
        color: #004085;
    }
    
    .bar-segment.hemolysis-beta {
        background-color: #f8d7da;
        color: #721c24;
    }
    
    .bar-segment.hemolysis-gamma {
        background-color: #d1ecf1;
        color: #0c5460;
    }
    
    /* Cell shape colors */
    .bar-segment.shape-spherical {
        background-color: #e1f5fe;
        color: #01579b;
    }
    
    .bar-segment.shape-rod {
        background-color: #f3e5f5;
        color: #4a148c;
    }
    
    .bar-segment.shape-spiral {
        background-color: #fff8e1;
        color: #e65100;
    }
    
    .bar-segment.shape-filamentous {
        background-color: #e8f5e8;
        color: #2e7d32;
    }
    
    .bar-segment.shape-pleomorphic {
        background-color: #fce4ec;
        color: #880e4f;
    }
    
    /* Modern dropdown controls */
    .simple-controls {
        display: flex;
        gap: var(--spacing-small);
        margin-bottom: var(--spacing-element);
        align-items: center;
        flex-wrap: wrap;
        padding: var(--spacing-small);
        background: #FAFAFA;
        border: 1px solid var(--gray-200);
        border-radius: 12px;
    }
    
    .control-item {
        display: flex;
        align-items: center;
        gap: calc(var(--spacing-small) * 0.625);
    }
    
    .control-item label {
        font-size: 13px;
        color: #495057;
        font-weight: 600;
        min-width: 60px;
    }
    
    .control-item select {
        padding: 8px 12px;
        border: 1px solid #dee2e6;
        border-radius: 4px;
        background: white;
        font-size: 13px;
        font-family: inherit;
        min-width: 160px;
    }
    
    /* Hidden phenotypes info */
    .hidden-phenotypes-info {
        margin-bottom: calc(var(--spacing-element) * 1.04);
        padding: var(--spacing-element);
        background: #FAFAFA;
        border: 1px solid var(--gray-200);
        border-radius: 8px;
    }
    
    .hidden-phenotypes-info h4 {
        margin: 0 0 calc(var(--spacing-small) * 0.625) 0;
        color: var(--gray-700);
        font-size: 14px;
        font-weight: 600;
    }
    
    .hidden-phenotypes-info p {
        margin: 0 0 calc(var(--spacing-small) * 0.625) 0;
        color: var(--gray-600);
        font-size: 14px;
        line-height: 1.6;
    }
    
    .hidden-phenotypes-info ul {
        margin: 0;
        padding-left: var(--spacing-element);
        color: var(--gray-600);
    }
    
    .hidden-phenotypes-info li {
        margin-bottom: calc(var(--spacing-small) * 0.3125);
        font-size: 14px;
    }
    
    /* Tooltip styles */
    .phenotype-tooltip {
        position: fixed;
        z-index: 1000;
        pointer-events: none;
        filter: drop-shadow(0 2px 8px rgba(0,0,0,0.15));
    }
    
    .phenotype-tooltip-content {
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        padding: 8px 12px;
        font-size: 11px;
        max-width: 300px;
    }
    
    .phenotype-tooltip-header {
        font-weight: 600;
        margin-bottom: 6px;
        padding-bottom: 4px;
        border-bottom: 1px solid #e9ecef;
    }
    
    .phenotype-tooltip-stats {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        margin-top: 8px;
    }
    
    .tooltip-stat {
        font-size: 10px;
    }
    
    .tooltip-stat-label {
        color: #6c757d;
    }
    
    .tooltip-stat-value {
        font-weight: 600;
        color: #2c3e50;
    }
    
    /* Field type badges */
    .field-type-badge {
        font-size: 11px;
        padding: 2px 6px;
        border-radius: 3px;
        font-weight: 500;
        margin-left: 8px;
    }
    
    .field-type-binary {
        background-color: #e3f2fd;
        color: #1565c0;
    }
    
    .field-type-categorical {
        background-color: #f3e5f5;
        color: #7b1fa2;
    }
    
    .field-type-multi-select {
        background-color: #fff3e0;
        color: #ef6c00;
    }
    
    /* Legend styles */
    .phenotype-legend {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        margin-bottom: 16px;
        font-size: 13px;
    }
    
    .legend-item {
        display: flex;
        align-items: center;
        font-size: 12px;
        color: var(--gray-600);
    }
    
    .legend-color {
        width: 16px;
        height: 16px;
        border-radius: 3px;
        margin-right: 6px;
        display: inline-block;
    }
    
    .legend-label {
        color: var(--gray-600);
    }
    
    /* Consensus Analysis Styles */
    .consensus-explanation {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        padding: 20px;
        margin-bottom: 25px;
    }
    
    .consensus-explanation p {
        margin: 0 0 15px 0;
        color: #495057;
        font-size: 14px;
        line-height: 1.6;
    }
    
    .consensus-explanation ul {
        margin: 0;
        padding-left: 20px;
        color: #6c757d;
        font-size: 13px;
    }
    
    .consensus-explanation li {
        margin-bottom: 8px;
        line-height: 1.5;
    }
    
    .model-ranking {
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 30px;
    }
    
    .model-ranking h5 {
        margin: 0 0 10px 0;
        color: #2c3e50;
        font-size: 18px;
        font-weight: 600;
    }
    
    .ranking-explanation {
        color: #6c757d;
        font-size: 13px;
        margin-bottom: 20px;
        font-style: italic;
    }
    
    .consensus-ranking-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 13px;
    }
    
    .consensus-ranking-table th {
        background-color: #f8f9fa;
        padding: 12px 8px;
        text-align: center;
        font-weight: 600;
        color: #495057;
        border: 1px solid #dee2e6;
        font-size: 12px;
    }
    
    .consensus-ranking-table th i {
        margin-left: 4px;
        color: #6c757d;
        cursor: help;
    }
    
    .consensus-ranking-table td {
        padding: 10px 8px;
        border: 1px solid #e9ecef;
        text-align: center;
        vertical-align: middle;
    }
    
    .rank-badge {
        display: inline-block;
        width: 30px;
        height: 24px;
        line-height: 24px;
        text-align: center;
        border-radius: 12px;
        font-weight: 700;
        font-size: 12px;
    }
    
    .rank-badge.rank-top {
        background-color: #d4edda;
        color: #155724;
        border: 2px solid #28a745;
    }
    
    .rank-badge.rank-middle {
        background-color: #fff3cd;
        color: #856404;
        border: 2px solid #ffc107;
    }
    
    .rank-badge.rank-bottom {
        background-color: #f8d7da;
        color: #721c24;
        border: 2px solid #dc3545;
    }
    
    .deviation-score {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-weight: 600;
        padding: 4px 8px;
        border-radius: 4px;
        background-color: #f8f9fa;
    }
    
    .significant-count {
        font-weight: 600;
        color: #dc3545;
    }
    
    .significant-phenotypes-list {
        font-size: 11px;
        color: #721c24;
        margin-top: 4px;
        font-style: italic;
    }
    
    .agreement-badge {
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 11px;
        font-weight: 600;
        text-transform: uppercase;
    }
    
    .agreement-badge.agreement-high {
        background-color: #d4edda;
        color: #155724;
    }
    
    .agreement-badge.agreement-moderate {
        background-color: #d1ecf1;
        color: #0c5460;
    }
    
    .agreement-badge.agreement-low {
        background-color: #fff3cd;
        color: #856404;
    }
    
    .agreement-badge.agreement-outlier {
        background-color: #f8d7da;
        color: #721c24;
    }
    
    .consensus-phenotype-analysis {
        margin-top: 30px;
    }
    
    .consensus-phenotype-analysis h5 {
        margin: 0 0 20px 0;
        color: #2c3e50;
        font-size: 18px;
        font-weight: 600;
    }
    
    .consensus-analysis-container {
        background: white;
        border: 1px solid #e9ecef;
        border-radius: 6px;
        padding: 20px;
        margin-bottom: 20px;
    }
    
    .consensus-phenotype-header {
        margin: 0 0 15px 0;
        color: #495057;
        font-size: 16px;
        font-weight: 600;
        display: flex;
        align-items: center;
    }
    
    .consensus-distribution {
        margin-bottom: 20px;
        padding: 15px;
        background: #f8f9fa;
        border: 1px solid #e9ecef;
        border-radius: 4px;
    }
    
    .consensus-label {
        font-weight: 600;
        color: #495057;
        margin-bottom: 10px;
        font-size: 13px;
    }
    
    .consensus-bar {
        width: 100%;
        height: 20px;
        display: flex;
        border: 1px solid #dee2e6;
        border-radius: 4px;
        overflow: hidden;
        background: #f8f9fa;
    }
    
    .consensus-segment {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 11px;
        font-weight: 600;
        position: relative;
        min-width: 2px;
    }
    
    .consensus-comparison-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 12px;
    }
    
    .consensus-comparison-table th {
        background-color: #f8f9fa;
        padding: 10px 8px;
        text-align: center;
        font-weight: 600;
        color: #495057;
        border: 1px solid #dee2e6;
        font-size: 11px;
    }
    
    .consensus-comparison-table td {
        padding: 8px;
        border: 1px solid #e9ecef;
        vertical-align: middle;
    }
    
    .consensus-comparison-table tr.significant-deviation {
        background-color: #fff5f5;
        border-left: 4px solid #dc3545;
    }
    
    .comparison-cell {
        width: 400px;
        padding: 4px;
    }
    
    .comparison-container {
        display: flex;
        flex-direction: column;
        gap: 3px;
    }
    
    .comparison-bar {
        width: 100%;
        display: flex;
        border-radius: 2px;
        overflow: hidden;
        background: #f8f9fa;
    }
    
    .comparison-bar.model-bar {
        height: 20px;
        border: 1px solid #dee2e6;
    }
    
    .comparison-bar.consensus-ref-bar {
        height: 12px;
        border: 1px solid #ced4da;
    }
    
    .comparison-segment {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        font-weight: 600;
        position: relative;
        min-width: 2px;
    }
    
    .segment-label {
        font-size: 9px;
        font-weight: 700;
        text-shadow: 0 0 2px rgba(255,255,255,0.8);
    }
    
    .deviation-cell {
        text-align: center;
        width: 100px;
    }
    
    .js-score {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-weight: 600;
        padding: 3px 6px;
        border-radius: 3px;
        background-color: #f8f9fa;
        color: #495057;
    }
    
    .js-score.significant {
        background-color: #f8d7da;
        color: #721c24;
    }
    
    .status-cell {
        text-align: center;
        width: 80px;
    }
    
    .deviation-status {
        padding: 3px 8px;
        border-radius: 3px;
        font-size: 10px;
        font-weight: 600;
        text-transform: uppercase;
    }
    
    .deviation-status.consensus {
        background-color: #d4edda;
        color: #155724;
    }
    
    .deviation-status.outlier {
        background-color: #f8d7da;
        color: #721c24;
    }
    
    .no-consensus {
        color: #6c757d;
        font-style: italic;
        text-align: center;
        padding: 10px;
    }
</style>
<script>
    // Original phenotype analysis variables
    let phenotypeData = null;
    let templateData = null;
    let availableTemplates = [];
    let selectedTemplate = 'template1_phenotype';
    let visibleFieldTypes = ['binary', 'categorical']; // Only show binary and categorical by default
    
    const phenotypes = {
        'gram_staining': { name: 'Gram Staining' },
        'motility': { name: 'Motility' },
        'aerophilicity': { name: 'Aerophilicity' },
        'extreme_environment_tolerance': { name: 'Extreme Environment' },
        'biofilm_formation': { name: 'Biofilm Formation' },
        'animal_pathogenicity': { name: 'Animal Pathogenicity' },
        'biosafety_level': { name: 'Biosafety Level' },
        'health_association': { name: 'Health Association' },
        'host_association': { name: 'Host Association' },
        'plant_pathogenicity': { name: 'Plant Pathogenicity' },
        'spore_formation': { name: 'Spore Formation' },
        'hemolysis': { name: 'Hemolysis' },
        'cell_shape': { name: 'Cell Shape' }
    };
    
    // Format model name with provider
    function formatModelName(modelName) {
        if (!modelName.includes('/')) {
            return modelName;
        }
        
        const [provider, model] = modelName.split('/');
        const providerMap = {
            'anthropic': 'Anthropic',
            'openai': 'OpenAI',
            'google': 'Google',
            'meta-llama': 'Meta',
            'mistralai': 'Mistral',
            'cohere': 'Cohere',
            'x-ai': 'xAI'
        };
        
        const displayProvider = providerMap[provider] || provider.charAt(0).toUpperCase() + provider.slice(1);
        return `${displayProvider} ${model}`;
    }
    
    // Load data on page load
    loadInitialData();
    
    function loadInitialData() {
        // Load available templates first
        fetch('/api/available_phenotype_templates')
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    availableTemplates = data.templates;
                    if (availableTemplates.length > 0) {
                        selectedTemplate = availableTemplates[0].name;
                    }
                    // Load template definitions and phenotype data
                    return Promise.all([
                        loadTemplateDefinitions(),
                        loadPhenotypeData()
                    ]);
                } else {
                    throw new Error(data.error || 'Failed to load templates');
                }
            })
            .catch(error => {
                console.error('Error loading initial data:', error);
                document.getElementById('phenotypeContent').innerHTML = 
                    '<div class="empty-state"><h3>Error loading data</h3><p>' + error.message + '</p></div>';
            });
    }
    
    function loadTemplateDefinitions() {
        return fetch(`/api/template_field_definitions?template=${selectedTemplate}`)
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    templateData = data;
                } else {
                    throw new Error(data.error || 'Failed to load template definitions');
                }
            });
    }
    
    function loadPhenotypeData() {
        fetch('/api/phenotype_analysis')
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    document.getElementById('phenotypeContent').innerHTML = 
                        `<div class="empty-state"><h3>Error loading phenotype data</h3><p>${data.error}</p></div>`;
                    return;
                }
                
                phenotypeData = data;
                
                if (!data.files || data.files.length === 0) {
                    document.getElementById('phenotypeContent').innerHTML = 
                        '<div class="empty-state"><h3>No phenotype prediction data found</h3><p>Run predictions using phenotype templates to see analysis here.</p></div>';
                    return;
                }
                
                // Auto-select first dataset
                if (data.files.length > 0) {
                    showDatasetAnalysis(data.files[0]);
                }
            })
            .catch(error => {
                console.error('Error loading phenotype data:', error);
                document.getElementById('phenotypeContent').innerHTML = 
                    '<div class="empty-state"><h3>Error loading data</h3><p>' + error.message + '</p></div>';
            });
    }
    
    function changeTemplate(newTemplate) {
        selectedTemplate = newTemplate;
        
        // Show loading state
        document.getElementById('phenotypeContent').innerHTML = 
            '<div class="loading-container"><div class="loading-spinner"></div><div class="loading-text">Loading template definitions...</div></div>';
        
        // Load new template definitions and refresh data
        loadTemplateDefinitions()
            .then(() => loadPhenotypeData())
            .catch(error => {
                console.error('Error changing template:', error);
                document.getElementById('phenotypeContent').innerHTML = 
                    '<div class="empty-state"><h3>Error loading template</h3><p>' + error.message + '</p></div>';
            });
    }
    
    function shouldShowPhenotype(phenotypeKey) {
        if (!templateData || !templateData.legend_data) {
            return true; // Show all if no template data
        }
        
        const legendInfo = templateData.legend_data[phenotypeKey];
        if (!legendInfo) {
            return true; // Show if no field type info
        }
        
        const fieldType = legendInfo.field_type;
        return visibleFieldTypes.includes(fieldType);
    }
    
    function getHiddenPhenotypes() {
        const hiddenPhenotypes = [];
        if (!templateData || !templateData.legend_data) {
            return hiddenPhenotypes;
        }
        
        Object.entries(phenotypes).forEach(([phenotypeKey, phenotypeInfo]) => {
            const legendInfo = templateData.legend_data[phenotypeKey];
            if (legendInfo && !visibleFieldTypes.includes(legendInfo.field_type)) {
                hiddenPhenotypes.push({
                    name: phenotypeInfo.name,
                    fieldType: legendInfo.field_type
                });
            }
        });
        
        return hiddenPhenotypes;
    }

    function showDatasetAnalysis(selectedFile) {
        if (!selectedFile || !phenotypeData) {
            return;
        }
        
        const fileData = phenotypeData.data[selectedFile];
        if (!fileData) {
            document.getElementById('phenotypeContent').innerHTML = 
                '<div class="empty-state"><h3>No data available for this file</h3></div>';
            return;
        }
        
        updatePhenotypeView(selectedFile, fileData);
    }
    
    function updatePhenotypeView(fileName, fileData) {
        const content = document.getElementById('phenotypeContent');
        
        let html = '';
        
        // Simple controls without field type filtering
        html += '<div class="simple-controls">';
        
        // Template selector
        html += '<div class="control-item">';
        html += '<label>Template:</label>';
        html += '<select class="modern-select" onchange="changeTemplate(this.value)">';
        availableTemplates.forEach(template => {
            html += `<option value="${template.name}" ${template.name === selectedTemplate ? 'selected' : ''}>${template.display_name}</option>`;
        });
        html += '</select>';
        html += '</div>';
        
        // Dataset selector  
        html += '<div class="control-item">';
        html += '<label>Dataset:</label>';
        html += '<select class="modern-select" onchange="showDatasetAnalysis(this.value)">';
        phenotypeData.files.forEach(file => {
            html += `<option value="${file}" ${file === fileName ? 'selected' : ''}>${file}</option>`;
        });
        html += '</select>';
        html += '</div>';
        
        html += '</div>';

        // Calculate statistics
        const modelStats = {};
        let totalPredictions = 0;
        let totalNA = 0;
        
        // Process data by model and phenotype
        fileData.forEach(item => {
            const model = item.model;
            if (!modelStats[model]) {
                modelStats[model] = {
                    totalPredictions: 0,
                    naCount: 0,
                    phenotypeDistributions: {}
                };
            }
            
            modelStats[model].totalPredictions++;
            totalPredictions++;
            
            // Check each phenotype field
            const phenotypeFields = Object.keys(phenotypes);
            
            phenotypeFields.forEach(field => {
                if (!modelStats[model].phenotypeDistributions[field]) {
                    modelStats[model].phenotypeDistributions[field] = {};
                }
                
                let value = item[field];
                
                // Check for null, undefined, empty string, or NA values
                if (value === null || value === undefined || value === 'NA' || value === 'N/A' || value === '') {
                    value = 'NA';
                    modelStats[model].naCount++;
                    totalNA++;
                } else if (typeof value === 'string' && value.startsWith('INVALID:')) {
                    // Handle invalid values that failed validation
                    const originalValue = value.substring(8);
                    value = `Invalid: ${originalValue}`;
                }
                
                // Handle arrays (like aerophilicity)
                if (Array.isArray(value)) {
                    value = value.join(', ');
                }
                
                modelStats[model].phenotypeDistributions[field][value] = 
                    (modelStats[model].phenotypeDistributions[field][value] || 0) + 1;
            });
        });
        
        // Convert to sorted array
        const modelResults = Object.entries(modelStats).map(([modelName, stats]) => ({
            modelName,
            totalPredictions: stats.totalPredictions,
            naCount: stats.naCount,
            naPercentage: (stats.naCount / (stats.totalPredictions * Object.keys(phenotypes).length)) * 100,
            phenotypeDistributions: stats.phenotypeDistributions
        }));
        
        // Sort alphabetically by model name for consistent ordering
        modelResults.sort((a, b) => a.modelName.localeCompare(b.modelName));
        
        if (modelResults.length === 0) {
            html += '<div class="empty-state"><h3>No model predictions found</h3></div>';
            content.innerHTML = html;
            return;
        }
        
        // Calculate consensus and deviation metrics
        const consensusAnalysis = calculateConsensusAnalysis(modelResults);
        
        // Dataset overview statistics
        const avgNAPercentage = modelResults.reduce((sum, m) => sum + m.naPercentage, 0) / modelResults.length;
        const totalPhenotypes = Object.keys(phenotypes).length;
        const avgPredictionsPerModel = totalPredictions / modelResults.length;
        
        // Find best and worst performers based on NA rate
        let bestModel = null;
        let bestNARate = 100;
        let worstModel = null;
        let worstNARate = 0;
        
        modelResults.forEach(model => {
            if (model.naPercentage < bestNARate) {
                bestNARate = model.naPercentage;
                bestModel = model.modelName;
            }
            if (model.naPercentage > worstNARate) {
                worstNARate = model.naPercentage;
                worstModel = model.modelName;
            }
        });
        
        // Add dynamic statistics text
        const dynamicStatsText =
            `We analyzed <span class="stat-value">${modelResults.length}</span> language models across ` +
            `<span class="stat-value">${totalPhenotypes}</span> bacterial phenotype categories, ` +
            `generating an average of <span class="stat-value">${Math.round(avgPredictionsPerModel)}</span> predictions per model. ` +
            `The models showed varying levels of confidence in their predictions, with an average NA rate of <span class="stat-value">${avgNAPercentage.toFixed(1)}%</span>. ` +
            (bestModel ? `<span class="model-highlight">${formatModelName(bestModel)}</span> demonstrated the highest confidence ` +
                `with only <span class="stat-value">${bestNARate.toFixed(1)}%</span> NA responses, ` : '') +
            (worstModel && worstModel !== bestModel ? `while <span class="model-lowlight">${formatModelName(worstModel)}</span> ` +
                `was more conservative with <span class="stat-value">${worstNARate.toFixed(1)}%</span> NA responses.` : '');
        
        const statsTarget = document.getElementById('dynamicStatsText');
        if (statsTarget) statsTarget.innerHTML = dynamicStatsText;
        
        // Consensus Agreement Ranking
        html += renderConsensusRanking(consensusAnalysis);
        
        // Model distributions
        html += renderDistributionsView(modelResults);
        
        content.innerHTML = html;
        
        // Show hidden phenotypes info in the standard article section
        const hiddenPhenotypes = getHiddenPhenotypes();
        const hiddenSection = document.getElementById('hiddenPhenotypesSection');
        if (hiddenSection && hiddenPhenotypes.length > 0) {
            let hiddenHtml = '<div class="hidden-phenotypes-info">';
            hiddenHtml += '<h4>Hidden Phenotype Fields</h4>';
            hiddenHtml += '<p>The following phenotype fields are not shown because they are complex multi-select data types:</p>';
            hiddenHtml += '<ul>';
            hiddenPhenotypes.forEach(phenotype => {
                hiddenHtml += `<li><strong>${phenotype.name}</strong> not shown since it is datatype ${phenotype.fieldType}</li>`;
            });
            hiddenHtml += '</ul>';
            hiddenHtml += '</div>';
            hiddenSection.innerHTML = hiddenHtml;
        }
    }
    
    function generatePhenotypeLegend(phenotypeKey) {
        if (!templateData || !templateData.legend_data) {
            // Fallback to a simple legend
            return '<div class="phenotype-legend"><div class="legend-item"><span class="legend-label">Loading template data...</span></div></div>';
        }
        
        const legendInfo = templateData.legend_data[phenotypeKey];
        if (!legendInfo) {
            // No legend data for this field
            return '<div class="phenotype-legend"><div class="legend-item"><span class="legend-label">No legend data available</span></div></div>';
        }
        
        let html = '<div class="phenotype-legend">';
        
        legendInfo.items.forEach(item => {
            html += `<div class="legend-item">`;
            html += `<div class="legend-color" style="background-color: ${item.background}; color: ${item.color}; border: 1px solid rgba(0,0,0,0.1);"></div>`;
            html += `<span class="legend-label">${item.label}</span>`;
            html += `</div>`;
        });
        
        // Always add Invalid Response and NA to legend
        html += `<div class="legend-item">`;
        html += `<div class="legend-color" style="background-color: #ffcdd2; color: #c62828; border: 1px dashed #c62828;"></div>`;
        html += `<span class="legend-label">Invalid Response</span>`;
        html += `</div>`;
        
        html += `<div class="legend-item">`;
        html += `<div class="legend-color" style="background-color: #e2e3e5; color: #6c757d; border: 1px solid rgba(0,0,0,0.1);"></div>`;
        html += `<span class="legend-label">NA/Not Available</span>`;
        html += `</div>`;
        
        html += '</div>';
        return html;
    }
    
    function renderPhenotypeCard(phenotypeKey, phenotypeInfo, modelResults) {
        let html = `<div class="phenotype-card">`;
        
        // Get field type info from template data
        let fieldTypeInfo = '';
        if (templateData && templateData.legend_data && templateData.legend_data[phenotypeKey]) {
            const fieldType = templateData.legend_data[phenotypeKey].field_type;
            const typeLabels = {
                'binary': 'Binary',
                'categorical': 'Categorical', 
                'multi-select': 'Multi-select'
            };
            fieldTypeInfo = ` <span class="field-type-badge field-type-${fieldType}">${typeLabels[fieldType] || fieldType}</span>`;
        }
        
        html += `<div class="phenotype-card-header">`;
        html += `<h4 class="phenotype-card-title">${phenotypeInfo.name}${fieldTypeInfo}</h4>`;
        html += `</div>`;
        
        // Add legend
        html += generatePhenotypeLegend(phenotypeKey);
        
        html += `<table class="phenotype-analysis-table">`;
        
        // Header row
        html += `<thead><tr>`;
        html += `<th style="text-align: left;">Model</th>`;
        html += `<th>Prediction Distribution</th>`;
        html += `<th>NA %</th>`;
        html += `</tr></thead>`;
        
        // Data rows
        html += `<tbody>`;
        
        modelResults.forEach(result => {
            const distribution = result.phenotypeDistributions[phenotypeKey] || {};
            const total = Object.values(distribution).reduce((sum, count) => sum + count, 0);
            const naCount = distribution['NA'] || 0;
            const naRate = total > 0 ? (naCount / total * 100) : 0;
            
            html += `<tr>`;
            html += `<td class="model-name-cell">${formatModelName(result.modelName)}</td>`;
            
            html += `<td class="chart-cell">
                        ${renderValueDistributionBar(distribution, total, phenotypeKey)}
                     </td>`;
            
            html += `<td style="text-align: center; font-weight: 600; color: ${naRate > 50 ? '#dc3545' : naRate > 20 ? '#ffc107' : '#28a745'};">
                        ${naRate.toFixed(1)}%
                     </td>`;
            html += `</tr>`;
        });
        
        html += `</tbody></table>`;
        html += `</div>`;
        
        return html;
    }
    
    function renderValueDistributionBar(distribution, total, phenotypeKey) {
        if (total === 0) {
            return '<div class="no-data">No data</div>';
        }
        
        // Get value ordering from template data
        let preferredOrder = [];
        if (templateData && templateData.value_orderings && templateData.value_orderings[phenotypeKey]) {
            preferredOrder = templateData.value_orderings[phenotypeKey];
        }
        
        // Sort values by preferred order, then alphabetically, with NA always last
        const sortedValues = Object.entries(distribution)
            .sort((a, b) => {
                const [valueA] = a;
                const [valueB] = b;
                
                // NA always goes last
                if (valueA === 'NA' || valueA === 'N/A' || valueA === '') return 1;
                if (valueB === 'NA' || valueB === 'N/A' || valueB === '') return -1;
                
                // Use preferred order if available
                const indexA = preferredOrder.findIndex(order => valueA.toLowerCase().includes(order.toLowerCase()));
                const indexB = preferredOrder.findIndex(order => valueB.toLowerCase().includes(order.toLowerCase()));
                
                if (indexA !== -1 && indexB !== -1) return indexA - indexB;
                if (indexA !== -1) return -1;
                if (indexB !== -1) return 1;
                
                // Fallback to alphabetical
                return valueA.localeCompare(valueB);
            });
        
        let html = '<div class="single-bar-chart">';
        html += '<div class="single-stacked-bar">';
        
        sortedValues.forEach(([value, count]) => {
            const percentage = (count / total * 100);
            const colors = getValueColors(value, phenotypeKey);
            
            if (percentage > 0) {
                html += `<div class="bar-segment" style="width: ${percentage}%; background-color: ${colors.background}; color: ${colors.color};">`;
                
                // Show count for larger segments
                if (percentage > 5) {
                    html += `<span class="bar-number">${count}</span>`;
                }
                
                html += `</div>`;
            }
        });
        
        html += '</div>';
        html += '</div>';
        
        return html;
    }
    
    function getValueColors(value, phenotypeKey) {
        // Default colors for NA or unknown values
        const defaultColors = {
            background: '#e2e3e5',
            color: '#6c757d'
        };
        
        if (value === 'NA' || value === 'N/A' || value === '') {
            return defaultColors;
        }
        
        // Check for invalid values
        if (typeof value === 'string' && value.startsWith('Invalid:')) {
            return {
                background: '#ffcdd2',
                color: '#c62828'
            };
        }
        
        // Try to get colors from template data
        if (templateData && templateData.color_mappings && templateData.color_mappings[phenotypeKey]) {
            const colorMapping = templateData.color_mappings[phenotypeKey];
            
            // Direct match first
            if (colorMapping[value]) {
                return {
                    background: colorMapping[value].background,
                    color: colorMapping[value].color
                };
            }
            
            // Try case-insensitive match for boolean values
            const lowerValue = value.toString().toLowerCase();
            if (lowerValue === 'true' && colorMapping['TRUE']) {
                return {
                    background: colorMapping['TRUE'].background,
                    color: colorMapping['TRUE'].color
                };
            }
            if (lowerValue === 'false' && colorMapping['FALSE']) {
                return {
                    background: colorMapping['FALSE'].background,
                    color: colorMapping['FALSE'].color
                };
            }
            
            // Try partial matching for complex values
            for (const [mappedValue, colors] of Object.entries(colorMapping)) {
                if (lowerValue.includes(mappedValue.toLowerCase()) || 
                    mappedValue.toLowerCase().includes(lowerValue)) {
                    return {
                        background: colors.background,
                        color: colors.color
                    };
                }
            }
        }
        
        // Fallback to default colors for unmatched values
        return {
            background: '#f8f9fa',
            color: '#495057'
        };
    }
    
    // Tooltip functions
    let phenotypeTooltip = null;
    
    function showPhenotypeTooltip(event, element) {
        const distribution = JSON.parse(element.getAttribute('data-distribution'));
        const phenotype = element.getAttribute('data-phenotype');
        const model = element.getAttribute('data-model');
        
        // Hide any existing tooltip
        hidePhenotypeTooltip();
        
        // Create tooltip
        phenotypeTooltip = document.createElement('div');
        phenotypeTooltip.className = 'phenotype-tooltip';
        
        let html = `<div class="phenotype-tooltip-content">`;
        html += `<div class="phenotype-tooltip-header">${formatModelName(model)}</div>`;
        
        // Sort values by count
        const sortedValues = Object.entries(distribution)
            .sort((a, b) => b[1] - a[1]);
        
        html += '<div class="phenotype-tooltip-stats">';
        sortedValues.forEach(([value, count]) => {
            html += `<div class="tooltip-stat">`;
            html += `<span class="tooltip-stat-label">${value}:</span> `;
            html += `<span class="tooltip-stat-value">${count}</span>`;
            html += `</div>`;
        });
        html += '</div>';
        
        html += '</div>';
        
        phenotypeTooltip.innerHTML = html;
        document.body.appendChild(phenotypeTooltip);
        
        // Position tooltip
        const rect = element.getBoundingClientRect();
        const tooltipRect = phenotypeTooltip.getBoundingClientRect();
        
        let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);
        let top = rect.top - tooltipRect.height - 10;
        
        // Ensure tooltip stays on screen
        if (left < 10) left = 10;
        if (left + tooltipRect.width > window.innerWidth - 10) {
            left = window.innerWidth - tooltipRect.width - 10;
        }
        
        // If tooltip would go above screen, show below
        if (top < 10) {
            top = rect.bottom + 10;
        }
        
        phenotypeTooltip.style.left = left + 'px';
        phenotypeTooltip.style.top = top + 'px';
    }
    
    function hidePhenotypeTooltip() {
        if (phenotypeTooltip) {
            phenotypeTooltip.remove();
            phenotypeTooltip = null;
        }
    }

    // Consensus Analysis Functions
    function calculateConsensusAnalysis(modelResults) {
        const consensus = {};
        const modelDeviations = {};
        
        // Calculate consensus for each phenotype
        Object.keys(phenotypes).forEach(phenotype => {
            if (!shouldShowPhenotype(phenotype)) return;
            
            // Collect all unique values across all models
            const allValues = new Set();
            modelResults.forEach(model => {
                if (model.phenotypeDistributions[phenotype]) {
                    Object.keys(model.phenotypeDistributions[phenotype]).forEach(value => {
                        allValues.add(value);
                    });
                }
            });
            
            // Calculate consensus percentages
            const consensusDistribution = {};
            allValues.forEach(value => {
                let totalCount = 0;
                let totalPredictions = 0;
                
                modelResults.forEach(model => {
                    const modelDist = model.phenotypeDistributions[phenotype] || {};
                    const valueCount = modelDist[value] || 0;
                    const modelTotal = Object.values(modelDist).reduce((sum, count) => sum + count, 0);
                    
                    if (modelTotal > 0) {
                        totalCount += (valueCount / modelTotal);
                        totalPredictions += 1;
                    }
                });
                
                if (totalPredictions > 0) {
                    consensusDistribution[value] = (totalCount / totalPredictions) * 100;
                }
            });
            
            consensus[phenotype] = consensusDistribution;
        });
        
        // Calculate deviation metrics for each model
        modelResults.forEach(model => {
            const deviations = {};
            let totalDeviation = 0;
            let phenotypeCount = 0;
            
            Object.keys(phenotypes).forEach(phenotype => {
                if (!shouldShowPhenotype(phenotype)) return;
                
                const modelDist = model.phenotypeDistributions[phenotype] || {};
                const consensusDist = consensus[phenotype] || {};
                const modelTotal = Object.values(modelDist).reduce((sum, count) => sum + count, 0);
                
                if (modelTotal > 0) {
                    // Convert to percentages
                    const modelPercentages = {};
                    Object.entries(modelDist).forEach(([value, count]) => {
                        modelPercentages[value] = (count / modelTotal) * 100;
                    });
                    
                    // Calculate Jensen-Shannon divergence
                    const jsDivergence = calculateJSDivergence(modelPercentages, consensusDist);
                    
                    // Calculate Mean Absolute Deviation
                    const mad = calculateMAD(modelPercentages, consensusDist);
                    
                    deviations[phenotype] = {
                        jsDivergence: jsDivergence,
                        mad: mad,
                        significant: jsDivergence > 0.1 // Threshold for "significant" deviation
                    };
                    
                    totalDeviation += jsDivergence;
                    phenotypeCount++;
                }
            });
            
            modelDeviations[model.modelName] = {
                phenotypeDeviations: deviations,
                averageDeviation: phenotypeCount > 0 ? totalDeviation / phenotypeCount : 0,
                significantDeviations: Object.values(deviations).filter(d => d.significant).length
            };
        });
        
        return { consensus, modelDeviations };
    }
    
    function calculateJSDivergence(p, q) {
        // Jensen-Shannon divergence between two probability distributions
        const allKeys = new Set([...Object.keys(p), ...Object.keys(q)]);
        
        let jsDiv = 0;
        const pArray = [];
        const qArray = [];
        
        allKeys.forEach(key => {
            const pVal = (p[key] || 0) / 100; // Convert percentage to probability
            const qVal = (q[key] || 0) / 100;
            pArray.push(pVal);
            qArray.push(qVal);
        });
        
        // Calculate M = (P + Q) / 2
        const mArray = pArray.map((pVal, i) => (pVal + qArray[i]) / 2);
        
        // Calculate KL divergences
        let klPM = 0;
        let klQM = 0;
        
        for (let i = 0; i < pArray.length; i++) {
            if (pArray[i] > 0 && mArray[i] > 0) {
                klPM += pArray[i] * Math.log2(pArray[i] / mArray[i]);
            }
            if (qArray[i] > 0 && mArray[i] > 0) {
                klQM += qArray[i] * Math.log2(qArray[i] / mArray[i]);
            }
        }
        
        return (klPM + klQM) / 2;
    }
    
    function calculateMAD(modelDist, consensusDist) {
        // Mean Absolute Deviation
        const allKeys = new Set([...Object.keys(modelDist), ...Object.keys(consensusDist)]);
        let totalDeviation = 0;
        
        allKeys.forEach(key => {
            const modelVal = modelDist[key] || 0;
            const consensusVal = consensusDist[key] || 0;
            totalDeviation += Math.abs(modelVal - consensusVal);
        });
        
        return totalDeviation / allKeys.size;
    }
    
    function renderConsensusRanking(consensusAnalysis) {
        let html = '';
        // Model ranking by deviation
        const rankedModels = Object.entries(consensusAnalysis.modelDeviations)
            .sort((a, b) => a[1].averageDeviation - b[1].averageDeviation);
        
        html += '<div class="model-ranking">';
        html += '<h5>Model Consensus Agreement Ranking</h5>';
        html += '<div class="ranking-explanation">Models are sorted by their average deviation from the consensus prediction patterns. Lower scores indicate better agreement with the overall trend.</div>';
        
        html += '<table class="consensus-ranking-table">';
        html += '<thead>';
        html += '<tr>';
        html += '<th>Model<br><span style="font-weight: normal; font-size: 10px; color: #6c757d; font-style: italic;">Language model used</span></th>';
        html += '<th>Avg. JS Divergence<br><span style="font-weight: normal; font-size: 10px; color: #6c757d; font-style: italic;">Avg. difference from consensus (0 is best)</span></th>';
        html += '<th>Outlier Phenotypes<br><span style="font-weight: normal; font-size: 10px; color: #6c757d; font-style: italic;">Count of phenotypes with JS > 0.1 from consensus</span></th>';
        html += '<th>Agreement Level<br><span style="font-weight: normal; font-size: 10px; color: #6c757d; font-style: italic;">Overall consensus agreement category</span></th>';
        html += '</tr>';
        html += '</thead>';
        html += '<tbody>';
        
        rankedModels.forEach(([modelName, metrics]) => {
            const agreementLevel = getAgreementLevel(metrics.averageDeviation);
            
            let significantPhenotypesHtml = `<span class="significant-count">${metrics.significantDeviations}</span>`;
            if (metrics.significantDeviations > 0) {
                const significantPhenotypeNames = Object.entries(metrics.phenotypeDeviations)
                    .filter(([phenotypeKey, deviationMetrics]) => deviationMetrics.significant)
                    .map(([phenotypeKey, deviationMetrics]) => phenotypes[phenotypeKey].name);
                
                significantPhenotypesHtml += `<div class="significant-phenotypes-list">${significantPhenotypeNames.join(', ')}</div>`;
            }

            html += '<tr>';
            html += `<td class="model-name">${formatModelName(modelName)}</td>`;
            html += `<td><span class="deviation-score">${metrics.averageDeviation.toFixed(3)}</span></td>`;
            html += `<td>${significantPhenotypesHtml}</td>`;
            html += `<td><span class="agreement-badge agreement-${agreementLevel.class}">${agreementLevel.label}</span></td>`;
            html += '</tr>';
        });
        
        html += '</tbody>';
        html += '</table>';
        html += '</div>';
        return html;
    }
    
    function getAgreementLevel(deviation) {
        if (deviation < 0.05) {
            return { class: 'high', label: 'High Agreement' };
        } else if (deviation < 0.1) {
            return { class: 'moderate', label: 'Moderate Agreement' };
        } else if (deviation < 0.2) {
            return { class: 'low', label: 'Low Agreement' };
        } else {
            return { class: 'outlier', label: 'Outlier' };
        }
    }
    
    function renderDistributionsView(modelResults) {
        // Display results in a grid layout with full-width section
        let html = '</div></div>'; // Close section-callout__content and section-callout
        
        // Create new full-width section for distributions
        html += '<section class="section-wide">';
        html += '<div class="section-wide__content">';
        html += '<h2 class="section-title" style="text-align: center; margin-bottom: var(--spacing-section);">Model Prediction Distributions by Phenotype</h2>';
        html += '<div class="phenotype-grid">';
        
        // Filter phenotypes by visible field types
        Object.entries(phenotypes).forEach(([phenotypeKey, phenotypeInfo]) => {
            if (shouldShowPhenotype(phenotypeKey)) {
                html += renderPhenotypeCard(phenotypeKey, phenotypeInfo, modelResults);
            }
        });
        
        html += '</div>';
        html += '</div>';
        html += '</section>';
        
        // Re-open the callout section
        html += '<section class="section-callout section-callout--purple">';
        html += '<div class="section-callout__content">';
        
        return html;
    }
</script>
{% endblock %} 