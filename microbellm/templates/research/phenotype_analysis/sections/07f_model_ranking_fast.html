<!-- Cached Overall Model Performance Ranking -->
<div id="modelRankingFastContent" class="ranking-section">
  <style>
  .ranking-section { padding: 0; background: transparent; }

  .ranking-controls-panel {
    display: flex;
    gap: 20px;
    align-items: flex-end;
    margin-bottom: 30px;
    padding: 20px;
    background: #f8f9fa;
    border-radius: 8px;
    border: 1px solid #dee2e6;
    flex-wrap: wrap;
  }

  .ranking-dataset-selector { flex: 1; min-width: 220px; }
  .ranking-dataset-selector label { display: block; margin-bottom: 8px; font-weight: 500; color: #495057; font-size: 14px; }
  .ranking-dataset-select { width: 100%; padding: 10px 12px; border: 1px solid #ced4da; border-radius: 6px; background: white; color: #495057; font-size: 14px; cursor: pointer; }
  .ranking-dataset-select:focus { outline: none; border-color: #22c55e; box-shadow: 0 0 0 3px rgba(34,197,94,0.1); }
  .ranking-dataset-details { margin-top: 8px; font-size: 12px; color: #6c757d; display: flex; flex-direction: column; gap: 4px; min-height: 32px; }

  .cache-controls { display: flex; flex-direction: column; align-items: flex-start; gap: 8px; min-width: 220px; }
  .refresh-button { display: inline-flex; align-items: center; gap: 8px; padding: 10px 16px; background: #22c55e; color: #fff; border: none; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer; transition: background 0.2s ease, box-shadow 0.2s ease; }
  .refresh-button:hover { background: #16a34a; box-shadow: 0 8px 14px rgba(34,197,94,0.2); }
  .refresh-button:disabled { background: #d1d5db; color: #6b7280; cursor: not-allowed; box-shadow: none; }
  .refresh-button.loading { background: #1e40af; box-shadow: 0 8px 14px rgba(30,64,175,0.2); }
  .refresh-button .fa-sync-alt { transition: transform 0.4s ease; }
  .refresh-button.loading .fa-sync-alt { animation: spin 1s linear infinite; }
  .cache-meta { font-size: 12px; color: #6c757d; line-height: 1.4; max-width: 260px; }
  .cache-meta strong { color: #111827; }
  @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

  .ranking-plot-container { display: none; background: white; border-radius: 12px; padding: 32px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05); }
  .ranking-plot-header { text-align: center; margin-bottom: 40px; }
  .ranking-plot-title { font-size: 28px; font-weight: 700; color: #1a202c; margin: 0 0 8px 0; }
  .ranking-plot-subtitle { font-size: 15px; color: #718096; font-weight: 400; }

  .ranking-panels { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
  .ranking-panel { background: #fafbfc; border: 1px solid #e1e4e8; border-radius: 10px; padding: 24px; position: relative; }
  .panel-title { font-size: 18px; font-weight: 600; color: #2d3748; margin: 0 0 24px 0; text-align: center; padding-bottom: 16px; border-bottom: 2px solid #e2e8f0; }
  .ranking-svg-container { width: 100%; overflow-x: auto; }

  .ranking-loading { text-align: center; padding: 60px 20px; color: #6c757d; }
  .ranking-loading i { font-size: 48px; color: #dee2e6; margin-bottom: 16px; }

  .ranking-model-label { font-size: 11px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; fill: #4a5568; font-weight: 500; }
  .ranking-bar { cursor: pointer; transition: all 0.3s ease; }
  .ranking-bar-balanced { fill: url(#blueGradient); }
  .ranking-bar-balanced:hover { filter: brightness(1.1); }
  .ranking-bar-precision { fill: url(#purpleGradient); }
  .ranking-bar-precision:hover { filter: brightness(1.1); }
  .ranking-value-label { font-size: 10px; font-weight: 700; fill: #2d3748; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; }
  .ranking-axis-label { font-size: 13px; font-weight: 600; fill: #4a5568; }
  .ranking-gridline { stroke: #e2e8f0; stroke-width: 0.5; opacity: 0.5; }
  .ranking-axis-line { stroke: #cbd5e0; stroke-width: 1; }

  @media (max-width: 1024px) { .ranking-panels { grid-template-columns: 1fr; } }
  </style>

  <div class="ranking-controls-panel">
    <div class="ranking-dataset-selector">
      <label for="rankingGroundTruthDataset">Ground Truth Dataset:</label>
      <select id="rankingGroundTruthDataset" class="ranking-dataset-select">
        <option value="">Loading datasets...</option>
      </select>
      <div class="ranking-dataset-details" id="rankingDatasetDetails"></div>
    </div>
    <div class="cache-controls">
      <button id="rankingRefreshSnapshot" class="refresh-button" disabled>
        <i class="fas fa-sync-alt" aria-hidden="true"></i>
        <span>Refresh Snapshot</span>
      </button>
      <div class="cache-meta" id="rankingCacheMeta">Select a dataset to load cached metrics</div>
    </div>
  </div>

  <div id="rankingPlotContainer" class="ranking-plot-container">
    <div class="ranking-plot-header">
      <h2 class="ranking-plot-title">Overall LLM Performance</h2>
      <p class="ranking-plot-subtitle">Average performance across all phenotypes</p>
    </div>
    <div class="ranking-panels">
      <div class="ranking-panel">
        <h3 class="panel-title">Balanced Accuracy</h3>
        <div id="rankingBalAccSvg" class="ranking-svg-container"></div>
      </div>
      <div class="ranking-panel">
        <h3 class="panel-title">Precision</h3>
        <div id="rankingPrecisionSvg" class="ranking-svg-container"></div>
      </div>
    </div>
  </div>

  <div class="ranking-loading" id="rankingLoadingState">
    <i class="fas fa-chart-bar"></i>
    <p>Select a dataset to view overall model performance rankings</p>
  </div>
</div>

<script>
(function() {
  'use strict';

  const datasetSelect = document.getElementById('rankingGroundTruthDataset');
  const datasetDetails = document.getElementById('rankingDatasetDetails');
  const cacheMetaEl = document.getElementById('rankingCacheMeta');
  const refreshBtn = document.getElementById('rankingRefreshSnapshot');
  const loadingState = document.getElementById('rankingLoadingState');

  let currentMetrics = [];
  let selectedDataset = null;
  let isLoading = false;

  function init() {
    loadDatasets();
    refreshBtn.addEventListener('click', () => {
      if (!selectedDataset || isLoading) return;
      fetchCachedMetrics(true);
    });
  }

  async function loadDatasets() {
    try {
      const response = await fetch('/api/ground_truth/datasets');
      if (!response.ok) throw new Error(`HTTP error: ${response.status}`);
      const result = await response.json();
      if (!result.success) throw new Error(result.error || 'Failed to load datasets');

      datasetSelect.innerHTML = '';
      if (result.datasets.length === 0) {
        const opt = document.createElement('option');
        opt.value = '';
        opt.textContent = 'No datasets available';
        datasetSelect.appendChild(opt);
        cacheMetaEl.textContent = 'Import a dataset to generate metrics';
        refreshBtn.disabled = true;
        return;
      }

      const defaultOpt = document.createElement('option');
      defaultOpt.value = '';
      defaultOpt.textContent = 'Select a dataset...';
      datasetSelect.appendChild(defaultOpt);

      let defaultDataset = null;
      result.datasets.forEach(dataset => {
        const opt = document.createElement('option');
        opt.value = dataset.dataset_name;
        opt.textContent = dataset.dataset_name;
        opt.dataset.template = dataset.template_name || '';
        opt.dataset.count = dataset.species_count || 0;
        datasetSelect.appendChild(opt);
        if (dataset.dataset_name === 'WA_Test_Dataset') defaultDataset = dataset.dataset_name;
      });

      datasetSelect.addEventListener('change', handleDatasetChange);
      if (defaultDataset) {
        datasetSelect.value = defaultDataset;
        handleDatasetChange();
      } else {
        refreshBtn.disabled = true;
        cacheMetaEl.textContent = 'Select a dataset to load cached metrics';
      }
    } catch (error) {
      console.error('Error loading datasets:', error);
      datasetSelect.innerHTML = '';
      const errorOpt = document.createElement('option');
      errorOpt.value = '';
      errorOpt.textContent = 'Error loading datasets - refresh';
      datasetSelect.appendChild(errorOpt);
      cacheMetaEl.textContent = 'Unable to reach dataset API';
      refreshBtn.disabled = true;
    }
  }

  function handleDatasetChange() {
    selectedDataset = datasetSelect.value || null;
    if (!selectedDataset) {
      datasetDetails.innerHTML = '';
      cacheMetaEl.textContent = 'Select a dataset to load cached metrics';
      refreshBtn.disabled = true;
      loadingState.style.display = 'block';
      document.getElementById('rankingPlotContainer').style.display = 'none';
      currentMetrics = [];
      return;
    }

    refreshBtn.disabled = false;
    cacheMetaEl.textContent = 'Fetching cached metrics...';
    datasetDetails.innerHTML = '<span><i class="fas ц-sync-alt"></i> Loading snapshot...</span>';
    fetchCachedMetrics(false);
  }

  async function fetchCachedMetrics(forceRefresh) {
    if (!selectedDataset) return;
    isLoading = true;
    refreshBtn.disabled = true;
    refreshBtn.classList.add('loading');
    refreshBtn.querySelector('span').textContent = forceRefresh ? 'Refreshing...' : 'Loading...';

    try {
      const refreshParam = forceRefresh ? '&refresh=1' : '';
      const url = `/api/model_accuracy_cached?dataset_name=${encodeURIComponent(selectedDataset)}${refreshParam}`;
      const response = await fetch(url);
      const json = await response.json();
      if (!json.success) throw new Error(json.error || 'Failed to load cached metrics');

      currentMetrics = json.metrics || [];
      updateDetails(json);
      updateCacheMeta(json.cache_info || {});

      if (currentMetrics.length) {
        renderRankings();
      } else {
        loadingState.style.display = 'block';
        document.getElementById('rankingPlotContainer').style.display = 'none';
      }
    } catch (error) {
      console.error('Failed to fetch cached model rankings:', error);
      datasetDetails.innerHTML = '<span style="color:#dc2626;">Snapshot unavailable</span>';
      cacheMetaEl.textContent = error.message || 'Error fetching metrics';
      loadingState.style.display = 'block';
      document.getElementById('rankingPlotContainer').style.display = 'none';
      currentMetrics = [];
    } finally {
      refreshBtn.disabled = !selectedDataset;
      refreshBtn.classList.remove('loading');
      refreshBtn.querySelector('span').textContent = 'Refresh Snapshot';
      isLoading = false;
    }
  }

  function updateDetails(payload) {
    const meta = payload.metadata || {};
    const summary = payload.summary || {};
    const totalSpecies = summary.ground_truth_species || 0;
    const modelCount = summary.model_count || 0;
    const predictionCount = summary.prediction_count || 0;
    const phenotypes = summary.phenotype_count || 0;

    const importDate = formatTimestamp(meta.import_date);
    const importLine = importDate ? `Imported ${importDate}` : 'Import timestamp unavailable';

    datasetDetails.innerHTML = `
      <span><strong>${modelCount} models</strong> · ${phenotypes} phenotypes</span>
      <span>${predictionCount.toLocaleString()} predictions · ${totalSpecies.toLocaleString()} ground truth species</span>
      <span>${importLine}</span>
    `;
  }

  function updateCacheMeta(cacheInfo) {
    if (!cacheInfo || (!cacheInfo.cached && cacheInfo.cached !== false)) {
      cacheMetaEl.textContent = 'Snapshot status unknown';
      return;
    }
    const computed = formatTimestamp(cacheInfo.computed_at);
    const age = cacheInfo.age_seconds != null ? formatRelativeAge(cacheInfo.age_seconds) : null;
    const status = cacheInfo.cached ? 'Using cached snapshot' : 'Snapshot refreshed';
    let text = `<strong>${status}</strong>`;
    if (computed) text += ` · computed ${computed}`;
    if (age) text += ` · ${age} old`;
    cacheMetaEl.innerHTML = text;
  }

  function calculateOverallRankings(metrics) {
    const excludedPhenotypes = ['aerophilicity', 'health_association', 'hemolysis'];
    const filtered = metrics.filter(m => !excludedPhenotypes.includes(m.phenotype));
    const groups = {};
    filtered.forEach(m => {
      if (!groups[m.model]) {
        groups[m.model] = { balancedAcc: [], precision: [], sampleSizes: [], phenotypes: new Set() };
      }
      if (Number.isFinite(m.balancedAcc)) groups[m.model].balancedAcc.push(m.balancedAcc);
      if (Number.isFinite(m.precision)) groups[m.model].precision.push(m.precision);
      groups[m.model].sampleSizes.push(m.sampleSize);
      groups[m.model].phenotypes.add(m.phenotype);
    });

    const rankings = [];
    Object.entries(groups).forEach(([model, group]) => {
      if (!group.balancedAcc.length || !group.precision.length) return;
      const avgBalAcc = group.balancedAcc.reduce((a, b) => a + b, 0) / group.balancedAcc.length;
      const avgPrecision = group.precision.reduce((a, b) => a + b, 0) / group.precision.length;
      const avgSampleSize = group.sampleSizes.length ? Math.round(group.sampleSizes.reduce((a, b) => a + b, 0) / group.sampleSizes.length) : 0;
      rankings.push({
        model,
        balancedAcc: avgBalAcc,
        precision: avgPrecision,
        avgSampleSize,
        phenotypeCount: group.phenotypes.size
      });
    });

    rankings.sort((a, b) => b.balancedAcc - a.balancedAcc);
    return rankings;
  }

  function renderRankings() {
    const rankings = calculateOverallRankings(currentMetrics);
    if (!rankings.length) {
      loadingState.style.display = 'block';
      document.getElementById('rankingPlotContainer').style.display = 'none';
      return;
    }

    loadingState.style.display = 'none';
    document.getElementById('rankingPlotContainer').style.display = 'block';

    renderRankingChart(rankings, 'balancedAcc', 'rankingBalAccSvg');
    renderRankingChart(rankings, 'precision', 'rankingPrecisionSvg');
  }

  function renderRankingChart(data, metric, containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    container.innerHTML = '';

    const margin = { top: 40, right: 60, bottom: 40, left: 140 };
    const barHeight = 24;
    const gap = 8;
    const height = margin.top + margin.bottom + data.length * (barHeight + gap);
    const width = Math.max(600, container.clientWidth || 700);
    const chartWidth = width - margin.left - margin.right;

    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.setAttribute('width', '100%');
    svg.setAttribute('height', height);
    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
    container.appendChild(svg);

    const xScale = (value) => {
      const t = Math.max(0, Math.min(1, (value - 0.5) / 0.5));
      return margin.left + t * chartWidth;
    };
    const yScale = (index) => margin.top + index * (barHeight + gap) + barHeight / 2;

    const defs = document.createElementNS(svg.namespaceURI, 'defs');
    defs.innerHTML = `
      <linearGradient id="blueGradient" x1="0" y1="0" x2="1" y2="0">
        <stop offset="0%" stop-color="#3b82f6" stop-opacity="0.7" />
        <stop offset="100%" stop-color="#1d4ed8" stop-opacity="1" />
      </linearGradient>
      <linearGradient id="purpleGradient" x1="0" y1="0" x2="1" y2="0">
        <stop offset="0%" stop-color="#a855f7" stop-opacity="0.7" />
        <stop offset="100%" stop-color="#7c3aed" stop-opacity="1" />
      </linearGradient>`;
    svg.appendChild(defs);

    const axisGroup = document.createElementNS(svg.namespaceURI, 'g');
    svg.appendChild(axisGroup);

    for (let t = 0.5; t <= 1.0001; t += 0.1) {
      const x = xScale(Number(t.toFixed(10)));
      const gridline = document.createElementNS(svg.namespaceURI, 'line');
      gridline.setAttribute('x1', x);
      gridline.setAttribute('x2', x);
      gridline.setAttribute('y1', margin.top - 10);
      gridline.setAttribute('y2', height - margin.bottom + 10);
      gridline.setAttribute('class', 'ranking-gridline');
      axisGroup.appendChild(gridline);

      const label = document.createElementNS(svg.namespaceURI, 'text');
      label.setAttribute('x', x);
      label.setAttribute('y', height - margin.bottom + 20);
      label.setAttribute('text-anchor', 'middle');
      label.setAttribute('class', 'ranking-model-label');
      label.textContent = t.toFixed(1);
      axisGroup.appendChild(label);
    }

    data.forEach((item, index) => {
      const y = yScale(index);
      const shortName = item.model.includes('/') ? item.model.split('/').pop() : item.model;

      const label = document.createElementNS(svg.namespaceURI, 'text');
      label.setAttribute('x', margin.left - 10);
      label.setAttribute('y', y);
      label.setAttribute('text-anchor', 'end');
      label.setAttribute('dominant-baseline', 'middle');
      label.setAttribute('class', 'ranking-model-label');
      label.textContent = shortName;
      svg.appendChild(label);

      const x = margin.left;
      const widthValue = xScale(item[metric]) - margin.left;
      const rect = document.createElementNS(svg.namespaceURI, 'rect');
      rect.setAttribute('x', x);
      rect.setAttribute('y', y - barHeight / 2);
      rect.setAttribute('width', Math.max(0, widthValue));
      rect.setAttribute('height', barHeight);
      rect.setAttribute('rx', 4);
      rect.setAttribute('class', `ranking-bar ${metric === 'balancedAcc' ? 'ranking-bar-balanced' : 'ranking-bar-precision'}`);
      rect.innerHTML = `<title>${item.model}\n${metric === 'balancedAcc' ? 'Balanced Accuracy' : 'Precision'}: ${item[metric].toFixed(3)}\nPhenotypes: ${item.phenotypeCount}\nAvg Sample Size: ${item.avgSampleSize}</title>`;
      svg.appendChild(rect);

      const valueLabel = document.createElementNS(svg.namespaceURI, 'text');
      valueLabel.setAttribute('x', xScale(item[metric]) + 8);
      valueLabel.setAttribute('y', y);
      valueLabel.setAttribute('text-anchor', 'start');
      valueLabel.setAttribute('dominant-baseline', 'middle');
      valueLabel.setAttribute('class', 'ranking-value-label');
      valueLabel.textContent = item[metric].toFixed(2);
      svg.appendChild(valueLabel);
    });

    const axisLabel = document.createElementNS(svg.namespaceURI, 'text');
    axisLabel.setAttribute('x', margin.left + chartWidth / 2);
    axisLabel.setAttribute('y', height - 5);
    axisLabel.setAttribute('text-anchor', 'middle');
    axisLabel.setAttribute('class', 'ranking-axis-label');
    axisLabel.textContent = metric === 'balancedAcc' ? 'Balanced Accuracy' : 'Precision';
    svg.appendChild(axisLabel);
  }

  function formatTimestamp(value) {
    if (!value) return '';
    if (value instanceof Date && !isNaN(value)) return value.toLocaleString();
    const str = String(value);
    try {
      const normalized = str.includes('T') ? str : str.replace(' ', 'T');
      const withZone = /Z$/.test(normalized) ? normalized : `${normalized}Z`;
      const date = new Date(withZone);
      if (isNaN(date.getTime())) throw new Error('Invalid date');
      return date.toLocaleString();
    } catch (_) {
      return str;
    }
  }

  function formatRelativeAge(seconds) {
    if (seconds == null) return '';
    if (seconds < 60) return `${Math.max(1, Math.round(seconds))}s`;
    if (seconds < 3600) return `${Math.round(seconds/60)}m`;
    if (seconds < 86400) return `${Math.round(seconds/3600)}h`;
    return `${Math.round(seconds/86400)}d`;
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();
</script>
