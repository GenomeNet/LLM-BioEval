<div id="phenotypeDistributionsContent">
    <!-- This will be populated by JavaScript -->
</div>

<style>
    /* Grid layout for phenotype cards */
    .phenotype-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 24px;
        margin-bottom: 32px;
        width: 100%;
    }
    
    @media (max-width: 1200px) {
        .phenotype-grid {
            grid-template-columns: 1fr;
        }
    }
    
    .phenotype-card {
        background: var(--bg-primary);
        border: 1px solid var(--gray-200);
        border-radius: 12px;
        padding: 20px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
    }
    
    .phenotype-card-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 16px;
        padding-bottom: 12px;
        border-bottom: 1px solid var(--gray-200);
    }
    
    .phenotype-card-title {
        font-size: 18px;
        font-weight: 600;
        color: var(--gray-900);
        margin: 0;
    }
    
    /* Phenotype Analysis Table Styles */
    .phenotype-analysis-table {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 18px;
        font-size: 14px;
    }
    
    .phenotype-analysis-table th,
    .phenotype-analysis-table td {
        padding: 8px 12px;
        border: 1px solid var(--gray-200);
        text-align: left;
    }
    
    .phenotype-analysis-table th {
        background: var(--gray-50);
        font-weight: 600;
    }
    
    .phenotype-card .phenotype-analysis-table th:first-child {
        text-align: left;
    }
    
    .phenotype-card .phenotype-analysis-table th:nth-child(2) {
        text-align: center;
    }
    
    .phenotype-card .phenotype-analysis-table th:last-child {
        text-align: center;
        width: 100px;
    }
    
    .chart-cell {
        width: 100%;
        max-width: 500px;
        padding: 4px 8px;
    }
    
    .phenotype-card .chart-cell {
        max-width: none;
    }
    
    .model-name-cell {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-weight: 600;
        font-size: 13px;
        color: var(--gray-700);
        background-color: var(--gray-50);
        padding-left: 10px;
        font-size: 11px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    
    .no-data {
        text-align: center;
        color: var(--gray-500);
        font-style: italic;
        font-size: 11px;
    }
    
    /* Bar Chart Styles */
    .single-bar-chart {
        width: 100%;
        height: 16px;
    }
    
    .single-stacked-bar {
        width: 100%;
        height: 16px;
        display: flex;
        border: 1px solid #dee2e6;
        border-radius: 2px;
        overflow: hidden;
        background: #f8f9fa;
    }
    
    .bar-segment {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        font-weight: 600;
        position: relative;
        min-width: 16px;
        transition: opacity 0.2s;
    }
    
    .bar-segment:hover {
        opacity: 0.9;
    }
    
    /* Force gradient backgrounds to override any parent styles */
    .section-callout .bar-segment[style*="linear-gradient"],
    .section-callout__content .bar-segment[style*="linear-gradient"],
    .phenotype-card .bar-segment[style*="linear-gradient"] {
        /* Preserve inline styles */
    }
    
    /* Specific gradient classes for fallback */
    .bar-segment.gradient-positive {
        background: linear-gradient(135deg, #4caf50 0%, #45a049 100%) !important;
    }
    
    .bar-segment.gradient-negative {
        background: linear-gradient(135deg, #f44336 0%, #e53935 100%) !important;
    }
    
    .bar-segment.gradient-true {
        background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%) !important;
    }
    
    .bar-segment.gradient-false {
        background: linear-gradient(135deg, #94a3b8 0%, #64748b 100%) !important;
    }
    
    .bar-segment.gradient-na {
        background: linear-gradient(135deg, #e2e3e5 0%, #d6d8db 100%) !important;
    }
    
    .bar-number {
        font-size: 11px;
        font-weight: 600;
        z-index: 1;
        pointer-events: none;
    }
    
    /* Field type badges */
    .field-type-badge {
        display: inline-block;
        font-size: 11px;
        font-weight: 500;
        padding: 2px 8px;
        border-radius: 4px;
        margin-left: 8px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }
    
    .field-type-binary {
        background: rgba(99, 102, 241, 0.1);
        color: #6366f1;
    }
    
    .field-type-categorical {
        background: rgba(34, 197, 94, 0.1);
        color: #059669;
    }
    
    .field-type-multi-select {
        background: rgba(251, 146, 60, 0.1);
        color: #ea580c;
    }
    
    /* Legend styles */
    .phenotype-legend {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        margin-bottom: 16px;
        font-size: 13px;
    }
    
    .legend-item {
        display: flex;
        align-items: center;
        font-size: 12px;
        color: var(--gray-600);
    }
    
    .legend-color {
        width: 16px;
        height: 16px;
        border-radius: 3px;
        margin-right: 6px;
        display: inline-block;
        border: 1px solid rgba(0,0,0,0.1);
    }
    
    /* Ensure legend colors work in section callouts */
    .section-callout .legend-color[style*="linear-gradient"],
    .section-callout__content .legend-color[style*="linear-gradient"] {
        /* Preserve inline styles */
    }
    
    .legend-label {
        color: var(--gray-600);
    }
    
    /* Loading and empty states */
    .loading-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 16px;
        padding: 48px;
        color: var(--gray-600);
    }
    
    .empty-state {
        text-align: center;
        padding: 48px;
        color: var(--gray-600);
    }
    
    .empty-state h3 {
        color: var(--gray-900);
        margin-bottom: 8px;
    }
</style>

<script>
(function() {
    // Component state
    let isComponentViewer = window.location.pathname.includes('/components/');
    let componentInitialized = false;
    
    // Set flag to indicate component is loaded
    window._phenotypeDistributionsReady = true;
    
    // Wait for phenotype data to be available
    function waitForData() {
        // In component viewer, try to fetch real data first
        if (isComponentViewer) {
            fetchRealData();
            return;
        }
        
        // In main page, wait for data from model predictions component
        if (window._phenotypeModelResults) {
            renderDistributions(window._phenotypeModelResults);
        } else {
            // Set up observer for when data becomes available
            Object.defineProperty(window, '_phenotypeModelResults', {
                set: function(value) {
                    window.__phenotypeModelResults = value;
                    if (value && !componentInitialized) {
                        renderDistributions(value);
                    }
                },
                get: function() {
                    return window.__phenotypeModelResults;
                }
            });
        }
        
        // Also listen for custom event
        window.addEventListener('phenotypeDataUpdated', function(event) {
            // Always re-render when we get new data
            renderDistributions(event.detail);
        });
    }
    
    function initializeWithMockData() {
        const mockData = createMockModelResults();
        renderDistributions(mockData);
    }
    
    // Fetch real data in component viewer
    async function fetchRealData() {
        try {
            console.log('[PhenotypeDistributions] Fetching real data...');
            const response = await fetch('/api/phenotype_analysis');
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            
            if (data.error || !data.files || data.files.length === 0) {
                throw new Error('No data available');
            }
            
            // Process the first file
            const firstFile = data.files[0];
            const fileData = data.data[firstFile];
            
            if (!fileData || fileData.length === 0) {
                throw new Error('No data in file');
            }
            
            // Transform data to expected format
            const modelStats = {};
            const phenotypes = {
                'gram_staining': { name: 'Gram Staining' },
                'motility': { name: 'Motility' },
                'aerophilicity': { name: 'Aerophilicity' },
                'biofilm_formation': { name: 'Biofilm Formation' },
                'spore_formation': { name: 'Spore Formation' },
                'cell_shape': { name: 'Cell Shape' }
            };
            
            // Process data
            fileData.forEach(item => {
                const model = item.model;
                if (!modelStats[model]) {
                    modelStats[model] = {
                        totalPredictions: 0,
                        naCount: 0,
                        phenotypeDistributions: {}
                    };
                }
                
                modelStats[model].totalPredictions++;
                
                // Process each phenotype
                Object.keys(phenotypes).forEach(field => {
                    if (!modelStats[model].phenotypeDistributions[field]) {
                        modelStats[model].phenotypeDistributions[field] = {};
                    }
                    
                    let value = item[field];
                    
                    // Handle null/undefined/NA
                    if (value === null || value === undefined || value === 'NA' || value === 'N/A' || value === '') {
                        value = 'NA';
                        modelStats[model].naCount++;
                    }
                    
                    // Handle string representations of arrays (e.g., "['aerobic']")
                    if (typeof value === 'string' && value.startsWith('[') && value.endsWith(']')) {
                        try {
                            // Parse the string as JSON after replacing single quotes with double quotes
                            const arrayValue = JSON.parse(value.replace(/'/g, '"'));
                            if (Array.isArray(arrayValue)) {
                                // For simplicity, use the first value for categorical fields
                                value = arrayValue[0] || 'NA';
                            }
                        } catch (e) {
                            // If parsing fails, try to extract values manually
                            const matches = value.match(/['"]([^'"]+)['"]/g);
                            if (matches && matches.length > 0) {
                                value = matches[0].replace(/['"]/g, '');
                            }
                        }
                    }
                    
                    // Handle arrays
                    if (Array.isArray(value)) {
                        value = value.join(', ');
                    }
                    
                    // Normalize boolean values
                    if (typeof value === 'string') {
                        if (value.toUpperCase() === 'TRUE') value = 'TRUE';
                        else if (value.toUpperCase() === 'FALSE') value = 'FALSE';
                        
                        // Normalize gram staining values
                        if (field === 'gram_staining') {
                            if (value.toLowerCase().includes('positive') || value.toLowerCase().includes('gram-positive')) {
                                value = 'Positive';
                            } else if (value.toLowerCase().includes('negative') || value.toLowerCase().includes('gram-negative')) {
                                value = 'Negative';
                            }
                        }
                        
                        // Normalize other values by removing underscores and proper casing
                        if (field === 'cell_shape') {
                            // Convert snake_case to proper case
                            value = value.replace(/_/g, ' ')
                                        .split(' ')
                                        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                                        .join(' ');
                        }
                        
                        // Normalize aerophilicity values
                        if (field === 'aerophilicity') {
                            const lowerValue = value.toLowerCase().trim();
                            if (lowerValue === 'aerobic' || lowerValue === 'obligate aerobe') {
                                value = 'Aerobic';
                            } else if (lowerValue === 'anaerobic' || lowerValue === 'obligate anaerobe') {
                                value = 'Anaerobic';
                            } else if (lowerValue.includes('facultative') || lowerValue === 'facultatively anaerobic') {
                                value = 'Facultative';
                            } else {
                                // Capitalize first letter for other values
                                value = value.charAt(0).toUpperCase() + value.slice(1).toLowerCase();
                            }
                        }
                    }
                    
                    modelStats[model].phenotypeDistributions[field][value] = 
                        (modelStats[model].phenotypeDistributions[field][value] || 0) + 1;
                });
            });
            
            // Convert to array format
            const modelResults = Object.entries(modelStats).map(([modelName, stats]) => ({
                modelName,
                totalPredictions: stats.totalPredictions,
                naCount: stats.naCount,
                naPercentage: (stats.naCount / (stats.totalPredictions * Object.keys(phenotypes).length)) * 100,
                phenotypeDistributions: stats.phenotypeDistributions
            }));
            
            // Sort by model name
            modelResults.sort((a, b) => a.modelName.localeCompare(b.modelName));
            
            console.log('[PhenotypeDistributions] Rendering real data:', modelResults.length, 'models');
            renderDistributions(modelResults);
            
        } catch (error) {
            console.error('[PhenotypeDistributions] Failed to fetch real data:', error);
            console.log('[PhenotypeDistributions] Falling back to mock data');
            initializeWithMockData();
        }
    }
    
    function createMockModelResults() {
        const models = [
            'anthropic/claude-3-opus-20240229',
            'openai/gpt-4',
            'google/gemini-pro',
            'meta-llama/llama-3-70b-instruct'
        ];
        
        const phenotypes = {
            'gram_staining': { name: 'Gram Staining' },
            'motility': { name: 'Motility' },
            'aerophilicity': { name: 'Aerophilicity' },
            'biofilm_formation': { name: 'Biofilm Formation' },
            'spore_formation': { name: 'Spore Formation' },
            'cell_shape': { name: 'Cell Shape' }
        };
        
        return models.map(modelName => ({
            modelName,
            totalPredictions: 100,
            naCount: Math.floor(Math.random() * 20),
            naPercentage: Math.random() * 20,
            phenotypeDistributions: Object.keys(phenotypes).reduce((acc, key) => {
                if (key === 'gram_staining') {
                    acc[key] = {
                        'Positive': Math.floor(Math.random() * 40) + 30,
                        'Negative': Math.floor(Math.random() * 40) + 20,
                        'NA': Math.floor(Math.random() * 20) + 10
                    };
                } else if (key === 'motility' || key === 'biofilm_formation' || key === 'spore_formation') {
                    acc[key] = {
                        'TRUE': Math.floor(Math.random() * 50) + 25,
                        'FALSE': Math.floor(Math.random() * 40) + 20,
                        'NA': Math.floor(Math.random() * 15) + 5
                    };
                } else if (key === 'aerophilicity') {
                    acc[key] = {
                        'Aerobic': Math.floor(Math.random() * 30) + 20,
                        'Anaerobic': Math.floor(Math.random() * 25) + 15,
                        'Facultative': Math.floor(Math.random() * 20) + 10,
                        'NA': Math.floor(Math.random() * 15) + 5
                    };
                } else if (key === 'cell_shape') {
                    acc[key] = {
                        'Coccus': Math.floor(Math.random() * 25) + 15,
                        'Bacillus': Math.floor(Math.random() * 30) + 20,
                        'Spiral': Math.floor(Math.random() * 15) + 5,
                        'Other': Math.floor(Math.random() * 10) + 5,
                        'NA': Math.floor(Math.random() * 10) + 5
                    };
                }
                return acc;
            }, {})
        }));
    }
    
    function renderDistributions(modelResults) {
        componentInitialized = true;
        const container = document.getElementById('phenotypeDistributionsContent');
        if (!container) return;
        
        // Clear any existing content
        container.innerHTML = '';
        
        const phenotypes = {
            'gram_staining': { name: 'Gram Staining' },
            'motility': { name: 'Motility' },
            'aerophilicity': { name: 'Aerophilicity' },
            'biofilm_formation': { name: 'Biofilm Formation' },
            'spore_formation': { name: 'Spore Formation' },
            'cell_shape': { name: 'Cell Shape' }
        };
        
        let html = '<div class="phenotype-grid">';
        
        Object.entries(phenotypes).forEach(([phenotypeKey, phenotypeInfo]) => {
            html += renderPhenotypeCard(phenotypeKey, phenotypeInfo, modelResults);
        });
        
        html += '</div>';
        container.innerHTML = html;
    }
    
    function renderPhenotypeCard(phenotypeKey, phenotypeInfo, modelResults) {
        let html = `<div class="phenotype-card">`;
        
        // Header
        html += `<div class="phenotype-card-header">`;
        html += `<h4 class="phenotype-card-title">${phenotypeInfo.name}`;
        
        // Add field type badge
        const fieldType = getFieldType(phenotypeKey);
        html += ` <span class="field-type-badge field-type-${fieldType}">${fieldType}</span>`;
        
        html += `</h4>`;
        html += `</div>`;
        
        // Legend
        html += generatePhenotypeLegend(phenotypeKey);
        
        // Table
        html += `<table class="phenotype-analysis-table">`;
        html += `<thead><tr>`;
        html += `<th style="text-align: left;">Model</th>`;
        html += `<th>Prediction Distribution</th>`;
        html += `<th>NA %</th>`;
        html += `</tr></thead>`;
        html += `<tbody>`;
        
        modelResults.forEach(result => {
            const distribution = result.phenotypeDistributions[phenotypeKey] || {};
            const total = Object.values(distribution).reduce((sum, count) => sum + count, 0);
            const naCount = distribution['NA'] || 0;
            const naRate = total > 0 ? (naCount / total * 100) : 0;
            
            html += `<tr>`;
            html += `<td class="model-name-cell">${formatModelName(result.modelName)}</td>`;
            html += `<td class="chart-cell">${renderValueDistributionBar(distribution, total, phenotypeKey)}</td>`;
            html += `<td style="text-align: center; font-weight: 600; color: ${naRate > 50 ? '#dc3545' : naRate > 20 ? '#ffc107' : '#28a745'};">`;
            html += `${naRate.toFixed(1)}%`;
            html += `</td>`;
            html += `</tr>`;
        });
        
        html += `</tbody></table>`;
        html += `</div>`;
        
        return html;
    }
    
    function getFieldType(phenotypeKey) {
        if (phenotypeKey === 'aerophilicity' || phenotypeKey === 'cell_shape') {
            return 'categorical';
        }
        return 'binary';
    }
    
    function generatePhenotypeLegend(phenotypeKey) {
        let html = '<div class="phenotype-legend">';
        
        const legendData = getLegendData(phenotypeKey);
        legendData.forEach(item => {
            html += `<div class="legend-item">`;
            html += `<div class="legend-color" style="background: ${item.background} !important; color: ${item.color} !important;"></div>`;
            html += `<span class="legend-label">${item.label}</span>`;
            html += `</div>`;
        });
        
        // Always add NA
        html += `<div class="legend-item">`;
        html += `<div class="legend-color" style="background: linear-gradient(135deg, #e2e3e5 0%, #d6d8db 100%) !important; color: #6c757d !important;"></div>`;
        html += `<span class="legend-label">NA/Not Available</span>`;
        html += `</div>`;
        
        html += '</div>';
        return html;
    }
    
    function getLegendData(phenotypeKey) {
        const legends = {
            'gram_staining': [
                { label: 'Positive', background: 'linear-gradient(135deg, #4caf50 0%, #45a049 100%)', color: 'white' },
                { label: 'Negative', background: 'linear-gradient(135deg, #f44336 0%, #e53935 100%)', color: 'white' }
            ],
            'motility': [
                { label: 'TRUE', background: 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)', color: 'white' },
                { label: 'FALSE', background: 'linear-gradient(135deg, #94a3b8 0%, #64748b 100%)', color: 'white' }
            ],
            'biofilm_formation': [
                { label: 'TRUE', background: 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)', color: 'white' },
                { label: 'FALSE', background: 'linear-gradient(135deg, #94a3b8 0%, #64748b 100%)', color: 'white' }
            ],
            'spore_formation': [
                { label: 'TRUE', background: 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)', color: 'white' },
                { label: 'FALSE', background: 'linear-gradient(135deg, #94a3b8 0%, #64748b 100%)', color: 'white' }
            ],
            'aerophilicity': [
                { label: 'Aerobic', background: 'linear-gradient(135deg, #2196f3 0%, #1976d2 100%)', color: 'white' },
                { label: 'Anaerobic', background: 'linear-gradient(135deg, #ff9800 0%, #f57c00 100%)', color: 'white' },
                { label: 'Facultative', background: 'linear-gradient(135deg, #9c27b0 0%, #7b1fa2 100%)', color: 'white' }
            ],
            'cell_shape': [
                { label: 'Coccus', background: 'linear-gradient(135deg, #3f51b5 0%, #303f9f 100%)', color: 'white' },
                { label: 'Bacillus', background: 'linear-gradient(135deg, #009688 0%, #00796b 100%)', color: 'white' },
                { label: 'Spiral', background: 'linear-gradient(135deg, #ff5722 0%, #e64a19 100%)', color: 'white' },
                { label: 'Other', background: 'linear-gradient(135deg, #607d8b 0%, #455a64 100%)', color: 'white' }
            ]
        };
        
        return legends[phenotypeKey] || [];
    }
    
    function renderValueDistributionBar(distribution, total, phenotypeKey) {
        if (total === 0) {
            return '<div class="no-data">No data</div>';
        }
        
        const sortedValues = Object.entries(distribution)
            .sort((a, b) => {
                if (a[0] === 'NA') return 1;
                if (b[0] === 'NA') return -1;
                return getValueOrder(phenotypeKey, a[0]) - getValueOrder(phenotypeKey, b[0]);
            });
        
        let html = '<div class="single-bar-chart">';
        html += '<div class="single-stacked-bar">';
        
        sortedValues.forEach(([value, count]) => {
            const percentage = (count / total * 100);
            const colors = getValueColors(value, phenotypeKey);
            
            // Log for debugging
            if (componentInitialized && sortedValues.length > 0 && sortedValues[0] === [value, count]) {
                console.log(`[PhenotypeDistributions] ${phenotypeKey} - ${value}: ${colors.background}`);
            }
            
            if (percentage > 0) {
                // Add gradient class as fallback
                let gradientClass = '';
                if (value === 'NA') {
                    gradientClass = 'gradient-na';
                } else if (value.toLowerCase() === 'positive' || value.toLowerCase() === 'gram-positive') {
                    gradientClass = 'gradient-positive';
                } else if (value.toLowerCase() === 'negative' || value.toLowerCase() === 'gram-negative') {
                    gradientClass = 'gradient-negative';
                } else if (value.toLowerCase() === 'true') {
                    gradientClass = 'gradient-true';
                } else if (value.toLowerCase() === 'false') {
                    gradientClass = 'gradient-false';
                }
                
                html += `<div class="bar-segment ${gradientClass}" style="width: ${percentage}%; background: ${colors.background} !important; color: ${colors.color} !important;">`;
                if (percentage > 5) {
                    html += `<span class="bar-number">${count}</span>`;
                }
                html += `</div>`;
            }
        });
        
        html += '</div>';
        html += '</div>';
        
        return html;
    }
    
    function getValueOrder(phenotypeKey, value) {
        const orders = {
            'gram_staining': { 'Positive': 0, 'Negative': 1 },
            'motility': { 'TRUE': 0, 'FALSE': 1 },
            'biofilm_formation': { 'TRUE': 0, 'FALSE': 1 },
            'spore_formation': { 'TRUE': 0, 'FALSE': 1 },
            'aerophilicity': { 'Aerobic': 0, 'Anaerobic': 1, 'Facultative': 2 },
            'cell_shape': { 'Coccus': 0, 'Bacillus': 1, 'Spiral': 2, 'Other': 3 }
        };
        
        return orders[phenotypeKey]?.[value] ?? 999;
    }
    
    function getValueColors(value, phenotypeKey) {
        if (value === 'NA' || value === 'N/A' || value === '') {
            return { 
                background: 'linear-gradient(135deg, #e2e3e5 0%, #d6d8db 100%)', 
                color: '#6b7280' 
            };
        }
        
        // Convert value to string for consistent comparison
        const valueStr = String(value);
        
        // Use gradient styles for better visibility
        const colorMappings = {
            'gram_staining': {
                'Positive': { background: 'linear-gradient(135deg, #4caf50 0%, #45a049 100%)', color: 'white' },
                'Negative': { background: 'linear-gradient(135deg, #f44336 0%, #e53935 100%)', color: 'white' },
                'positive': { background: 'linear-gradient(135deg, #4caf50 0%, #45a049 100%)', color: 'white' },
                'negative': { background: 'linear-gradient(135deg, #f44336 0%, #e53935 100%)', color: 'white' },
                'Gram-positive': { background: 'linear-gradient(135deg, #4caf50 0%, #45a049 100%)', color: 'white' },
                'Gram-negative': { background: 'linear-gradient(135deg, #f44336 0%, #e53935 100%)', color: 'white' },
                'gram-positive': { background: 'linear-gradient(135deg, #4caf50 0%, #45a049 100%)', color: 'white' },
                'gram-negative': { background: 'linear-gradient(135deg, #f44336 0%, #e53935 100%)', color: 'white' }
            },
            'motility': {
                'TRUE': { background: 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)', color: 'white' },
                'FALSE': { background: 'linear-gradient(135deg, #94a3b8 0%, #64748b 100%)', color: 'white' },
                'True': { background: 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)', color: 'white' },
                'False': { background: 'linear-gradient(135deg, #94a3b8 0%, #64748b 100%)', color: 'white' },
                'true': { background: 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)', color: 'white' },
                'false': { background: 'linear-gradient(135deg, #94a3b8 0%, #64748b 100%)', color: 'white' }
            },
            'biofilm_formation': {
                'TRUE': { background: 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)', color: 'white' },
                'FALSE': { background: 'linear-gradient(135deg, #94a3b8 0%, #64748b 100%)', color: 'white' },
                'True': { background: 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)', color: 'white' },
                'False': { background: 'linear-gradient(135deg, #94a3b8 0%, #64748b 100%)', color: 'white' },
                'true': { background: 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)', color: 'white' },
                'false': { background: 'linear-gradient(135deg, #94a3b8 0%, #64748b 100%)', color: 'white' }
            },
            'spore_formation': {
                'TRUE': { background: 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)', color: 'white' },
                'FALSE': { background: 'linear-gradient(135deg, #94a3b8 0%, #64748b 100%)', color: 'white' },
                'True': { background: 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)', color: 'white' },
                'False': { background: 'linear-gradient(135deg, #94a3b8 0%, #64748b 100%)', color: 'white' },
                'true': { background: 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)', color: 'white' },
                'false': { background: 'linear-gradient(135deg, #94a3b8 0%, #64748b 100%)', color: 'white' }
            },
            'aerophilicity': {
                'Aerobic': { background: 'linear-gradient(135deg, #2196f3 0%, #1976d2 100%)', color: 'white' },
                'Anaerobic': { background: 'linear-gradient(135deg, #ff9800 0%, #f57c00 100%)', color: 'white' },
                'Facultative': { background: 'linear-gradient(135deg, #9c27b0 0%, #7b1fa2 100%)', color: 'white' },
                'aerobic': { background: 'linear-gradient(135deg, #2196f3 0%, #1976d2 100%)', color: 'white' },
                'anaerobic': { background: 'linear-gradient(135deg, #ff9800 0%, #f57c00 100%)', color: 'white' },
                'facultative': { background: 'linear-gradient(135deg, #9c27b0 0%, #7b1fa2 100%)', color: 'white' },
                'Facultative anaerobe': { background: 'linear-gradient(135deg, #9c27b0 0%, #7b1fa2 100%)', color: 'white' },
                'facultative anaerobe': { background: 'linear-gradient(135deg, #9c27b0 0%, #7b1fa2 100%)', color: 'white' },
                'Obligate aerobe': { background: 'linear-gradient(135deg, #2196f3 0%, #1976d2 100%)', color: 'white' },
                'obligate aerobe': { background: 'linear-gradient(135deg, #2196f3 0%, #1976d2 100%)', color: 'white' },
                'Obligate anaerobe': { background: 'linear-gradient(135deg, #ff9800 0%, #f57c00 100%)', color: 'white' },
                'obligate anaerobe': { background: 'linear-gradient(135deg, #ff9800 0%, #f57c00 100%)', color: 'white' }
            },
            'cell_shape': {
                'Coccus': { background: 'linear-gradient(135deg, #3f51b5 0%, #303f9f 100%)', color: 'white' },
                'Bacillus': { background: 'linear-gradient(135deg, #009688 0%, #00796b 100%)', color: 'white' },
                'Spiral': { background: 'linear-gradient(135deg, #ff5722 0%, #e64a19 100%)', color: 'white' },
                'Other': { background: 'linear-gradient(135deg, #607d8b 0%, #455a64 100%)', color: 'white' },
                'coccus': { background: 'linear-gradient(135deg, #3f51b5 0%, #303f9f 100%)', color: 'white' },
                'bacillus': { background: 'linear-gradient(135deg, #009688 0%, #00796b 100%)', color: 'white' },
                'spiral': { background: 'linear-gradient(135deg, #ff5722 0%, #e64a19 100%)', color: 'white' },
                'other': { background: 'linear-gradient(135deg, #607d8b 0%, #455a64 100%)', color: 'white' }
            }
        };
        
        // Check for exact match
        if (colorMappings[phenotypeKey]?.[valueStr]) {
            return colorMappings[phenotypeKey][valueStr];
        }
        
        // Fallback to gray gradient
        return { 
            background: 'linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%)', 
            color: '#495057' 
        };
    }
    
    function formatModelName(modelName) {
        if (!modelName.includes('/')) {
            return modelName;
        }
        
        const [provider, model] = modelName.split('/');
        const providerMap = {
            'anthropic': 'Anthropic',
            'openai': 'OpenAI',
            'google': 'Google',
            'meta-llama': 'Meta',
            'mistralai': 'Mistral',
            'cohere': 'Cohere',
            'x-ai': 'xAI'
        };
        
        const displayProvider = providerMap[provider] || provider.charAt(0).toUpperCase() + provider.slice(1);
        return `${displayProvider} ${model}`;
    }
    
    // Initialize component
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', waitForData);
    } else {
        // Small delay to ensure main scripts have run
        setTimeout(waitForData, 100);
    }
})();
</script>