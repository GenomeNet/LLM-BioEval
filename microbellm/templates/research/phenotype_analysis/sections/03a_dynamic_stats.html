<div id="dynamicStatsText" class="article-text">
    <div class="loading-container">
        <div class="loading-progress">
            <div class="loading-progress-bar"></div>
        </div>
        <div class="loading-text">Loading statistics...</div>
    </div>
</div>

<style>
/* Loading animation styles */
.loading-container {
    text-align: center;
    padding: 20px;
}

.loading-progress {
    width: 200px;
    height: 4px;
    background: #f3f4f6;
    border-radius: 2px;
    margin: 0 auto 16px;
    overflow: hidden;
}

.loading-progress-bar {
    height: 100%;
    background: #22c55e;
    width: 30%;
    border-radius: 2px;
    animation: loading 1.5s ease-in-out infinite;
}

@keyframes loading {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(400%); }
}

.loading-text {
    color: #6b7280;
    font-size: 14px;
}

.stat-value {
    display: inline-block;
    font-weight: 700;
    color: var(--gray-900);
    background: rgba(34, 197, 94, 0.1);
    border-radius: 6px;
    margin: 0 2px;
    padding: 2px 8px;
    font-size: inherit;
}

.model-highlight {
    display: inline-block;
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    font-weight: 600;
    font-style: italic;
    background: rgba(34, 197, 94, 0.1);
    color: #059669;
    padding: 2px 6px;
    border-radius: 4px;
    font-size: inherit;
}

.model-lowlight {
    display: inline-block;
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    font-weight: 600;
    font-style: italic;
    background: rgba(239, 68, 68, 0.1);
    color: #dc2626;
    padding: 2px 6px;
    border-radius: 4px;
    font-size: inherit;
}
</style>

<script>
// Self-contained script for dynamic phenotype stats
(function() {
    console.log('[PhenotypeDynamicStats] Script starting...');
    
    // Wait a bit for DOM to settle
    setTimeout(function() {
        console.log('[PhenotypeDynamicStats] Initializing...');
        // Check if we're in component viewer
        if (window.location.pathname.includes('/components/')) {
            console.log('[PhenotypeDynamicStats] Component viewer detected, using mock data');
            useMockData();
        } else {
            loadPhenotypeDynamicStats();
        }
    }, 100);
    
    // Use mock data for component viewer
    function useMockData() {
        const container = document.getElementById('dynamicStatsText');
        if (!container) {
            console.error('[PhenotypeDynamicStats] Container not found');
            return;
        }
        
        const mockStatsText = `
            We analyzed <span class="stat-value">31</span> language models across
            <span class="stat-value">13</span> bacterial phenotype categories covering
            <span class="stat-value">3,884</span> species, generating about
            <span class="stat-value">50,492</span> prediction opportunities per model.
            The models varied in their response patterns, with an average NA rate of
            <span class="stat-value">12.8%</span> across all phenotype predictions.
            <span class="model-highlight">Claude 3 Opus</span> provided predictions for
            <span class="stat-value">92.8%</span> of queries (NA rate:
            <span class="stat-value">7.2%</span>), while <span class="model-lowlight">Mistral 7B</span>
            responded to <span class="stat-value">81.5%</span> of queries (NA rate:
            <span class="stat-value">18.5%</span>).
        `;
        container.innerHTML = mockStatsText.trim();
    }
    
    // Load and process data
    async function loadPhenotypeDynamicStats() {
        const container = document.getElementById('dynamicStatsText');
        if (!container) {
            console.error('[PhenotypeDynamicStats] Container not found');
            return;
        }
        
        try {
            console.log('[PhenotypeDynamicStats] Fetching from /api/phenotype_analysis...');
            const response = await fetch('/api/phenotype_analysis');
            console.log('[PhenotypeDynamicStats] Response status:', response.status);
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            console.log('[PhenotypeDynamicStats] Raw data received:', data);
            
            if (data.error) {
                console.error('[PhenotypeDynamicStats] Error in response:', data.error);
                container.innerHTML = `<div class="error-message">${data.error}</div>`;
                return;
            }
            
            const records = Object.values(data.data || {}).reduce((acc, items) => {
                if (Array.isArray(items)) {
                    return acc.concat(items);
                }
                return acc;
            }, []);

            if (records.length === 0) {
                console.error('[PhenotypeDynamicStats] No phenotype records available');
                container.innerHTML = '<div class="error-message">No phenotype prediction data found</div>';
                return;
            }

            console.log('[PhenotypeDynamicStats] Aggregated records:', records.length);

            // Generate the dynamic stats text
            generatePhenotypeDynamicStats(records, container);
            
        } catch (error) {
            console.error('[PhenotypeDynamicStats] Failed to load data:', error);
            // Use mock data in component viewer context
            if (window.location.pathname.includes('/components/')) {
                console.log('[PhenotypeDynamicStats] Using mock data for component viewer');
                const mockStatsText = `
                    We analyzed <span class="stat-value">25</span> language models across
                    <span class="stat-value">13</span> bacterial phenotype categories, covering
                    <span class="stat-value">2,500</span> species and generating about
                    <span class="stat-value">32,500</span> prediction opportunities per model.
                    The models showed varying levels of confidence, with an average NA rate of
                    <span class="stat-value">15.2%</span> across all phenotype predictions.
                    <span class="model-highlight">GPT-4</span> provided predictions for
                    <span class="stat-value">91.5%</span> of queries (NA rate:
                    <span class="stat-value">8.5%</span>), while <span class="model-lowlight">Llama-2</span>
                    responded to <span class="stat-value">77.7%</span> of queries (NA rate:
                    <span class="stat-value">22.3%</span>).
                `;
                container.innerHTML = mockStatsText.trim();
            } else {
                container.innerHTML = '<div class="error-message">Failed to load statistics. Please try again later.</div>';
            }
        }
    }
    
    // Generate dynamic stats text from phenotype data
    function generatePhenotypeDynamicStats(fileData, container) {
        const phenotypes = [
            'gram_staining', 'motility', 'aerophilicity',
            'extreme_environment_tolerance', 'biofilm_formation',
            'animal_pathogenicity', 'biosafety_level', 'health_association',
            'host_association', 'plant_pathogenicity', 'spore_formation',
            'hemolysis', 'cell_shape'
        ];

        if (!Array.isArray(fileData) || fileData.length === 0) {
            container.innerHTML = '<div class="error-message">No data available for analysis</div>';
            return;
        }

        const modelStats = {};
        const overallSpecies = new Set();

        fileData.forEach(item => {
            if (!item || !item.model) {
                return;
            }

            overallSpecies.add(item.binomial_name);

            if (!modelStats[item.model]) {
                modelStats[item.model] = {
                    speciesSet: new Set(),
                    naCount: 0,
                    filledCount: 0
                };
            }

            const stats = modelStats[item.model];
            stats.speciesSet.add(item.binomial_name);

            phenotypes.forEach(field => {
                const value = item[field];
                if (value === null || value === undefined || value === 'NA' || value === 'N/A' || value === '') {
                    stats.naCount++;
                } else {
                    stats.filledCount++;
                }
            });
        });

        const modelResults = Object.entries(modelStats).map(([modelName, stats]) => {
            const totalSpecies = stats.speciesSet.size;
            const totalPredictions = totalSpecies * phenotypes.length;
            const naPercentage = totalPredictions ? (stats.naCount / totalPredictions) * 100 : 0;
            const fillRate = totalPredictions ? (stats.filledCount / totalPredictions) * 100 : 0;

            return {
                modelName,
                totalSpecies,
                totalPredictions,
                naCount: stats.naCount,
                filledCount: stats.filledCount,
                naPercentage,
                fillRate
            };
        }).filter(result => result.totalPredictions > 0);

        const totalModels = modelResults.length;
        if (totalModels === 0) {
            container.innerHTML = '<div class="error-message">No phenotype prediction data available for analysis</div>';
            return;
        }

        const avgNAPercentage = modelResults.reduce((sum, m) => sum + m.naPercentage, 0) / totalModels;
        const avgOpportunitiesPerModel = modelResults.reduce((sum, m) => sum + m.totalPredictions, 0) / totalModels;
        const uniqueSpeciesCount = overallSpecies.size;

        let bestModelResult = null;
        let worstModelResult = null;

        modelResults.forEach(result => {
            if (!bestModelResult || result.naPercentage < bestModelResult.naPercentage) {
                bestModelResult = result;
            }
            if (!worstModelResult || result.naPercentage > worstModelResult.naPercentage) {
                worstModelResult = result;
            }
        });

        const formatModelName = (modelName) => {
            if (!modelName || !modelName.includes('/')) return modelName;
            const [provider, model] = modelName.split('/');
            const providerMap = {
                'anthropic': 'Anthropic',
                'openai': 'OpenAI',
                'google': 'Google',
                'meta-llama': 'Meta',
                'mistralai': 'Mistral',
                'cohere': 'Cohere',
                'x-ai': 'xAI'
            };
            const displayProvider = providerMap[provider] || provider.charAt(0).toUpperCase() + provider.slice(1);
            return `${displayProvider} ${model}`;
        };

        const formatCount = (value) => Number.isFinite(value) ? Math.round(value).toLocaleString() : '0';
        const formatPercentage = (value) => Number.isFinite(value) ? value.toFixed(1) : '0.0';

        const bestModelName = bestModelResult ? bestModelResult.modelName : null;
        const worstModelName = worstModelResult ? worstModelResult.modelName : null;
        const bestModelFillRate = bestModelResult ? formatPercentage(100 - bestModelResult.naPercentage) : null;
        const bestModelNARate = bestModelResult ? formatPercentage(bestModelResult.naPercentage) : null;
        const worstModelFillRate = worstModelResult ? formatPercentage(100 - worstModelResult.naPercentage) : null;
        const worstModelNARate = worstModelResult ? formatPercentage(worstModelResult.naPercentage) : null;

        const overview =
            `We analyzed <span class="stat-value">${formatCount(totalModels)}</span> language models across ` +
            `<span class="stat-value">${phenotypes.length}</span> bacterial phenotype categories covering ` +
            `<span class="stat-value">${formatCount(uniqueSpeciesCount)}</span> species, generating about ` +
            `<span class="stat-value">${formatCount(avgOpportunitiesPerModel)}</span> prediction opportunities per model.`;

        const variation =
            `The models varied in their response patterns, with an average NA rate of ` +
            `<span class="stat-value">${formatPercentage(avgNAPercentage)}%</span> across all phenotype predictions.`;

        const paragraphs = [`<p>${overview} ${variation}</p>`];

        if (bestModelName) {
            paragraphs.push(
                `<p><span class="model-highlight">${formatModelName(bestModelName)}</span> provided predictions for ` +
                `<span class="stat-value">${bestModelFillRate}%</span> of queries ` +
                `(NA rate: <span class="stat-value">${bestModelNARate}%</span>).</p>`
            );
        }

        if (worstModelName && worstModelName !== bestModelName) {
            paragraphs.push(
                `<p><span class="model-lowlight">${formatModelName(worstModelName)}</span> responded to ` +
                `<span class="stat-value">${worstModelFillRate}%</span> of queries ` +
                `(NA rate: <span class="stat-value">${worstModelNARate}%</span>).</p>`
            );
        }

        container.innerHTML = paragraphs.join('');
    }
})();
</script>
