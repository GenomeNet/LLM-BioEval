<!-- Model Accuracy by Knowledge Group Component -->
<div class="accuracy-knowledge-section">
  <!-- Header with controls -->
  <div class="accuracy-knowledge-header">
    <div class="controls-panel">
      <div class="dataset-selector">
        <label for="knowledgeDataset">Select Ground Truth Dataset</label>
        <select id="knowledgeDataset" class="dataset-select" onchange="performKnowledgeAnalysis()">
          <option value="">Choose a dataset...</option>
        </select>
        <div id="knowledgeDatasetDetails" class="dataset-details"></div>
      </div>
    </div>
  </div>

  <!-- Results Area -->
  <div id="knowledgeResultsArea" class="results-container" style="display:none;">
    <div class="results-header">
      <h3 class="results-title">Accuracy by Knowledge Group</h3>
      <p class="results-subtitle">Model performance stratified by self-reported knowledge level</p>
    </div>
    
    <div id="knowledgeResultsTable" class="results-table-container">
      <!-- Results will be injected here -->
    </div>
  </div>

  <!-- Initial Message -->
  <div id="knowledgeInitialMessage" class="info-message">
    <i class="fas fa-chart-bar"></i>
    <p>Select a ground truth dataset to analyze model accuracy by knowledge group</p>
  </div>
</div>

<style>
/* Component Styles */
.accuracy-knowledge-section {
  padding: 20px;
  background: #fff;
  border-radius: 12px;
  min-height: 400px;
}

.accuracy-knowledge-header {
  margin-bottom: 30px;
}

.controls-panel {
  display: flex;
  gap: 20px;
  align-items: flex-end;
  padding: 20px;
  background: #f8f9fa;
  border-radius: 8px;
  border: 1px solid #dee2e6;
}

.dataset-selector {
  flex: 1;
}

.dataset-selector label {
  display: block;
  margin-bottom: 8px;
  font-weight: 500;
  color: #495057;
  font-size: 14px;
}

.dataset-select {
  width: 100%;
  padding: 10px 12px;
  border: 1px solid #ced4da;
  border-radius: 6px;
  background: #fff;
  color: #495057;
  font-size: 14px;
  cursor: pointer;
}

.dataset-select:focus {
  outline: none;
  border-color: #22c55e;
  box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.1);
}

.dataset-details {
  margin-top: 8px;
  font-size: 12px;
  color: #6c757d;
}

.results-container {
  animation: fadeIn 0.3s ease-in;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

.results-header {
  text-align: center;
  margin-bottom: 30px;
}

.results-title {
  font-size: 24px;
  font-weight: 600;
  color: #2c3e50;
  margin: 0 0 8px 0;
}

.results-subtitle {
  font-size: 14px;
  color: #6c757d;
  margin: 0;
}

.results-table-container {
  overflow-x: auto;
  border: 1px solid #dee2e6;
  border-radius: 8px;
}

.knowledge-table {
  width: 100%;
  border-collapse: collapse;
  background: #fff;
}

.knowledge-table thead {
  background: #f8f9fa;
  border-bottom: 2px solid #dee2e6;
}

.knowledge-table th {
  padding: 12px 16px;
  text-align: left;
  font-weight: 600;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: #495057;
  white-space: nowrap;
}

.knowledge-table tbody tr {
  border-bottom: 1px solid #e9ecef;
}

.knowledge-table tbody tr:hover {
  background: #f8f9fa;
}

.knowledge-table td {
  padding: 12px 16px;
  font-size: 14px;
  color: #495057;
}

.model-name {
  font-weight: 600;
  color: #2c3e50;
}

.knowledge-group {
  display: inline-block;
  padding: 4px 12px;
  border-radius: 20px;
  font-size: 12px;
  font-weight: 600;
  text-transform: capitalize;
}

.knowledge-group.extensive {
  background: rgba(34, 197, 94, 0.1);
  color: #16a34a;
}

.knowledge-group.moderate {
  background: rgba(59, 130, 246, 0.1);
  color: #2563eb;
}

.knowledge-group.limited {
  background: rgba(251, 146, 60, 0.1);
  color: #ea580c;
}

.knowledge-group.na {
  background: rgba(156, 163, 175, 0.1);
  color: #6b7280;
}

.accuracy-value {
  font-weight: 700;
  font-variant-numeric: tabular-nums;
}

.accuracy-high {
  color: #16a34a;
}

.accuracy-medium {
  color: #f59e0b;
}

.accuracy-low {
  color: #ef4444;
}

.sample-size {
  color: #6c757d;
  font-size: 13px;
}

.expandable-row {
  cursor: pointer;
}

.expandable-row:hover {
  background: #f1f5f9;
}

.expand-icon {
  display: inline-block;
  margin-right: 8px;
  transition: transform 0.2s;
}

.expand-icon.expanded {
  transform: rotate(90deg);
}

.phenotype-details {
  display: none;
  background: #fafafa;
  border-top: 1px solid #e9ecef;
}

.phenotype-details.show {
  display: table-row;
}

.phenotype-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 16px;
  padding: 16px;
}

.phenotype-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  background: #fff;
  gap: 10px;
  border-radius: 6px;
  border: 1px solid #e5e7eb;
}

.phenotype-name {
  font-size: 13px;
  color: #6b7280;
  text-transform: capitalize;
  flex: 1;
}

.phenotype-stats {
  display: flex;
  align-items: center;
  gap: 8px;
}

.phenotype-accuracy {
  font-weight: 600;
  font-size: 14px;
}

.phenotype-sample-size {
  color: #6b7280;
  font-size: 12px;
  font-weight: 400;
}

.info-message {
  text-align: center;
  padding: 60px 20px;
  color: #6c757d;
}

.info-message i {
  font-size: 48px;
  color: #dee2e6;
  margin-bottom: 16px;
  display: block;
}

.info-message p {
  font-size: 14px;
  margin: 0;
}

.chart-container {
  background: #fff;
  padding: 20px;
  border: 1px solid #e5e7eb;
  border-radius: 8px;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .phenotype-grid {
    grid-template-columns: 1fr;
  }
  
  .knowledge-table {
    font-size: 13px;
  }
  
  .knowledge-table th,
  .knowledge-table td {
    padding: 8px 12px;
  }
}
</style>

<script>
// Initialize component
(function() {
  let knowledgeData = null;
  let groundTruthData = null;
  // Phenotypes considered in manuscript analyses
  const phenotypeFields = [
    'gram_staining',
    'motility',
    'extreme_environment_tolerance',
    'biofilm_formation',
    'animal_pathogenicity',
    'biosafety_level',
    'host_association',
    'plant_pathogenicity',
    'spore_formation',
    'cell_shape'
  ];
  const MIN_SAMPLES_PER_PHENOTYPE = 30;
  
  // Load available datasets and auto-select WA dataset
  async function loadDatasets() {
    console.log('Loading datasets for accuracy_by_knowledge component');
    const select = document.getElementById('knowledgeDataset');
    
    if (!select) {
      console.error('Dataset select element not found');
      return;
    }
    
    try {
      const response = await fetch('/api/ground_truth/datasets');
      const result = await response.json();
      console.log('Datasets API response:', result);
      
      if (result.success && result.datasets && result.datasets.length > 0) {
        select.innerHTML = '<option value="">Choose a dataset...</option>';
        
        let waDatasetFound = false;
        result.datasets.forEach(dataset => {
          if (dataset.name === 'WA_Test_Dataset') { // Only show WA dataset for now
            const option = document.createElement('option');
            option.value = dataset.name;
            option.textContent = `${dataset.name} (${dataset.species_count} species)`;
            option.dataset.count = dataset.species_count;
            select.appendChild(option);
            waDatasetFound = true;
          }
        });
        
        // Auto-select the WA dataset if found
        if (waDatasetFound) {
          console.log('WA dataset found, auto-selecting');
          select.value = 'WA_Test_Dataset';
          // Trigger analysis automatically
          setTimeout(() => performKnowledgeAnalysis(), 100);
        } else {
          console.log('WA dataset not found in API response, using fallback');
          addFallbackDataset();
        }
      } else {
        // Fallback: manually add WA dataset option
        console.log('No datasets from API, using fallback');
        addFallbackDataset();
      }
    } catch (error) {
      console.error('Error loading datasets, using fallback:', error);
      addFallbackDataset();
    }
  }
  
  // Helper function to add fallback dataset
  function addFallbackDataset() {
    const select = document.getElementById('knowledgeDataset');
    if (!select) return;
    
    console.log('Adding WA_Test_Dataset as fallback');
    select.innerHTML = '';
    const option = document.createElement('option');
    option.value = 'WA_Test_Dataset';
    option.textContent = 'WA_Test_Dataset (3884 species)';
    option.dataset.count = 3884;
    select.appendChild(option);
    
    // Auto-select and trigger analysis
    select.value = 'WA_Test_Dataset';
    console.log('Triggering analysis with WA_Test_Dataset');
    setTimeout(() => performKnowledgeAnalysis(), 100);
  }
  
  // Perform analysis
  window.performKnowledgeAnalysis = async function() {
    console.log('performKnowledgeAnalysis called');
    const select = document.getElementById('knowledgeDataset');
    const datasetName = select ? select.value : 'WA_Test_Dataset';
    
    console.log('Dataset selected:', datasetName);
    
    if (!datasetName) {
      console.log('No dataset selected, showing initial message');
      const resultsArea = document.getElementById('knowledgeResultsArea');
      const initMessage = document.getElementById('knowledgeInitialMessage');
      if (resultsArea) resultsArea.style.display = 'none';
      if (initMessage) initMessage.style.display = 'block';
      return;
    }
    
    // Update dataset details
    const details = document.getElementById('knowledgeDatasetDetails');
    if (details) {
      details.innerHTML = '<span><i class="fas fa-spinner fa-spin"></i> Loading data...</span>';
    }
    
    // Hide initial message, show results area
    const initMessage = document.getElementById('knowledgeInitialMessage');
    const resultsArea = document.getElementById('knowledgeResultsArea');
    
    if (initMessage) initMessage.style.display = 'none';
    if (resultsArea) resultsArea.style.display = 'block';
    
    try {
      // Fetch knowledge-grouped data
      console.log(`Fetching data from /api/phenotype_accuracy_by_knowledge?dataset=${datasetName}`);
      const response = await fetch(`/api/phenotype_accuracy_by_knowledge?dataset=${datasetName}`);
      const result = await response.json();
      console.log('API response received:', result);
      
      if (!result.success) {
        throw new Error('Failed to load data');
      }
      
      knowledgeData = result.data;
      
      // Update details
      if (details) {
        const totalResults = result.total_results || result.data.length;
        const uniqueModels = [...new Set(result.data.map(d => d.model))].length;
        const uniqueKnowledgeGroups = [...new Set(result.data.map(d => d.knowledge_group))].length;
        details.innerHTML = `<span>${totalResults.toLocaleString()} predictions • ${uniqueModels} models • ${uniqueKnowledgeGroups} knowledge groups</span>`;
      }
      
      // Calculate accuracy metrics
      const metrics = calculateKnowledgeMetrics(knowledgeData);
      
      // Display results
      console.log('Displaying metrics:', metrics);
      displayKnowledgeResults(metrics);
      
      // Show results area is already shown above
      
    } catch (error) {
      console.error('Error analyzing knowledge accuracy:', error);
      if (details) {
        details.innerHTML = '<span style="color: #dc2626;">Failed to load data</span>';
      }
      // Show error in results area
      const resultsTable = document.getElementById('knowledgeResultsTable');
      if (resultsTable) {
        resultsTable.innerHTML = `<div class="error-message" style="padding: 20px; color: #dc2626;">Failed to load data: ${error.message}</div>`;
      }
    }
  }
  
  // Calculate accuracy metrics grouped by knowledge level
  function calculateKnowledgeMetrics(data) {
    const results = {};
    
    // Group data by model and knowledge group
    data.forEach(item => {
      const model = item.model;
      const knowledgeGroup = item.knowledge_group;
      
      if (!results[model]) {
        results[model] = {};
      }
      
      if (!results[model][knowledgeGroup]) {
        results[model][knowledgeGroup] = {
          observations: {},
          species: new Set()
        };
      }

      phenotypeFields.forEach(field => {
        const predicted = normalizePhenotypeValue(field, item.predictions[field]);
        const truth = normalizePhenotypeValue(field, item.ground_truth[field]);

        if (predicted === null || truth === null) {
          return;
        }

        if (!results[model][knowledgeGroup].observations[field]) {
          results[model][knowledgeGroup].observations[field] = [];
        }

        results[model][knowledgeGroup].observations[field].push({
          prediction: predicted,
          truth: truth
        });
      });

      results[model][knowledgeGroup].species.add(item.binomial_name);
    });

    // Calculate accuracies
    const metrics = [];

    Object.keys(results).forEach(model => {
      Object.keys(results[model]).forEach(knowledgeGroup => {
        const groupData = results[model][knowledgeGroup];

        let totalSamples = 0;
        const phenotypeAccuracies = {};
        const perPhenotypeScores = [];

        phenotypeFields.forEach(field => {
          const observations = groupData.observations[field] || [];
          if (observations.length < MIN_SAMPLES_PER_PHENOTYPE) {
            return;
          }

          const balancedAcc = calculateBalancedAccuracy(field, observations);
          if (!Number.isFinite(balancedAcc)) {
            return;
          }

          const correct = Math.round(balancedAcc * observations.length);
          phenotypeAccuracies[field] = {
            accuracy: balancedAcc * 100,
            correct: correct,
            total: observations.length
          };

          perPhenotypeScores.push(balancedAcc * 100);
          totalSamples += observations.length;
        });

        const overallAccuracy = perPhenotypeScores.length > 0
          ? perPhenotypeScores.reduce((sum, value) => sum + value, 0) / perPhenotypeScores.length
          : 0;

        metrics.push({
          model: model,
          knowledgeGroup: knowledgeGroup,
          overallAccuracy: overallAccuracy,
          sampleSize: groupData.species.size,
          totalPredictions: totalSamples,
          phenotypeAccuracies: phenotypeAccuracies
        });
      });
    });
    
    // Sort by model and knowledge group (NA -> Limited -> Moderate -> Extensive)
    const knowledgeOrder = ['NA', 'limited', 'moderate', 'extensive'];
    metrics.sort((a, b) => {
      if (a.model !== b.model) {
        return a.model.localeCompare(b.model);
      }
      const aIndex = knowledgeOrder.indexOf(a.knowledgeGroup);
      const bIndex = knowledgeOrder.indexOf(b.knowledgeGroup);
      return (aIndex === -1 ? 999 : aIndex) - (bIndex === -1 ? 999 : bIndex);
    });
    
    return metrics;
  }
  
  // Normalize values for comparison
  function normalizePhenotypeValue(phenotype, value) {
    if (value === null || value === undefined) {
      return null;
    }

    const str = String(value).trim().toLowerCase();
    if (!str || str === 'na' || str === 'n/a' || str === '-') {
      return null;
    }

    if (phenotype === 'gram_staining') {
      if (str.includes('positive')) return 'positive';
      if (str.includes('negative')) return 'negative';
      if (str.includes('variable')) return 'variable';
    }

    if (phenotype === 'biosafety_level') {
      if (str.includes('1')) return 'level_1';
      if (str.includes('2')) return 'level_2';
      if (str.includes('3')) return 'level_3';
    }

    if (phenotype === 'cell_shape') {
      if (str.includes('bacillus')) return 'bacillus';
      if (str.includes('coccus')) return 'coccus';
      if (str.includes('spirillum')) return 'spirillum';
      if (str.includes('tail')) return 'tail';
      if (str.includes('filamentous')) return 'filamentous';
    }

    if (str === 'true' || str === 't' || str === 'yes' || str === '1') {
      return true;
    }
    if (str === 'false' || str === 'f' || str === 'no' || str === '0') {
      return false;
    }

    return str;
  }

  function calculateBalancedAccuracy(phenotype, observations) {
    const truths = observations.map(o => o.truth);
    const preds = observations.map(o => o.prediction);

    const isBoolean = typeof truths[0] === 'boolean' || typeof preds[0] === 'boolean';

    if (isBoolean) {
      let tp = 0, tn = 0, fp = 0, fn = 0;
      observations.forEach(({ truth, prediction }) => {
        if (prediction === true && truth === true) tp += 1;
        else if (prediction === true && truth === false) fp += 1;
        else if (prediction === false && truth === false) tn += 1;
        else if (prediction === false && truth === true) fn += 1;
      });

      const recall = tp + fn > 0 ? tp / (tp + fn) : 0;
      const specificity = tn + fp > 0 ? tn / (tn + fp) : 0;
      return (recall + specificity) / 2;
    }

    const labels = Array.from(new Set(truths.concat(preds)));
    if (labels.length === 0) {
      return NaN;
    }

    const counts = {};
    labels.forEach(label => {
      counts[label] = { tp: 0, fn: 0 };
    });

    observations.forEach(({ truth, prediction }) => {
      if (!counts[truth]) {
        counts[truth] = { tp: 0, fn: 0 };
      }
      if (!counts[prediction]) {
        counts[prediction] = { tp: 0, fn: 0 };
      }

      if (truth === prediction) {
        counts[truth].tp += 1;
      } else {
        counts[truth].fn += 1;
      }
    });

    const recalls = labels.map(label => {
      const { tp, fn } = counts[label] || { tp: 0, fn: 0 };
      return tp + fn > 0 ? tp / (tp + fn) : 0;
    });

    const recallSum = recalls.reduce((sum, value) => sum + value, 0);
    return recallSum / recalls.length;
  }
  
  // Display results in table
  function displayKnowledgeResults(metrics) {
    const container = document.getElementById('knowledgeResultsTable');
    
    // Group metrics by model
    const modelGroups = {};
    metrics.forEach(m => {
      if (!modelGroups[m.model]) {
        modelGroups[m.model] = [];
      }
      modelGroups[m.model].push(m);
    });
    
    let html = `
      <table class="knowledge-table">
        <thead>
          <tr>
            <th>Model</th>
            <th>Knowledge Group</th>
            <th>Overall Accuracy</th>
            <th>Sample Size</th>
            <th>Total Predictions</th>
            <th>Details</th>
          </tr>
        </thead>
        <tbody>
    `;
    
    Object.keys(modelGroups).forEach(model => {
      const groups = modelGroups[model];
      
      groups.forEach((metric, index) => {
        const accuracyClass = metric.overallAccuracy >= 70 ? 'accuracy-high' : 
                             metric.overallAccuracy >= 50 ? 'accuracy-medium' : 
                             'accuracy-low';
        
        const rowId = `row-${model.replace(/[^a-zA-Z0-9]/g, '-')}-${metric.knowledgeGroup}`;
        
        html += `
          <tr class="expandable-row" onclick="toggleDetails('${rowId}')">
            <td>
              ${index === 0 ? `<span class="model-name">${formatModelName(model)}</span>` : ''}
            </td>
            <td>
              <span class="knowledge-group ${metric.knowledgeGroup.toLowerCase()}">${formatKnowledgeGroup(metric.knowledgeGroup)}</span>
            </td>
            <td>
              <span class="accuracy-value ${accuracyClass}">${metric.overallAccuracy.toFixed(1)}%</span>
            </td>
            <td>
              <span class="sample-size">${metric.sampleSize.toLocaleString()}</span>
            </td>
            <td>
              <span class="sample-size">${metric.totalPredictions.toLocaleString()}</span>
            </td>
            <td>
              <span class="expand-icon" id="icon-${rowId}">▶</span> View
            </td>
          </tr>
          <tr id="${rowId}" class="phenotype-details">
            <td colspan="6">
              <div class="phenotype-grid">
                ${Object.keys(metric.phenotypeAccuracies).map(phenotype => {
                  const acc = metric.phenotypeAccuracies[phenotype];
                  const accClass = acc.accuracy >= 70 ? 'accuracy-high' : 
                                  acc.accuracy >= 50 ? 'accuracy-medium' : 
                                  'accuracy-low';
                  return `
                    <div class="phenotype-item">
                      <span class="phenotype-name">${phenotype.replace(/_/g, ' ')}</span>
                      <div class="phenotype-stats">
                        <span class="phenotype-accuracy ${accClass}">${acc.accuracy.toFixed(1)}%</span>
                        <span class="phenotype-sample-size">(${acc.correct}/${acc.total})</span>
                      </div>
                    </div>
                  `;
                }).join('')}
              </div>
            </td>
          </tr>
        `;
      });
    });
    
    html += `
        </tbody>
      </table>
    `;
    
    container.innerHTML = html;
  }
  
  // Format knowledge group names for display
  function formatKnowledgeGroup(group) {
    if (group === 'NA') return 'NA';
    return group.charAt(0).toUpperCase() + group.slice(1).toLowerCase();
  }
  
  // Format model name for display
  function formatModelName(modelName) {
    if (!modelName.includes('/')) return modelName;
    const [provider, model] = modelName.split('/');
    const providerMap = {
      'anthropic': 'Anthropic',
      'openai': 'OpenAI',
      'google': 'Google',
      'meta-llama': 'Meta',
      'mistralai': 'Mistral',
      'cohere': 'Cohere',
      'deepseek': 'DeepSeek'
    };
    const displayProvider = providerMap[provider] || provider.charAt(0).toUpperCase() + provider.slice(1);
    return `${displayProvider} ${model}`;
  }
  
  // Toggle phenotype details
  window.toggleDetails = function(rowId) {
    const detailsRow = document.getElementById(rowId);
    const icon = document.getElementById(`icon-${rowId}`);
    
    if (detailsRow.classList.contains('show')) {
      detailsRow.classList.remove('show');
      icon.classList.remove('expanded');
      icon.textContent = '▶';
    } else {
      detailsRow.classList.add('show');
      icon.classList.add('expanded');
      icon.textContent = '▼';
    }
  }
  
  // Create chart showing accuracy trends
  
  // Initialize on load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', loadDatasets);
  } else {
    loadDatasets();
  }
  
  // Also add a direct fallback for component viewer
  setTimeout(() => {
    const select = document.getElementById('knowledgeDataset');
    if (select && !select.value) {
      console.log('Force loading fallback dataset after delay');
      addFallbackDataset();
    }
  }, 500);
})();
</script>
