<!-- Cached Model Accuracy by Knowledge Group -->
<div class="accuracy-knowledge-section">
  <div class="accuracy-knowledge-header">
    <div class="controls-panel">
      <div class="dataset-selector">
        <label for="knowledgeDataset">Select Ground Truth Dataset</label>
        <select id="knowledgeDataset" class="dataset-select">
          <option value="">Loading datasets...</option>
        </select>
        <div id="knowledgeDatasetDetails" class="dataset-details"></div>
      </div>
      <div class="cache-controls">
        <button id="knowledgeRefresh" class="refresh-button" disabled>
          <i class="fas fa-sync-alt" aria-hidden="true"></i>
          <span>Refresh Snapshot</span>
        </button>
        <div class="cache-meta" id="knowledgeCacheMeta">Select a dataset to load cached metrics</div>
      </div>
    </div>
  </div>

  <div id="knowledgeResultsArea" class="results-container" style="display:none;">
    <div class="results-header">
      <h3 class="results-title">Accuracy by Knowledge Group (Cached)</h3>
      <p class="results-subtitle">Model performance stratified by self-reported knowledge level</p>
    </div>
    <div id="knowledgeResultsTable" class="results-table-container"></div>
  </div>

  <div id="knowledgeInitialMessage" class="info-message">
    <i class="fas fa-chart-bar"></i>
    <p>Select a ground truth dataset to analyze model accuracy by knowledge group</p>
  </div>
</div>

<style>
.accuracy-knowledge-section { padding: 20px; background: #fff; border-radius: 12px; min-height: 400px; }
.accuracy-knowledge-header { margin-bottom: 30px; }
.controls-panel { display: flex; gap: 20px; align-items: flex-end; padding: 20px; background: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6; flex-wrap: wrap; }
.dataset-selector { flex: 1; min-width: 220px; }
.dataset-selector label { display: block; margin-bottom: 8px; font-weight: 500; color: #495057; font-size: 14px; }
.dataset-select { width: 100%; padding: 10px 12px; border: 1px solid #ced4da; border-radius: 6px; background: #fff; color: #495057; font-size: 14px; cursor: pointer; }
.dataset-select:focus { outline: none; border-color: #22c55e; box-shadow: 0 0 0 3px rgba(34,197,94,0.1); }
.dataset-details { margin-top: 8px; font-size: 12px; color: #6c757d; display: flex; flex-direction: column; gap: 4px; min-height: 32px; }
.cache-controls { display: flex; flex-direction: column; align-items: flex-start; gap: 8px; min-width: 220px; }
.refresh-button { display: inline-flex; align-items: center; gap: 8px; padding: 10px 16px; background: #22c55e; color: #fff; border: none; border-radius: 6px; font-size: 13px; font-weight: 600; cursor: pointer; transition: background 0.2s ease, box-shadow 0.2s ease; }
.refresh-button:hover { background: #16a34a; box-shadow: 0 8px 14px rgba(34,197,94,0.2); }
.refresh-button:disabled { background: #d1d5db; color: #6b7280; cursor: not-allowed; box-shadow: none; }
.refresh-button.loading { background: #1e40af; box-shadow: 0 8px 14px rgba(30,64,175,0.2); }
.refresh-button .fa-sync-alt { transition: transform 0.4s ease; }
.refresh-button.loading .fa-sync-alt { animation: spin 1s linear infinite; }
.cache-meta { font-size: 12px; color: #6c757d; line-height: 1.4; max-width: 260px; }
.cache-meta strong { color: #111827; }
@keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

.results-container { animation: fadeIn 0.3s ease-in; }
@keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
.results-header { text-align: center; margin-bottom: 30px; }
.results-title { font-size: 24px; font-weight: 600; color: #2c3e50; margin: 0 0 8px 0; }
.results-subtitle { font-size: 14px; color: #6c757d; margin: 0; }
.results-table-container { overflow-x: auto; border: 1px solid #dee2e6; border-radius: 8px; }

.knowledge-table { width: 100%; border-collapse: collapse; background: #fff; }
.knowledge-table thead { background: #f8f9fa; border-bottom: 2px solid #dee2e6; }
.knowledge-table th { padding: 12px 16px; text-align: left; font-weight: 600; font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px; color: #495057; white-space: nowrap; }
.knowledge-table tbody tr { border-bottom: 1px solid #e9ecef; transition: background 0.2s; }
.knowledge-table tbody tr:hover { background: #f8f9fa; }
.knowledge-table td { padding: 12px 16px; font-size: 14px; color: #495057; }
.model-name { font-weight: 600; color: #2c3e50; }
.knowledge-group { display: inline-block; padding: 4px 12px; border-radius: 20px; font-size: 12px; font-weight: 600; text-transform: capitalize; }
.knowledge-group.extensive { background: rgba(34,197,94,0.1); color: #16a34a; }
.knowledge-group.moderate { background: rgba(59,130,246,0.1); color: #2563eb; }
.knowledge-group.limited { background: rgba(251,146,60,0.1); color: #ea580c; }
.knowledge-group.na { background: rgba(156,163,175,0.1); color: #6b7280; }
.accuracy-value { font-weight: 700; font-variant-numeric: tabular-nums; }
.accuracy-high { color: #16a34a; }
.accuracy-medium { color: #f59e0b; }
.accuracy-low { color: #ef4444; }
.sample-size { color: #6c757d; font-size: 13px; }
.expandable-row { cursor: pointer; }
.expandable-row:hover { background: #f1f5f9; }
.expand-icon { display: inline-block; margin-right: 8px; transition: transform 0.2s; }
.expand-icon.expanded { transform: rotate(90deg); }
.phenotype-details { display: none; background: #fafafa; border-top: 1px solid #e9ecef; }
.phenotype-details.show { display: table-row; }
.phenotype-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px; padding: 16px; }
.phenotype-item { display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; background: #fff; gap: 10px; border-radius: 6px; border: 1px solid #e5e7eb; }
.phenotype-name { font-size: 13px; color: #6b7280; text-transform: capitalize; flex: 1; }
.phenotype-stats { display: flex; align-items: center; gap: 8px; }
.phenotype-accuracy { font-weight: 600; font-size: 14px; }
.phenotype-sample-size { color: #6b7280; font-size: 12px; font-weight: 400; }
.info-message { text-align: center; padding: 60px 20px; color: #6c757d; }
.info-message i { font-size: 48px; color: #dee2e6; margin-bottom: 16px; display: block; }
.info-message p { font-size: 14px; margin: 0; }

@media (max-width: 768px) {
  .controls-panel { flex-direction: column; align-items: stretch; }
  .cache-controls { width: 100%; }
  .phenotype-grid { grid-template-columns: 1fr; }
  .knowledge-table { font-size: 13px; }
  .knowledge-table th, .knowledge-table td { padding: 8px 12px; }
}
</style>

<script>
(function() {
  'use strict';

  const datasetSelect = document.getElementById('knowledgeDataset');
  const datasetDetails = document.getElementById('knowledgeDatasetDetails');
  const refreshBtn = document.getElementById('knowledgeRefresh');
  const cacheMetaEl = document.getElementById('knowledgeCacheMeta');
  const resultsArea = document.getElementById('knowledgeResultsArea');
  const initMessage = document.getElementById('knowledgeInitialMessage');
  const tableContainer = document.getElementById('knowledgeResultsTable');
  const allowManualRefresh = new URLSearchParams(window.location.search).has('show_refresh');

  if(!allowManualRefresh && refreshBtn){
    refreshBtn.style.display = 'none';
    const cacheControlsEl = refreshBtn.closest('.cache-controls');
    if(cacheControlsEl){
      cacheControlsEl.style.gap = '0';
    }
    refreshBtn.disabled = true;
  }

  let entries = [];
  let phenotypes = [];
  let isLoading = false;
  let selectedDataset = null;

  function init() {
    loadDatasets();
    if(allowManualRefresh){
      refreshBtn.addEventListener('click', () => {
        if (!selectedDataset || isLoading) return;
        fetchCachedMetrics(true);
      });
    }
  }

  async function loadDatasets() {
    try {
      const response = await fetch('/api/ground_truth/datasets');
      if (!response.ok) throw new Error(`HTTP error: ${response.status}`);
      const result = await response.json();
      if (!result.success) throw new Error(result.error || 'Failed to load datasets');

      datasetSelect.innerHTML = '';
      if (result.datasets.length === 0) {
        const opt = document.createElement('option');
        opt.value = '';
        opt.textContent = 'No datasets available';
        datasetSelect.appendChild(opt);
        cacheMetaEl.textContent = 'Import a dataset to generate metrics';
        if(allowManualRefresh){
          refreshBtn.disabled = true;
        }
        return;
      }

      const defaultOpt = document.createElement('option');
      defaultOpt.value = '';
      defaultOpt.textContent = 'Select a dataset...';
      datasetSelect.appendChild(defaultOpt);

      let defaultDataset = null;
      result.datasets.forEach(dataset => {
        const opt = document.createElement('option');
        opt.value = dataset.dataset_name;
        opt.textContent = dataset.dataset_name;
        opt.dataset.count = dataset.species_count || 0;
        datasetSelect.appendChild(opt);
        if (dataset.dataset_name === 'WA_Test_Dataset') defaultDataset = dataset.dataset_name;
      });

      datasetSelect.addEventListener('change', handleDatasetChange);
      if (defaultDataset) {
        datasetSelect.value = defaultDataset;
        handleDatasetChange();
      } else {
        if(allowManualRefresh){
          refreshBtn.disabled = true;
        }
        cacheMetaEl.textContent = 'Select a dataset to load cached metrics';
      }
    } catch (error) {
      console.error('Error loading datasets:', error);
      datasetSelect.innerHTML = '';
      const errorOpt = document.createElement('option');
      errorOpt.value = '';
      errorOpt.textContent = 'Error loading datasets - refresh';
      datasetSelect.appendChild(errorOpt);
      cacheMetaEl.textContent = 'Unable to reach dataset API';
      if(allowManualRefresh){
        refreshBtn.disabled = true;
      }
    }
  }

  function handleDatasetChange() {
    selectedDataset = datasetSelect.value || null;
    if (!selectedDataset) {
      datasetDetails.innerHTML = '';
      cacheMetaEl.textContent = 'Select a dataset to load cached metrics';
      if(allowManualRefresh){
        refreshBtn.disabled = true;
      }
      if (resultsArea) resultsArea.style.display = 'none';
      if (initMessage) initMessage.style.display = 'block';
      tableContainer.innerHTML = '';
      entries = [];
      return;
    }

    if(allowManualRefresh){
      refreshBtn.disabled = false;
    }
    cacheMetaEl.textContent = 'Fetching cached metrics...';
    datasetDetails.innerHTML = '<span><i class="fas fa-spinner fa-spin"></i> Loading snapshot...</span>';
    fetchCachedMetrics(false);
  }

  async function fetchCachedMetrics(forceRefresh) {
    if (!selectedDataset) return;
    isLoading = true;
    if(allowManualRefresh){
      refreshBtn.disabled = true;
      refreshBtn.classList.add('loading');
      refreshBtn.querySelector('span').textContent = forceRefresh ? 'Refreshing...' : 'Loading...';
    }

    try {
      const refreshParam = forceRefresh ? '&refresh=1' : '';
      const url = `/api/knowledge_accuracy_cached?dataset_name=${encodeURIComponent(selectedDataset)}${refreshParam}`;
      const response = await fetch(url);
      const json = await response.json();
      if (!json.success) throw new Error(json.error || 'Failed to load cached metrics');

      entries = json.entries || [];
      phenotypes = json.phenotypes || [];
      updateDetails(json);
      updateCacheMeta(json.cache_info || {});

      if (entries.length) {
        if (resultsArea) resultsArea.style.display = 'block';
        if (initMessage) initMessage.style.display = 'none';
        renderTable();
      } else {
        if (resultsArea) resultsArea.style.display = 'none';
        if (initMessage) {
          initMessage.style.display = 'block';
          initMessage.querySelector('p').textContent = 'No cached metrics available yet for this dataset';
        }
        tableContainer.innerHTML = '';
      }
    } catch (error) {
      console.error('Failed to fetch cached knowledge metrics:', error);
      datasetDetails.innerHTML = '<span style="color:#dc2626;">Snapshot unavailable</span>';
      cacheMetaEl.textContent = error.message || 'Error fetching metrics';
      if (resultsArea) resultsArea.style.display = 'none';
      if (initMessage) initMessage.style.display = 'block';
      entries = [];
      tableContainer.innerHTML = '';
    } finally {
      if(allowManualRefresh){
        refreshBtn.disabled = !selectedDataset;
        refreshBtn.classList.remove('loading');
        refreshBtn.querySelector('span').textContent = 'Refresh Snapshot';
      }
      isLoading = false;
    }
  }

  function updateDetails(payload) {
    const summary = payload.summary || {};
    const importDate = formatTimestamp(payload.metadata && payload.metadata.import_date);
    const importLine = importDate ? `Imported ${importDate}` : 'Import timestamp unavailable';

    datasetDetails.innerHTML = `
      <span><strong>${summary.model_count || 0} models</strong> · ${summary.knowledge_group_count || 0} knowledge groups</span>
      <span>${summary.entry_count || 0} rows · ${summary.ground_truth_species || 0} ground truth species</span>
      <span>${importLine}</span>
    `;
  }

  function updateCacheMeta(cacheInfo) {
    if (!cacheInfo || (!cacheInfo.cached && cacheInfo.cached !== false)) {
      cacheMetaEl.textContent = 'Snapshot status unknown';
      return;
    }
    const computed = formatTimestamp(cacheInfo.computed_at);
    const age = cacheInfo.age_seconds != null ? formatRelativeAge(cacheInfo.age_seconds) : null;
    const status = cacheInfo.cached ? 'Using cached snapshot' : 'Snapshot refreshed';
    let text = `<strong>${status}</strong>`;
    if (computed) text += ` · computed ${computed}`;
    if (age) text += ` · ${age} old`;
    cacheMetaEl.innerHTML = text;
  }

  function renderTable() {
    const knowledgeOrder = ['NA', 'limited', 'moderate', 'extensive'];
    entries.sort((a, b) => {
      if (a.model !== b.model) return a.model.localeCompare(b.model);
      const aIndex = knowledgeOrder.indexOf(a.knowledge_group);
      const bIndex = knowledgeOrder.indexOf(b.knowledge_group);
      return (aIndex === -1 ? 999 : aIndex) - (bIndex === -1 ? 999 : bIndex);
    });

    let html = `
      <table class="knowledge-table">
        <thead>
          <tr>
            <th>Model</th>
            <th>Knowledge Group</th>
            <th>Overall Accuracy</th>
            <th>Sample Size</th>
            <th>Total Predictions</th>
            <th>Details</th>
          </tr>
        </thead>
        <tbody>
    `;

    entries.forEach((entry, index) => {
      const accuracyClass = entry.overall_accuracy >= 70 ? 'accuracy-high' : entry.overall_accuracy >= 50 ? 'accuracy-medium' : 'accuracy-low';
      const rowId = `knowledge-${index}-${entry.model.replace(/[^a-z0-9]/gi, '-')}-${entry.knowledge_group}`;
      const knowledgeClass = (entry.knowledge_group || 'NA').toLowerCase();

      html += `
        <tr class="expandable-row" onclick="toggleKnowledgeDetails('${rowId}')">
          <td><span class="model-name">${formatModelName(entry.model)}</span></td>
          <td><span class="knowledge-group ${knowledgeClass}">${formatKnowledgeGroup(entry.knowledge_group)}</span></td>
          <td><span class="accuracy-value ${accuracyClass}">${entry.overall_accuracy.toFixed(1)}%</span></td>
          <td><span class="sample-size">${entry.sample_size.toLocaleString()}</span></td>
          <td><span class="sample-size">${entry.total_predictions.toLocaleString()}</span></td>
          <td><span class="expand-icon" id="icon-${rowId}">▶</span> View</td>
        </tr>
        <tr id="${rowId}" class="phenotype-details">
          <td colspan="6">
            <div class="phenotype-grid">
              ${renderPhenotypeDetails(entry.phenotype_accuracies)}
            </div>
          </td>
        </tr>
      `;
    });

    html += `</tbody></table>`;
    tableContainer.innerHTML = html;
  }

  function renderPhenotypeDetails(phenotypeAccuracies) {
    if (!phenotypeAccuracies) return '';
    return Object.entries(phenotypeAccuracies).map(([phenotype, stats]) => {
      const accClass = stats.accuracy >= 70 ? 'accuracy-high' : stats.accuracy >= 50 ? 'accuracy-medium' : 'accuracy-low';
      const label = phenotype.replace(/_/g, ' ');
      return `
        <div class="phenotype-item">
          <span class="phenotype-name">${label}</span>
          <div class="phenotype-stats">
            <span class="phenotype-accuracy ${accClass}">${stats.accuracy.toFixed(1)}%</span>
            <span class="phenotype-sample-size">(${stats.correct}/${stats.total})</span>
          </div>
        </div>
      `;
    }).join('');
  }

  window.toggleKnowledgeDetails = function(rowId) {
    const row = document.getElementById(rowId);
    const icon = document.getElementById(`icon-${rowId}`);
    if (!row || !icon) return;
    const expanded = row.classList.toggle('show');
    icon.classList.toggle('expanded', expanded);
    icon.textContent = expanded ? '▼' : '▶';
  };

  function formatKnowledgeGroup(group) {
    if (!group) return 'NA';
    if (group === 'NA') return 'NA';
    return group.charAt(0).toUpperCase() + group.slice(1).toLowerCase();
  }

  function formatModelName(model) {
    if (!model.includes('/')) return model;
    const [provider, name] = model.split('/');
    return `${provider}/${name}`;
  }

  function formatTimestamp(value) {
    if (!value) return '';
    if (value instanceof Date && !isNaN(value)) return value.toLocaleString();
    const str = String(value);
    try {
      const normalized = str.includes('T') ? str : str.replace(' ', 'T');
      const withZone = /Z$/.test(normalized) ? normalized : `${normalized}Z`;
      const date = new Date(withZone);
      if (isNaN(date.getTime())) throw new Error('Invalid date');
      return date.toLocaleString();
    } catch (_) {
      return str;
    }
  }

  function formatRelativeAge(seconds) {
    if (seconds == null) return '';
    if (seconds < 60) return `${Math.max(1, Math.round(seconds))}s`;
    if (seconds < 3600) return `${Math.round(seconds/60)}m`;
    if (seconds < 86400) return `${Math.round(seconds/3600)}h`;
    return `${Math.round(seconds/86400)}d`;
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
})();
</script>
