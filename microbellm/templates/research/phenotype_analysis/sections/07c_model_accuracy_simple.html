<!-- Model Accuracy Analysis Component -->
<div class="accuracy-section">
    <div class="accuracy-header">
        <h3>Model Performance Against Ground Truth</h3>
        <p>Compare language model predictions with validated bacterial phenotype data</p>
    </div>

    <!-- Controls -->
    <div class="accuracy-controls-panel">
        <div class="dataset-selector">
            <label>Ground Truth Dataset:</label>
            <select id="groundTruthDataset" class="dataset-select">
                <option value="">Loading datasets...</option>
            </select>
            <div class="dataset-details" id="datasetDetails"></div>
        </div>
    </div>

    <!-- Results Area -->
    <div id="resultsArea" class="results-container" style="display: none;">
        <!-- Metric Toggle -->
        <div class="metric-toggle-container">
            <label class="metric-toggle-label">Display Metric:</label>
            <div class="metric-toggle-group">
                <button id="toggleBalAcc" class="metric-toggle-btn active">Balanced Accuracy</button>
                <button id="togglePrecision" class="metric-toggle-btn">Precision</button>
            </div>
        </div>
        
        <!-- Performance Legend -->
        <div class="performance-legend">
            <h4>Performance Scale - <span id="legendMetricName">Balanced Accuracy</span></h4>
            <div class="legend-container">
                <div class="legend-section">
                    <h5>Accuracy Levels:</h5>
                    <div class="legend-grid">
                        <div class="legend-entry">
                            <span class="perf-box excellent"></span>
                            <span>≥ 0.9 Excellent</span>
                        </div>
                        <div class="legend-entry">
                            <span class="perf-box good"></span>
                            <span>0.7-0.9 Good</span>
                        </div>
                        <div class="legend-entry">
                            <span class="perf-box moderate"></span>
                            <span>0.5-0.7 Moderate</span>
                        </div>
                        <div class="legend-entry">
                            <span class="perf-box poor"></span>
                            <span>< 0.5 Poor</span>
                        </div>
                    </div>
                </div>
                <div class="legend-section">
                    <h5>Metric Definition:</h5>
                    <div class="metrics-info">
                        <div id="metricDefBalAcc" class="metric-desc">
                            <strong>Balanced Accuracy:</strong> Macro-average recall across all classes, providing equal weight to each class regardless of frequency
                        </div>
                        <div id="metricDefPrecision" class="metric-desc" style="display: none;">
                            <strong>Precision:</strong> Macro-average precision, measuring the proportion of correct predictions for each class
                        </div>
                        <div class="metric-desc">
                            <span class="best-indicator">★</span> = Best performer for this phenotype
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Results Table -->
        <div class="results-table-container">
            <div id="resultsTable"></div>
        </div>
    </div>

    <!-- Initial Message -->
    <div id="initialMessage" class="info-message">
        <i class="fas fa-chart-line"></i>
        <p>Select a ground truth dataset and click "Analyze Accuracy" to compare model performance</p>
    </div>
</div>

<style>
/* Main container */
.accuracy-section {
    padding: 20px;
    background: white;
    border-radius: 12px;
    min-height: 400px;
}

.accuracy-header {
    margin-bottom: 30px;
}

.accuracy-header h3 {
    font-size: 24px;
    font-weight: 600;
    color: #2c3e50;
    margin: 0 0 8px 0;
}

.accuracy-header p {
    font-size: 14px;
    color: #6c757d;
    margin: 0;
}

/* Controls Panel */
.accuracy-controls-panel {
    display: flex;
    gap: 20px;
    align-items: flex-end;
    margin-bottom: 30px;
    padding: 20px;
    background: #f8f9fa;
    border-radius: 8px;
    border: 1px solid #dee2e6;
}

.dataset-selector {
    flex: 1;
}

.dataset-selector label {
    display: block;
    margin-bottom: 8px;
    font-weight: 500;
    color: #495057;
    font-size: 14px;
}

.dataset-select {
    width: 100%;
    padding: 10px 12px;
    border: 1px solid #ced4da;
    border-radius: 6px;
    background: white;
    color: #495057;
    font-size: 14px;
    cursor: pointer;
}

.dataset-select:focus {
    outline: none;
    border-color: #22c55e;
    box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.1);
}

.dataset-details {
    margin-top: 8px;
    font-size: 12px;
    color: #6c757d;
}

/* Results Container */
.results-container {
    animation: fadeIn 0.3s ease-in;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

/* Performance Legend */
.performance-legend {
    margin-bottom: 24px;
    padding: 16px;
    background: #f8f9fa;
    border-radius: 8px;
    border: 1px solid #dee2e6;
}

.performance-legend h4 {
    margin: 0 0 16px 0;
    font-size: 16px;
    font-weight: 600;
    color: #2c3e50;
}

.legend-container {
    display: flex;
    gap: 40px;
}

.legend-section {
    flex: 1;
}

.legend-section h5 {
    margin: 0 0 12px 0;
    font-size: 13px;
    font-weight: 600;
    color: #495057;
    text-transform: uppercase;
}

.legend-grid {
    display: flex;
    gap: 20px;
    flex-wrap: wrap;
}

.metrics-info {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.metric-desc {
    font-size: 12px;
    color: #6c757d;
    line-height: 1.5;
}

.metric-desc strong {
    color: #495057;
    font-weight: 600;
}

.best-indicator {
    color: #fbbf24;
    font-size: 16px;
    vertical-align: middle;
}

.legend-entry {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 13px;
    color: #495057;
}

.perf-box {
    width: 20px;
    height: 20px;
    border-radius: 4px;
}

.perf-box.excellent {
    background: #22c55e;
}

.perf-box.good {
    background: #3b82f6;
}

.perf-box.moderate {
    background: #f59e0b;
}

.perf-box.poor {
    background: #ef4444;
}

/* Metric Toggle */
.metric-toggle-container {
    margin-bottom: 20px;
    display: flex;
    align-items: center;
    gap: 16px;
}

.metric-toggle-label {
    font-size: 14px;
    font-weight: 600;
    color: #495057;
}

.metric-toggle-group {
    display: flex;
    gap: 0;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    overflow: hidden;
}

.metric-toggle-btn {
    padding: 8px 16px;
    border: none;
    background: white;
    color: #6c757d;
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
    border-right: 1px solid #dee2e6;
}

.metric-toggle-btn:last-child {
    border-right: none;
}

.metric-toggle-btn:hover {
    background: #f8f9fa;
}

.metric-toggle-btn.active {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    font-weight: 600;
}

/* Results Table */
.results-table-container {
    overflow-x: auto;  /* Enable horizontal scrolling */
    overflow-y: hidden;  /* Prevent vertical scroll */
    background: white;
    border: 1px solid #dee2e6;
    border-radius: 8px;
    position: relative;
    max-width: 100%;  /* Ensure container doesn't exceed viewport */
    display: block;  /* Ensure block display */
}

/* Frozen first column */
.accuracy-results-table thead th:first-child,
.accuracy-results-table tbody td:first-child {
    position: sticky;
    left: 0;
    z-index: 5;
    background: white;
    box-shadow: 2px 0 4px rgba(0,0,0,0.08);
}

.accuracy-results-table thead th:first-child {
    background: #f8f9fa;
    z-index: 11;
}

.accuracy-results-table tbody tr:hover td:first-child {
    background: #f8f9fa;
}

.accuracy-results-table {
    width: auto;  /* Let table size to content */
    border-collapse: collapse;
    font-size: 12px;  /* Smaller base font */
}

.accuracy-results-table th,
.accuracy-results-table td {
    padding: 4px 3px;  /* Even smaller padding */
    text-align: center;
    border: 1px solid #e9ecef;
    vertical-align: middle;
    white-space: nowrap;  /* Prevent text wrapping */
    min-width: 60px;  /* Minimum width for cells */
    max-width: 90px;  /* Maximum width for cells */
    overflow: hidden;  /* Hide overflow */
    text-overflow: ellipsis;  /* Show ellipsis for long text */
}

.accuracy-results-table thead th {
    background: #f8f9fa;
    font-weight: 600;
    color: #495057;
    font-size: 9px;  /* Very small header font */
    text-transform: uppercase;
    letter-spacing: 0;  /* No letter spacing */
    position: sticky;
    top: 0;
    z-index: 10;
    padding: 4px 2px;  /* Minimal padding for headers */
    line-height: 1.1;
}

.accuracy-results-table tbody tr:hover {
    background: #f8f9fa;
}

.accuracy-results-table td.model-column {
    text-align: left;
    font-family: 'Monaco', 'Menlo', monospace;
    vertical-align: middle;
    white-space: nowrap;
}

.metric-badge {
    display: inline-block;
    padding: 1px 4px;  /* Minimal padding */
    border-radius: 3px;
    font-weight: 600;
    font-family: monospace;
    font-size: 10px;  /* Even smaller font */
}

.metric-badge.excellent {
    background: rgba(34, 197, 94, 0.15);
    color: #16a34a;
}

.metric-badge.good {
    background: rgba(59, 130, 246, 0.15);
    color: #2563eb;
}

.metric-badge.moderate {
    background: rgba(245, 158, 11, 0.15);
    color: #d97706;
}

.metric-badge.poor {
    background: rgba(239, 68, 68, 0.15);
    color: #dc2626;
}

.metric-badge.na {
    background: #e9ecef;
    color: #6c757d;
    font-style: italic;
}

/* Model column with integrated best count */
.model-column {
    min-width: 120px !important;  /* Even narrower */
    max-width: 140px !important;  /* Smaller max */
    padding: 4px 6px !important;
    font-size: 11px !important;  /* Smaller font */
    position: sticky;
    left: 0;
    background: white;
    z-index: 5;
}

.model-info {
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.model-name {
    font-weight: 600;
    color: #2c3e50;
    font-size: 11px;  /* Smaller model name */
    line-height: 1.2;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.best-indicator {
    display: inline-flex;
    align-items: center;
    gap: 2px;  /* Smaller gap */
    padding: 1px 4px;  /* Smaller padding */
    border-radius: 8px;
    background: #f1f5f9;
    font-size: 9px;  /* Smaller font */
    align-self: flex-start;
    cursor: pointer;
    transition: transform 0.1s ease;
}

.best-indicator:hover {
    transform: translateY(-1px);
}

.best-indicator .best-count {
    font-weight: 700;
    color: #64748b;
}

.best-indicator .best-label {
    color: #94a3b8;
    font-weight: 500;
}

.best-indicator.top-performer {
    background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
    box-shadow: 0 1px 3px rgba(251, 191, 36, 0.2);
}

.best-indicator.top-performer .best-count {
    color: #d97706;
}

.best-indicator.top-performer .best-label {
    color: #f59e0b;
}

.best-indicator.zero-count {
    background: #f8f9fa;
    opacity: 0.6;
}

.best-indicator.zero-count .best-count {
    color: #94a3b8;
}

.best-indicator.zero-count .best-label {
    color: #cbd5e1;
}

.sample-count {
    font-size: 11px;
    color: #6c757d;
}

.sample-size {
    display: block;
    font-size: 8px;  /* Tiny sample size text */
    color: #94a3b8;
    margin-top: 0px;
    font-family: monospace;
    opacity: 0.8;  /* Slightly faded */
}

/* Best performer indicators */
.best-cell {
    position: relative;
    background: linear-gradient(135deg, #fef3c7 0%, #fffbeb 100%) !important;
}

.best-cell::after {
    content: '★';
    position: absolute;
    top: 2px;
    right: 2px;
    color: #fbbf24;
    font-size: 12px;
}

.metric-badge.best {
    box-shadow: 0 0 0 2px #fbbf24;
}

/* Metric cell styling */
.metric-cell {
    position: relative;
    cursor: default;
}

.metric-cell:hover {
    background: #f0f4f8;
}

/* Tooltip styling */
.metric-tooltip,
.best-tooltip {
    display: none;
    position: fixed;  /* Critical for proper positioning */
    background: rgba(255, 255, 255, 0.98);
    border: 1px solid #dee2e6;
    border-radius: 8px;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
    z-index: 99999;  /* Ensure it's above everything */
    padding: 12px;
    font-size: 12px;
    pointer-events: none;  /* Prevent hover interference */
    transform: translate3d(0,0,0);  /* Hardware acceleration */
    will-change: left, top;  /* Optimize for animation */
}

.metric-tooltip {
    min-width: 280px;
    max-width: 350px;
}

.best-tooltip {
    min-width: 200px;
    max-width: 300px;
}

.best-tooltip-header {
    font-weight: 600;
    font-size: 13px;
    color: #2c3e50;
    margin-bottom: 8px;
    padding-bottom: 6px;
    border-bottom: 1px solid #e9ecef;
}

.best-tooltip-list {
    margin: 0;
    padding-left: 20px;
}

.best-tooltip-list li {
    margin: 4px 0;
    color: #495057;
    font-size: 12px;
}

.best-tooltip-empty {
    color: #6c757d;
    font-style: italic;
    font-size: 12px;
}

/* Removed tooltip arrow for cleaner look */

.tooltip-header {
    font-weight: 600;
    font-size: 13px;
    color: #2c3e50;
    margin-bottom: 8px;
    padding-bottom: 6px;
    border-bottom: 1px solid #e9ecef;
    text-transform: capitalize;
}

.tooltip-stats {
    margin-bottom: 12px;
    color: #495057;
}

.tooltip-stats div {
    margin: 4px 0;
}

.tooltip-stats strong {
    color: #2c3e50;
    font-weight: 600;
}

.tooltip-matrix-title {
    font-weight: 600;
    font-size: 12px;
    color: #495057;
    margin: 12px 0 8px 0;
}

/* Confusion Matrix styling */
.confusion-matrix-wrapper {
    position: relative;
    padding-top: 20px;
    padding-left: 35px;
}

.matrix-label-predicted {
    position: absolute;
    top: 0;
    left: 50%;
    transform: translateX(-50%);
    font-size: 11px;
    color: #6c757d;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.matrix-label-true {
    position: absolute;
    left: 0;
    top: 50%;
    transform: translateY(-50%) rotate(-90deg);
    transform-origin: center;
    font-size: 11px;
    color: #6c757d;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.confusion-matrix {
    width: auto;
    border-collapse: collapse;
    font-size: 11px;
    margin: 0 auto;
}

.confusion-matrix th,
.confusion-matrix td {
    padding: 6px 10px;
    text-align: center;
    border: 1px solid #dee2e6;
    min-width: 40px;
}

.matrix-corner {
    border: none !important;
    background: transparent !important;
}

.matrix-header-col {
    background: #f8f9fa;
    font-weight: 600;
    color: #495057;
    border-bottom: 2px solid #dee2e6 !important;
}

.matrix-header-row {
    background: #f8f9fa;
    font-weight: 600;
    color: #495057;
    text-align: right;
    padding-right: 8px !important;
    border-right: 2px solid #dee2e6 !important;
}

.matrix-cell {
    background: white;
    font-family: monospace;
    font-weight: 600;
    color: #495057;
}

.matrix-cell.matrix-diagonal {
    background: #e8f5e9;
    color: #2e7d32;
    font-weight: 700;
}

/* Info Message */
.info-message {
    text-align: center;
    padding: 60px 20px;
    color: #6c757d;
}

.info-message i {
    font-size: 48px;
    color: #dee2e6;
    margin-bottom: 16px;
}

.info-message p {
    font-size: 14px;
    margin: 0;
}

/* Responsive */
@media (max-width: 768px) {
    .accuracy-controls-panel {
        flex-direction: column;
        align-items: stretch;
    }
    
    .action-button {
        width: 100%;
    }
    
    .legend-container {
        flex-direction: column;
        gap: 20px;
    }
    
    .legend-grid {
        flex-direction: column;
        gap: 8px;
    }
}
</style>

<script>
(function() {
    'use strict';
    
    let groundTruthData = null;
    let predictionData = null;
    let fieldDefinitions = {};
    let currentMetrics = null;  // Store metrics for re-rendering
    let selectedMetric = 'balancedAcc';  // Default to balanced accuracy
    
    // Initialize when DOM is ready
    function init() {
        loadGroundTruthDatasets();
        // Don't load prediction data upfront anymore - load on demand
        
        // Set up metric toggle listeners
        const toggleBalAcc = document.getElementById('toggleBalAcc');
        const togglePrecision = document.getElementById('togglePrecision');
        
        if (toggleBalAcc) {
            toggleBalAcc.addEventListener('click', () => switchMetric('balancedAcc'));
        }
        
        if (togglePrecision) {
            togglePrecision.addEventListener('click', () => switchMetric('precision'));
        }
    }
    
    // Switch between metrics
    function switchMetric(metric) {
        if (metric === selectedMetric) return;
        
        selectedMetric = metric;
        
        // Update toggle buttons
        document.getElementById('toggleBalAcc').classList.toggle('active', metric === 'balancedAcc');
        document.getElementById('togglePrecision').classList.toggle('active', metric === 'precision');
        
        // Update legend
        const metricName = metric === 'balancedAcc' ? 'Balanced Accuracy' : 'Precision';
        document.getElementById('legendMetricName').textContent = metricName;
        
        // Update metric definition visibility
        document.getElementById('metricDefBalAcc').style.display = metric === 'balancedAcc' ? 'block' : 'none';
        document.getElementById('metricDefPrecision').style.display = metric === 'precision' ? 'block' : 'none';
        
        // Re-render table if we have metrics
        if (currentMetrics) {
            displayResults(currentMetrics);
            
            // Update range plot if available
            if (typeof window.renderRangePlot === 'function') {
                const phenotypes = [...new Set(currentMetrics.map(m => m.phenotype))]
                    .filter(p => p !== 'aerophilicity' && p !== 'health_association');
                window.renderRangePlot(currentMetrics, phenotypes);
            }
        }
    }
    
    // Load available ground truth datasets
    async function loadGroundTruthDatasets() {
        try {
            const response = await fetch('/api/ground_truth/datasets');
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const result = await response.json();
            
            if (result.success && result.datasets) {
                const select = document.getElementById('groundTruthDataset');
                
                if (result.datasets.length === 0) {
                    // Clear and add empty option safely
                    select.innerHTML = '';
                    const emptyOpt = document.createElement('option');
                    emptyOpt.value = '';
                    emptyOpt.textContent = 'No datasets available';
                    select.appendChild(emptyOpt);
                    return;
                }
                
                // Build options safely
                select.innerHTML = '';
                let waTestDataset = null;
                
                // Add default option
                const defaultOpt = document.createElement('option');
                defaultOpt.value = '';
                defaultOpt.textContent = 'Select a dataset...';
                select.appendChild(defaultOpt);
                
                // Add dataset options safely
                result.datasets.forEach(dataset => {
                    const opt = document.createElement('option');
                    opt.value = dataset.dataset_name;
                    opt.textContent = dataset.dataset_name;  // Safe text content
                    opt.dataset.template = dataset.template_name;
                    opt.dataset.count = dataset.species_count;
                    select.appendChild(opt);
                    
                    if (dataset.dataset_name === 'WA_Test_Dataset') {
                        waTestDataset = dataset;
                    }
                });
                
                // Add change listener to auto-analyze
                select.addEventListener('change', () => {
                    updateDatasetInfo();
                    if (select.value) {
                        performAnalysis();
                    }
                });
                
                // Auto-select WA_Test_Dataset if available
                if (waTestDataset) {
                    select.value = 'WA_Test_Dataset';
                    updateDatasetInfo();
                    // Auto-analyze after a short delay
                    setTimeout(() => performAnalysis(), 500);
                }
            } else {
                // Handle case where API returns but not successful
                console.error('API returned without success:', result);
                throw new Error(result.error || 'Failed to load datasets');
            }
        } catch (error) {
            console.error('Error loading datasets:', error);
            const select = document.getElementById('groundTruthDataset');
            select.innerHTML = '';
            const errorOpt = document.createElement('option');
            errorOpt.value = '';
            errorOpt.textContent = 'Error loading datasets - please refresh';
            select.appendChild(errorOpt);
        }
    }
    
    // Load prediction data - now deferred until dataset is selected
    async function loadPredictionData(speciesFile) {
        if (!speciesFile) {
            console.log('No species file specified, skipping data load');
            return null;
        }
        
        try {
            // Use the new filtered endpoint to only load data for the selected dataset
            const response = await fetch(`/api/phenotype_analysis_filtered?species_file=${encodeURIComponent(speciesFile)}`);
            const result = await response.json();
            
            if (!result.error && result.data) {
                console.log(`Loaded ${result.total_results} predictions for ${speciesFile}`);
                return result.data;
            }
            return null;
        } catch (error) {
            console.error('Error loading prediction data:', error);
            return null;
        }
    }
    
    // Update dataset information display
    function updateDatasetInfo() {
        const select = document.getElementById('groundTruthDataset');
        const details = document.getElementById('datasetDetails');
        
        if (select.value) {
            const option = select.selectedOptions[0];
            const count = option.dataset.count;
            const template = option.dataset.template;
            details.innerHTML = `<span>${count} species</span>`;
        } else {
            details.innerHTML = '';
            // Hide results if no dataset selected
            document.getElementById('resultsArea').style.display = 'none';
            document.getElementById('initialMessage').style.display = 'block';
        }
    }
    
    // Perform accuracy analysis
    async function performAnalysis() {
        const select = document.getElementById('groundTruthDataset');
        const datasetName = select.value;
        
        if (!datasetName) {
            return;  // Just return if no dataset selected
        }
        
        const templateName = select.selectedOptions[0].dataset.template;
        
        // Determine species file from dataset name - WA_Test_Dataset maps to wa_with_gcount.txt
        let speciesFile = 'wa_with_gcount.txt';  // Default for WA dataset
        if (datasetName.includes('Artificial') || datasetName.includes('artificial')) {
            speciesFile = 'artificial.txt';
        }
        
        // Load prediction data on demand for the specific species file
        console.log(`Loading predictions for species file: ${speciesFile}`);
        
        // Show loading indicator in dataset details
        const details = document.getElementById('datasetDetails');
        details.innerHTML = '<span><i class="fas fa-spinner fa-spin"></i> Loading data...</span>';
        
        predictionData = await loadPredictionData(speciesFile);
        
        if (!predictionData) {
            console.error('Failed to load prediction data');
            alert('Failed to load prediction data. Please try again.');
            details.innerHTML = '<span style="color: #dc2626;">Failed to load data</span>';
            return;
        }
        
        // Update dataset details with loaded data info
        const uniqueModels = [...new Set(predictionData.map(p => p.model))];
        const uniqueSpecies = [...new Set(predictionData.map(p => p.binomial_name))];
        details.innerHTML = `<span>${uniqueSpecies.length} species • ${uniqueModels.length} models • ${predictionData.length.toLocaleString()} total predictions</span>`;
        
        // Hide initial message
        document.getElementById('initialMessage').style.display = 'none';
        
        try {
            // Fetch template field definitions
            const templateResp = await fetch(`/api/template_field_definitions?template=${templateName}`);
            const templateResult = await templateResp.json();
            fieldDefinitions = templateResult.success ? templateResult.field_definitions : {};
            
            // Fetch ground truth data
            const gtResp = await fetch(`/api/ground_truth/data?dataset=${datasetName}&per_page=20000`);
            const gtResult = await gtResp.json();
            
            if (!gtResult.success) {
                throw new Error('Failed to load ground truth data');
            }
            
            console.log(`Loaded ${gtResult.data.length} ground truth records for ${datasetName}`);
            
            // Create ground truth map
            const gtMap = {};
            gtResult.data.forEach(item => {
                gtMap[item.binomial_name.toLowerCase()] = item;
            });
            
            console.log(`Ground truth map has ${Object.keys(gtMap).length} unique species`);
            
            // Calculate metrics
            const metrics = calculateMetrics(predictionData, gtMap, fieldDefinitions);
            
            // Debug: Log some sample sizes
            console.log('Sample metrics calculation:');
            const sampleMetrics = metrics.filter(m => m.model.includes('gemini') && m.phenotype === 'gram_staining');
            sampleMetrics.forEach(m => {
                console.log(`${m.model} - ${m.phenotype}: ${m.sampleSize} samples`);
            });
            
            // Store metrics for re-rendering when toggling
            currentMetrics = metrics;
            
            // Display results
            displayResults(metrics);
            document.getElementById('resultsArea').style.display = 'block';
            
        } catch (error) {
            console.error('Error analyzing accuracy:', error);
            alert('Error analyzing accuracy: ' + error.message);
            document.getElementById('initialMessage').style.display = 'block';
            document.getElementById('resultsArea').style.display = 'none';
        }
    }
    
    // Calculate accuracy metrics
    function calculateMetrics(predictions, groundTruth, fields) {
        const results = [];
        const phenotypes = Object.keys(fields);
        
        for (const phenotype of phenotypes) {
            // Predictions is now always an array
            const pool = Array.isArray(predictions) ? predictions : [];
            
            const models = [...new Set(pool.map(p => p.model))];
            
            for (const model of models) {
                const rows = pool.filter(p => p.model === model);
                const trueVals = [], predVals = [];
                
                // Debug logging for first phenotype and specific model
                if (phenotype === 'gram_staining' && model.includes('gemini-pro')) {
                    console.log(`Processing ${model} for ${phenotype}:`);
                    console.log(`- Total predictions: ${rows.length}`);
                }
                
                for (const pred of rows) {
                    const species = pred.binomial_name?.toLowerCase();
                    if (!species || !groundTruth[species]) continue;
                    const t = normalizeValue(groundTruth[species][phenotype]);
                    const y = normalizeValue(pred[phenotype]);
                    // Only include if BOTH values are non-null
                    // This ensures we don't count missing predictions or missing ground truth
                    if (t !== null && y !== null) {
                        trueVals.push(t);
                        predVals.push(y);
                    }
                }
                
                // More debug logging
                if (phenotype === 'gram_staining' && model.includes('gemini-pro')) {
                    console.log(`- Matched samples: ${trueVals.length}`);
                    // Log sample of excluded data
                    let excluded = 0;
                    for (const pred of rows.slice(0, 10)) {
                        const species = pred.binomial_name?.toLowerCase();
                        const gt = groundTruth[species];
                        const t = gt ? normalizeValue(gt[phenotype]) : null;
                        const y = normalizeValue(pred[phenotype]);
                        if (!gt || t === '' || y === '') {
                            excluded++;
                            console.log(`  Excluded ${pred.binomial_name}: pred="${pred[phenotype]}", truth="${gt ? gt[phenotype] : 'no GT'}"`);
                        }
                    }
                    if (excluded > 0) {
                        console.log(`  Total excluded in sample: ${excluded}/10`);
                    }
                }
                
                if (trueVals.length) {
                    const m = computeMetrics(predVals, trueVals);
                    results.push({
                        model,
                        phenotype,
                        balancedAcc: m.balancedAcc,
                        precision: m.precision,
                        sampleSize: m.sampleSize,
                        confusionMatrix: m.confusionMatrix,
                        labels: m.labels
                    });
                }
            }
        }
        return results;
    }
    
    // Normalize values with deterministic handling
    function normalizeValue(value) {
        // Handle various representations of missing/null values
        const missingTokens = ['n/a', 'na', 'null', 'none', 'nan', 'undefined', '-', 'unknown', 'missing'];
        
        if (value === null || value === undefined || value === '') {
            return null;
        }
        
        // Convert to string and normalize
        const strValue = String(value).trim().toLowerCase();
        
        // Check if it's a missing token
        if (missingTokens.includes(strValue)) {
            return null;
        }
        
        // For multi-value fields (like aerophilicity), parse and sort
        if (strValue.includes(',') || strValue.includes(';')) {
            const parts = strValue.split(/[,;]/).map(s => s.trim()).filter(s => s);
            return parts.sort().join(',');  // Normalize to comma-separated sorted list
        }
        
        // Return normalized string
        return strValue;
    }
    
    // Convert to boolean with consistent handling
    function toBoolean(v) {
        if (v === null || v === undefined) return null;
        const s = String(v).trim().toLowerCase();
        if (['true','1','yes','t','y'].includes(s)) return true;
        if (['false','0','no','f','n'].includes(s)) return false;
        return null; // unknown token → treat as missing
    }
    
    // Compute metrics for predictions
    function computeMetrics(preds, truths) {
        // Try binary first by converting both sides
        const mapped = preds.map((p, i) => [toBoolean(p), toBoolean(truths[i])])
                            .filter(([p, t]) => p !== null && t !== null);
        
        const allBinary = mapped.length > 0 && mapped.length === preds.length;
        if (allBinary) {
            // Binary classification metrics
            let tp = 0, tn = 0, fp = 0, fn = 0;
            for (const [p, t] of mapped) {
                if (t && p) tp++;
                else if (!t && !p) tn++;
                else if (!t && p) fp++;
                else fn++;
            }
            const sens = tp + fn ? tp / (tp + fn) : 0;
            const spec = tn + fp ? tn / (tn + fp) : 0;
            const prec = tp + fp ? tp / (tp + fp) : 0;
            return {
                balancedAcc: (sens + spec) / 2,
                precision: prec,
                sampleSize: mapped.length,
                confusionMatrix: [[tn, fp], [fn, tp]],
                labels: ['False', 'True']
            };
        }
        
        // Multiclass: use standard macro-recall "balanced accuracy"
        const labels = [...new Set([...truths, ...preds].map(v => String(v)))].sort();
        const conf = Object.fromEntries(labels.map(r => [r, Object.fromEntries(labels.map(c => [c, 0]))]));
        for (let i = 0; i < truths.length; i++) {
            conf[String(truths[i])][String(preds[i])]++;
        }
        
        let recallSum = 0, precSum = 0;
        for (const lab of labels) {
            const tp = conf[lab][lab];
            let fn = 0, fp = 0;
            for (const l2 of labels) {
                if (l2 !== lab) {
                    fn += conf[lab][l2];
                    fp += conf[l2][lab];
                }
            }
            const rec = tp + fn ? tp / (tp + fn) : 0;  // sensitivity/recall
            const pre = tp + fp ? tp / (tp + fp) : 0;  // precision
            recallSum += rec;
            precSum += pre;
        }
        const confusionMatrixArray = labels.map(r => labels.map(c => conf[r][c]));
        return {
            balancedAcc: recallSum / labels.length,  // macro recall (standard multiclass balanced accuracy)
            precision: precSum / labels.length,      // macro precision
            sampleSize: truths.length,
            confusionMatrix: confusionMatrixArray,
            labels
        };
    }
    
    // Display results
    // Helper function to check if value is finite
    function isFiniteNum(v) { 
        return Number.isFinite(v); 
    }
    
    // Format value safely
    function fmt(v) { 
        return isFiniteNum(v) ? v.toFixed(3) : 'N/A'; 
    }
    
    function displayResults(metrics) {
        let models = [...new Set(metrics.map(m => m.model))];
        // Filter out aerophilicity and health_association from display (low sample sizes)
        let phenotypes = [...new Set(metrics.map(m => m.phenotype))]
            .filter(p => p !== 'aerophilicity' && p !== 'health_association');
        
        // Use selected metric for sorting
        const metricField = selectedMetric;  // 'balancedAcc' or 'precision'
        
        // Calculate best score for each phenotype to sort columns
        const phenotypeMaxScore = {};
        phenotypes.forEach(pheno => {
            const phenoMetrics = metrics.filter(m => m.phenotype === pheno);
            const scores = phenoMetrics.map(m => m[metricField]).filter(isFiniteNum);
            const maxScore = scores.length ? Math.max(...scores) : NaN;
            phenotypeMaxScore[pheno] = maxScore;
        });
        
        // Sort phenotypes by their best score (descending)
        phenotypes.sort((a, b) => {
            const aVal = isFiniteNum(phenotypeMaxScore[a]) ? phenotypeMaxScore[a] : -1;
            const bVal = isFiniteNum(phenotypeMaxScore[b]) ? phenotypeMaxScore[b] : -1;
            return bVal - aVal;
        });
        
        // Find best performers for each phenotype
        const bestPerformers = {};
        phenotypes.forEach(pheno => {
            const phenoMetrics = metrics.filter(m => m.phenotype === pheno);
            const validMetrics = phenoMetrics.filter(m => isFiniteNum(m[metricField]));
            if (validMetrics.length > 0) {
                const maxScore = Math.max(...validMetrics.map(m => m[metricField]));
                const bestModel = validMetrics.find(m => m[metricField] === maxScore);
                if (bestModel) {
                    bestPerformers[pheno] = bestModel.model;
                }
            }
        });
        
        // Count how many times each model is best and track which phenotypes
        const modelBestCounts = {};
        const modelBestPhenotypes = {};
        models.forEach(model => {
            modelBestCounts[model] = 0;
            modelBestPhenotypes[model] = [];
        });
        Object.entries(bestPerformers).forEach(([pheno, model]) => {
            if (model) {
                modelBestCounts[model]++;
                modelBestPhenotypes[model].push(pheno);
            }
        });
        
        // Sort models by best count (descending), then alphabetically
        models.sort((a, b) => {
            const countDiff = modelBestCounts[b] - modelBestCounts[a];
            if (countDiff !== 0) return countDiff;
            return a.localeCompare(b);
        });
        
        let html = '<table class="accuracy-results-table">';
        html += '<thead><tr><th class="model-column">Model</th>';
        
        // Add phenotype headers (sorted by best score) with shortened names
        phenotypes.forEach(pheno => {
            const fullName = pheno.replace(/_/g, ' ');
            // Shorten names for compact display
            const shortName = fullName
                .replace('extreme environment tolerance', 'extreme env.')
                .replace('biofilm formation', 'biofilm')
                .replace('animal pathogenicity', 'animal path.')
                .replace('host association', 'host assoc.')
                .replace('plant pathogenicity', 'plant path.')
                .replace('spore formation', 'spore form.')
                .replace('biosafety level', 'biosafety')
                .replace('gram staining', 'gram stain');
            const maxScore = phenotypeMaxScore[pheno];
            html += `<th title="${fullName}" style="width: 70px; max-width: 70px;">${shortName}</th>`;
        });
        html += '</tr></thead><tbody>';
        
        // Add data rows
        models.forEach(model => {
            const shortName = model.includes('/') ? model.split('/').pop() : model;
            const bestCount = modelBestCounts[model];
            
            // Create model cell with integrated best count
            const maxCount = Math.max(...Object.values(modelBestCounts));
            const isTopPerformer = bestCount === maxCount && bestCount > 0;
            
            // Store phenotypes data for tooltip
            const bestPhenotypes = modelBestPhenotypes[model] || [];
            const bestTooltipData = JSON.stringify({
                model: model,
                phenotypes: bestPhenotypes,
                count: bestCount
            }).replace(/"/g, '&quot;');
            
            html += `<tr><td class="model-column">
                <div class="model-info">
                    <div class="model-name">${shortName}</div>
                    <div class="best-indicator ${bestCount > 0 ? (isTopPerformer ? 'top-performer' : '') : 'zero-count'}" 
                         data-best-tooltip="${bestTooltipData}">
                        <span class="best-count">${bestCount}</span>
                        <span class="best-label">best</span>
                    </div>
                </div>
            </td>`;
            
            phenotypes.forEach(pheno => {
                const metric = metrics.find(m => m.model === model && m.phenotype === pheno);
                const isBest = bestPerformers[pheno] === model;
                
                if (metric) {
                    const value = metric[metricField];
                    const perfClass = getPerformanceClass(value);
                    const bestClass = isBest ? ' best' : '';
                    const cellClass = isBest ? ' best-cell' : '';
                    
                    // Store metric data for tooltip
                    const tooltipData = JSON.stringify({
                        model: model,
                        phenotype: pheno,
                        metric: metric
                    }).replace(/"/g, '&quot;');
                    
                    html += `<td class="metric-cell ${cellClass}" data-tooltip-data="${tooltipData}">
                        <span class="metric-badge ${perfClass}${bestClass}">${fmt(value)}</span>
                        <span class="sample-size">n=${metric.sampleSize}</span>
                    </td>`;
                } else {
                    html += '<td><span class="metric-badge na">N/A</span></td>';
                }
            });
            
            html += '</tr>';
        });
        
        html += '</tbody></table>';
        
        document.getElementById('resultsTable').innerHTML = html;
        
        // Ensure tooltip elements exist at document root (not inside scrollable container)
        let metricTooltip = document.getElementById('metricTooltip');
        let bestTooltip = document.getElementById('bestTooltip');
        
        if (!metricTooltip) {
            metricTooltip = document.createElement('div');
            metricTooltip.id = 'metricTooltip';
            metricTooltip.className = 'metric-tooltip';
            document.body.appendChild(metricTooltip);
        }
        
        if (!bestTooltip) {
            bestTooltip = document.createElement('div');
            bestTooltip.id = 'bestTooltip';
            bestTooltip.className = 'best-tooltip';
            document.body.appendChild(bestTooltip);
        }
        
        // Setup tooltips after rendering
        setTimeout(setupTooltips, 100);
        
        // Render range plot if available
        console.log('Checking for range plot function:', typeof window.renderRangePlot);
        if (typeof window.renderRangePlot === 'function') {
            console.log('Calling range plot with metrics:', metrics.length, 'phenotypes:', phenotypes.length);
            window.renderRangePlot(metrics, phenotypes);
        } else {
            console.log('Range plot function not available yet');
        }
    }
    
    // Create tooltip content
    function createTooltipContent(metric, phenotype) {
        const phenoName = phenotype.replace(/_/g, ' ');
        let html = `<div class="tooltip-header">${phenoName}</div>`;
        html += `<div class="tooltip-stats">`;
        html += `<div><strong>Sample Size:</strong> ${metric.sampleSize}</div>`;
        html += `<div><strong>Balanced Acc:</strong> ${fmt(metric.balancedAcc)}</div>`;
        html += `<div><strong>Precision:</strong> ${fmt(metric.precision)}</div>`;
        html += `</div>`;
        
        // Add confusion matrix if available
        if (metric.confusionMatrix && metric.labels) {
            html += `<div class="tooltip-matrix-title">Confusion Matrix:</div>`;
            html += `<div class="confusion-matrix-wrapper">`;
            html += `<div class="matrix-label-predicted">Predicted</div>`;
            html += `<div class="matrix-label-true">True</div>`;
            html += `<table class="confusion-matrix">`;
            
            // Header row with labels only
            html += `<thead><tr><th class="matrix-corner"></th>`;
            metric.labels.forEach(label => {
                html += `<th class="matrix-header-col">${label}</th>`;
            });
            html += `</tr></thead><tbody>`;
            
            // Data rows with row labels
            metric.labels.forEach((label, i) => {
                html += `<tr><th class="matrix-header-row">${label}</th>`;
                metric.confusionMatrix[i].forEach((count, j) => {
                    const isCorrect = i === j;
                    html += `<td class="matrix-cell ${isCorrect ? 'matrix-diagonal' : ''}">${count}</td>`;
                });
                html += `</tr>`;
            });
            
            html += `</tbody></table>`;
            html += `</div>`;
        }
        
        return html;
    }
    
    // Get performance class
    function getPerformanceClass(value) {
        if (isNaN(value)) return 'na';
        if (value >= 0.9) return 'excellent';
        if (value >= 0.7) return 'good';
        if (value >= 0.5) return 'moderate';
        return 'poor';
    }
    
    // Position tooltip at mouse cursor with smart edge detection
    function positionTooltipAtMouse(event, tooltip) {
        if (!tooltip || tooltip.style.display === 'none') return;
        
        const pad = 12;  // Offset from cursor
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        
        // Get tooltip dimensions after it's visible
        const rect = tooltip.getBoundingClientRect();
        const tooltipWidth = rect.width;
        const tooltipHeight = rect.height;
        
        // Start to the bottom-right of cursor
        let x = event.clientX + pad;
        let y = event.clientY + pad;
        
        // Flip horizontally if overflowing right edge
        if (x + tooltipWidth > vw - 4) {
            x = event.clientX - tooltipWidth - pad;
        }
        
        // Flip vertically if overflowing bottom edge
        if (y + tooltipHeight > vh - 4) {
            y = event.clientY - tooltipHeight - pad;
        }
        
        // Clamp to viewport with small margin
        x = Math.max(4, Math.min(x, vw - tooltipWidth - 4));
        y = Math.max(4, Math.min(y, vh - tooltipHeight - 4));
        
        // Apply position using fixed coordinates
        tooltip.style.left = `${x}px`;
        tooltip.style.top = `${y}px`;
    }
    
    // Setup tooltip events
    function setupTooltips() {
        const metricTooltip = document.getElementById('metricTooltip');
        const bestTooltip = document.getElementById('bestTooltip');
        if (!metricTooltip || !bestTooltip) return;
        
        let hideTimeout;
        let currentElement = null;
        
        // Setup metric cell tooltips
        const cells = document.querySelectorAll('.metric-cell');
        cells.forEach(cell => {
            const tooltipDataStr = cell.getAttribute('data-tooltip-data');
            if (!tooltipDataStr) return;
            
            cell.addEventListener('mouseenter', (e) => {
                clearTimeout(hideTimeout);
                currentElement = cell;
                bestTooltip.style.display = 'none'; // Hide other tooltip
                
                try {
                    const data = JSON.parse(tooltipDataStr.replace(/&quot;/g, '"'));
                    const tooltipContent = createTooltipContent(data.metric, data.phenotype);
                    metricTooltip.innerHTML = tooltipContent;
                    metricTooltip.style.display = 'block';
                    positionTooltipAtMouse(e, metricTooltip);
                } catch (error) {
                    console.error('Error parsing tooltip data:', error);
                }
            });
            
            cell.addEventListener('mousemove', (e) => {
                if (currentElement === cell && metricTooltip.style.display === 'block') {
                    // Use requestAnimationFrame for smooth updates
                    requestAnimationFrame(() => positionTooltipAtMouse(e, metricTooltip));
                }
            });
            
            cell.addEventListener('mouseleave', () => {
                currentElement = null;
                hideTimeout = setTimeout(() => {
                    metricTooltip.style.display = 'none';
                }, 100);
            });
        });
        
        // Setup best indicator tooltips
        const bestIndicators = document.querySelectorAll('.best-indicator[data-best-tooltip]');
        bestIndicators.forEach(indicator => {
            const tooltipDataStr = indicator.getAttribute('data-best-tooltip');
            if (!tooltipDataStr) return;
            
            indicator.addEventListener('mouseenter', (e) => {
                clearTimeout(hideTimeout);
                currentElement = indicator;
                metricTooltip.style.display = 'none'; // Hide other tooltip
                
                try {
                    const data = JSON.parse(tooltipDataStr.replace(/&quot;/g, '"'));
                    let tooltipContent = '<div class="best-tooltip-header">Best Performance</div>';
                    
                    if (data.count > 0 && data.phenotypes.length > 0) {
                        tooltipContent += '<ul class="best-tooltip-list">';
                        data.phenotypes.forEach(pheno => {
                            tooltipContent += `<li>${pheno.replace(/_/g, ' ')}</li>`;
                        });
                        tooltipContent += '</ul>';
                    } else {
                        tooltipContent += '<div class="best-tooltip-empty">Not a best performer for any phenotype</div>';
                    }
                    
                    bestTooltip.innerHTML = tooltipContent;
                    bestTooltip.style.display = 'block';
                    positionTooltipAtMouse(e, bestTooltip);
                } catch (error) {
                    console.error('Error parsing best tooltip data:', error);
                }
            });
            
            indicator.addEventListener('mousemove', (e) => {
                if (currentElement === indicator && bestTooltip.style.display === 'block') {
                    requestAnimationFrame(() => positionTooltipAtMouse(e, bestTooltip));
                }
            });
            
            indicator.addEventListener('mouseleave', () => {
                currentElement = null;
                hideTimeout = setTimeout(() => {
                    bestTooltip.style.display = 'none';
                }, 100);
            });
        });
        
        // Hide tooltips on scroll
        window.addEventListener('scroll', () => {
            metricTooltip.style.display = 'none';
            bestTooltip.style.display = 'none';
        }, { passive: true });
        
        // Keep tooltips visible if hovering over them
        metricTooltip.addEventListener('mouseenter', () => {
            clearTimeout(hideTimeout);
        });
        
        metricTooltip.addEventListener('mouseleave', () => {
            metricTooltip.style.display = 'none';
        });
        
        bestTooltip.addEventListener('mouseenter', () => {
            clearTimeout(hideTimeout);
        });
        
        bestTooltip.addEventListener('mouseleave', () => {
            bestTooltip.style.display = 'none';
        });
    }
    
    // Start initialization
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
})();
</script>