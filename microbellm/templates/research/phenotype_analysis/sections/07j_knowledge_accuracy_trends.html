<!-- Knowledge Accuracy Trends Across Models -->
<div id="knowledge-trends-container" style="margin-top: 40px;">
    <!-- Header with explanation -->
    <div class="trends-header" style="margin-bottom: 20px;">
        <div class="metric-explanation" style="background: #f9fafb; padding: 15px; border-radius: 8px; border-left: 4px solid #2563eb;">
            <h4 style="margin: 0 0 8px 0; font-size: 14px; font-weight: 600; color: #1f2937;">
                <i class="fas fa-chart-line"></i> Weighted Mean Accuracy Across Phenotypes
            </h4>
            <p style="margin: 0; color: #6b7280; font-size: 13px; line-height: 1.5;">
                Each point represents a model's weighted mean accuracy for a knowledge group, calculated across all phenotypes. 
                The weighting is based on the number of predictions per phenotype, giving more weight to phenotypes with larger sample sizes.
                This provides a statistically robust comparison of how model performance changes with knowledge level.
            </p>
        </div>
    </div>
    
    <!-- Dataset selector -->
    <div class="trends-controls">
        <div class="dataset-select-group">
            <label for="trendsDatasetSelect">Knowledge Dataset:</label>
            <select id="trendsDatasetSelect" class="trends-dataset-select">
                <option value="WA_Test_Dataset">WA_Test_Dataset</option>
                <option value="LA_Test_Dataset">LA_Test_Dataset</option>
            </select>
        </div>
        <div id="trendsDatasetSummary" class="dataset-summary"></div>
    </div>

    <!-- Main Chart Area -->
    <div id="trendsChartContainer" style="background: #FAFAFA; border: 1px solid #e5e7eb; border-radius: 8px; padding: 20px;">
        <canvas id="trendsCanvas" style="width: 100%; max-width: 800px; margin: 0 auto; display: block;"></canvas>
    </div>
    
    <!-- Legend Area -->
    <div id="trendsLegend" style="margin-top: 20px; padding: 15px; background: white; border: 1px solid #e5e7eb; border-radius: 8px;">
        <!-- Legend will be populated dynamically -->
    </div>
    
    <!-- Statistics Table -->
    <div id="trendsStats" style="margin-top: 20px;">
        <h4 style="font-size: 14px; font-weight: 600; margin-bottom: 10px;">Model Performance Summary</h4>
        <p style="font-size: 12px; color: #6b7280; margin-bottom: 10px;">
            Δ columns show incremental accuracy changes between adjacent knowledge levels. 
            Positive values (green) indicate improvement with better knowledge; negative values (red) indicate decline.
        </p>
        <div id="statsTable" style="overflow-x: auto;">
            <!-- Stats table will be populated dynamically -->
        </div>
    </div>
</div>

<style>
.trends-model-line {
    cursor: pointer;
    transition: opacity 0.2s;
}

.trends-model-line:hover {
    opacity: 0.8;
}

.legend-item {
    display: inline-flex;
    align-items: center;
    margin-right: 20px;
    margin-bottom: 8px;
    cursor: pointer;
    user-select: none;
}

.legend-item.disabled {
    opacity: 0.3;
}

.legend-color {
    width: 24px;
    height: 3px;
    margin-right: 8px;
    border-radius: 2px;
}

.legend-label {
    font-size: 12px;
    color: #4b5563;
}

.stats-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 13px;
}

.stats-table th {
    background: #f3f4f6;
    padding: 8px 12px;
    text-align: left;
    font-weight: 600;
    border-bottom: 2px solid #e5e7eb;
}

.stats-table td {
    padding: 8px 12px;
    border-bottom: 1px solid #f3f4f6;
}

.stats-table tr:hover {
    background: #f9fafb;
}

.improvement-positive {
    color: #16a34a;
    font-weight: 600;
}

.improvement-negative {
    color: #dc2626;
    font-weight: 600;
}

.improvement-neutral {
    color: #6b7280;
}

.trends-controls {
    display: flex;
    justify-content: space-between;
    align-items: flex-end;
    margin-bottom: 16px;
    gap: 16px;
}

.dataset-select-group {
    display: flex;
    flex-direction: column;
    gap: 6px;
}

.dataset-select-group label {
    font-size: 13px;
    font-weight: 600;
    color: #1f2937;
}

.trends-dataset-select {
    padding: 8px 12px;
    border: 1px solid #d1d5db;
    border-radius: 6px;
    background: #ffffff;
    color: #1f2937;
    font-size: 13px;
    min-width: 220px;
}

.trends-dataset-select:focus {
    outline: none;
    border-color: #2563eb;
    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
}

.dataset-summary {
    font-size: 12px;
    color: #4b5563;
    background: #f9fafb;
    border: 1px solid #e5e7eb;
    border-radius: 6px;
    padding: 8px 12px;
    flex: 1;
}

.loading-state {
    font-size: 13px;
    color: #6b7280;
}
</style>

<style>
@media (max-width: 768px) {
    .trends-controls {
        flex-direction: column;
        align-items: stretch;
    }

    .dataset-summary {
        width: 100%;
    }
}
</style>

<script>
// Self-contained script for knowledge accuracy trends
(function() {
    console.log('[KnowledgeTrends] Script starting...');
    
    let globalData = null;
    let chartData = null;
    let activeModels = new Set();
    let currentDataset = 'WA_Test_Dataset';
    let datasetSelectEl = null;
    
    // Color palette for different models
    const modelColors = [
        '#2563eb', '#dc2626', '#16a34a', '#ea580c', '#8b5cf6',
        '#ec4899', '#06b6d4', '#f59e0b', '#10b981', '#6366f1',
        '#f43f5e', '#84cc16', '#a855f7', '#14b8a6', '#f97316'
    ];
    
    const DATASET_METADATA = {
        'WA_Test_Dataset': {
            label: 'WA Test Dataset',
            description: 'Well-annotated reference set'
        },
        'LA_Test_Dataset': {
            label: 'LA Test Dataset',
            description: 'Less-annotated expansion set'
        }
    };

    // Initialize on load
    setTimeout(function() {
        console.log('[KnowledgeTrends] Initializing...');
        initializeKnowledgeTrends();
    }, 100);
    
    // Expose for component viewer
    window.initializeKnowledgeTrends = initializeKnowledgeTrends;
    
    async function initializeKnowledgeTrends() {
        datasetSelectEl = document.getElementById('trendsDatasetSelect');
        if (datasetSelectEl) {
            datasetSelectEl.addEventListener('change', () => {
                const selected = datasetSelectEl.value || 'WA_Test_Dataset';
                if (selected !== currentDataset) {
                    currentDataset = selected;
                    loadDatasetData(currentDataset);
                }
            });
            currentDataset = datasetSelectEl.value || 'WA_Test_Dataset';
        }

        await loadDatasetData(currentDataset);
    }
    
    async function loadDatasetData(datasetName) {
        console.log(`[KnowledgeTrends] Loading data for ${datasetName}...`);
        showLoadingState();

        try {
            const response = await fetch(`/api/phenotype_accuracy_by_knowledge?dataset=${encodeURIComponent(datasetName)}`);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const result = await response.json();
            console.log('[KnowledgeTrends] Data received:', result);

            if (!result.success || !Array.isArray(result.data)) {
                updateDatasetSummary(null, 'No data available for the selected dataset');
                showError('No data available for the selected dataset');
                return;
            }

            globalData = result.data;
            chartData = null;
            processAndVisualize();
            updateDatasetSummary(result);

        } catch (error) {
            console.error('[KnowledgeTrends] Failed to load data:', error);
            globalData = null;
            chartData = null;
            updateDatasetSummary(null, 'Failed to load data');
            showError('Failed to load data: ' + error.message);
        }
    }

    function processAndVisualize() {
        if (!globalData || globalData.length === 0) {
            showError('No data available for the selected dataset');
            return;
        }

        // Calculate weighted mean accuracy for each model and knowledge group
        const modelAccuracies = calculateWeightedAccuracies();
        
        // Store for later use
        chartData = modelAccuracies;
        
        // Initialize all models as active
        activeModels = new Set();
        Object.keys(modelAccuracies).forEach(model => activeModels.add(model));
        
        // Draw the chart
        drawTrendsChart(modelAccuracies);
        
        // Create legend
        createLegend(modelAccuracies);
        
        // Create statistics table
        createStatsTable(modelAccuracies);
    }
    
    function calculateWeightedAccuracies() {
        const results = {};

        // Phenotypes considered in the manuscript analyses
        const phenotypeFields = [
            'gram_staining',
            'motility',
            'extreme_environment_tolerance',
            'biofilm_formation',
            'animal_pathogenicity',
            'biosafety_level',
            'host_association',
            'plant_pathogenicity',
            'spore_formation',
            'cell_shape'
        ];

        const MIN_SAMPLES_PER_PHENOTYPE = 30;

        // Group data by model, knowledge group, and phenotype
        const grouped = {};

        globalData.forEach(item => {
            const model = item.model;
            const rawGroup = item.knowledge_group || '';
            const knowledgeGroup = rawGroup.toLowerCase();

            if (!['limited', 'moderate', 'extensive'].includes(knowledgeGroup)) {
                return;
            }

            if (!grouped[model]) {
                grouped[model] = {};
            }

            if (!grouped[model][knowledgeGroup]) {
                grouped[model][knowledgeGroup] = {};
            }

            phenotypeFields.forEach(field => {
                const groundTruth = item.ground_truth ? item.ground_truth[field] : null;
                const prediction = item.predictions ? item.predictions[field] : null;

                const normalizedTruth = normalizePhenotypeValue(field, groundTruth);
                const normalizedPrediction = normalizePhenotypeValue(field, prediction);

                if (normalizedTruth === null || normalizedPrediction === null) {
                    return;
                }

                if (!grouped[model][knowledgeGroup][field]) {
                    grouped[model][knowledgeGroup][field] = [];
                }

                grouped[model][knowledgeGroup][field].push({
                    truth: normalizedTruth,
                    prediction: normalizedPrediction
                });
            });
        });

        // Calculate weighted mean accuracy for each model
        Object.keys(grouped).forEach(model => {
            results[model] = {};

            ['limited', 'moderate', 'extensive'].forEach(group => {
                const groupData = grouped[model][group] || {};

                let totalSamples = 0;
                const accuracies = [];

                phenotypeFields.forEach(field => {
                    const observations = groupData[field] || [];
                    if (observations.length < MIN_SAMPLES_PER_PHENOTYPE) {
                        return;
                    }

                    const balancedAccuracy = calculateBalancedAccuracy(field, observations);
                    if (!Number.isFinite(balancedAccuracy)) {
                        return;
                    }

                    accuracies.push(balancedAccuracy * 100);
                    totalSamples += observations.length;
                });

                if (accuracies.length > 0) {
                    const averageAccuracy = accuracies.reduce((sum, value) => sum + value, 0) / accuracies.length;

                    results[model][group] = {
                        accuracy: averageAccuracy,
                        sampleSize: totalSamples,
                        correct: Math.round((averageAccuracy / 100) * totalSamples)
                    };
                } else {
                    results[model][group] = { accuracy: 0, sampleSize: 0, correct: 0 };
                }
            });
        });

        return results;
    }
    
    function drawTrendsChart(data) {
        const canvas = document.getElementById('trendsCanvas');
        if (!canvas) {
            console.error('[KnowledgeTrends] Canvas not found');
            return;
        }
        
        // Setup canvas with DPI scaling
        const dpr = window.devicePixelRatio || 1;
        const displayWidth = 750;
        const displayHeight = 400;
        
        canvas.style.width = displayWidth + 'px';
        canvas.style.height = displayHeight + 'px';
        canvas.width = displayWidth * dpr;
        canvas.height = displayHeight * dpr;
        
        const ctx = canvas.getContext('2d');
        ctx.scale(dpr, dpr);
        
        // Clear canvas
        ctx.clearRect(0, 0, displayWidth, displayHeight);
        
        // Chart dimensions
        const padding = { top: 30, right: 40, bottom: 60, left: 60 };
        const chartWidth = displayWidth - padding.left - padding.right;
        const chartHeight = displayHeight - padding.top - padding.bottom;
        
        // Calculate min and max values for y-axis
        let minAccuracy = 100;
        let maxAccuracy = 0;
        
        Object.keys(data).forEach(model => {
            if (activeModels.has(model)) {
                const modelData = data[model];
                ['limited', 'moderate', 'extensive'].forEach(group => {
                    if (modelData[group].sampleSize > 0) {
                        minAccuracy = Math.min(minAccuracy, modelData[group].accuracy);
                        maxAccuracy = Math.max(maxAccuracy, modelData[group].accuracy);
                    }
                });
            }
        });
        
        // Set y-axis range with some padding
        const yMin = Math.max(0, Math.floor(minAccuracy / 10) * 10 - 10); // Round down to nearest 10 and subtract 10
        const yMax = Math.min(100, Math.ceil(maxAccuracy / 10) * 10 + 10); // Round up to nearest 10 and add 10
        const yRange = yMax - yMin;
        
        // Draw axes
        ctx.strokeStyle = '#e5e7eb';
        ctx.lineWidth = 1;
        
        // Y-axis
        ctx.beginPath();
        ctx.moveTo(padding.left, padding.top);
        ctx.lineTo(padding.left, displayHeight - padding.bottom);
        ctx.stroke();
        
        // X-axis
        ctx.beginPath();
        ctx.moveTo(padding.left, displayHeight - padding.bottom);
        ctx.lineTo(displayWidth - padding.right, displayHeight - padding.bottom);
        ctx.stroke();
        
        // Y-axis labels and grid
        ctx.fillStyle = '#6b7280';
        ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
        ctx.textAlign = 'right';
        
        // Calculate nice step size
        const yStep = yRange <= 30 ? 5 : 10;
        
        for (let i = yMin; i <= yMax; i += yStep) {
            const y = displayHeight - padding.bottom - ((i - yMin) / yRange) * chartHeight;
            ctx.fillText(i + '%', padding.left - 8, y + 4);
            
            // Grid lines
            if (i > yMin) {
                ctx.strokeStyle = '#f3f4f6';
                ctx.setLineDash([2, 2]);
                ctx.beginPath();
                ctx.moveTo(padding.left + 1, y);
                ctx.lineTo(displayWidth - padding.right, y);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }
        
        // X-axis labels
        const knowledgeGroups = ['limited', 'moderate', 'extensive'];
        const xLabels = ['Limited', 'Moderate', 'Extensive'];
        const xStep = chartWidth / (knowledgeGroups.length - 1);
        
        ctx.fillStyle = '#374151';
        ctx.font = '13px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
        ctx.textAlign = 'center';
        
        xLabels.forEach((label, index) => {
            const x = padding.left + index * xStep;
            ctx.fillText(label, x, displayHeight - padding.bottom + 20);
        });
        
        // Draw title
        ctx.fillStyle = '#111827';
        ctx.font = 'bold 14px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
        ctx.textAlign = 'center';
        const datasetLabel = getDatasetLabel(currentDataset);
        ctx.fillText(`Model Accuracy Trends Across Knowledge Levels — ${datasetLabel}`, displayWidth / 2, 20);
        
        // X-axis label
        ctx.fillStyle = '#6b7280';
        ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
        ctx.fillText('Knowledge Group', displayWidth / 2, displayHeight - 10);
        
        // Y-axis label (rotated)
        ctx.save();
        ctx.translate(15, displayHeight / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.textAlign = 'center';
        ctx.fillText('Weighted Mean Accuracy (%)', 0, 0);
        ctx.restore();
        
        // Calculate average across all active models
        const averageData = {
            limited: { accuracy: 0, count: 0 },
            moderate: { accuracy: 0, count: 0 },
            extensive: { accuracy: 0, count: 0 }
        };
        
        Object.keys(data).forEach(model => {
            if (activeModels.has(model)) {
                const modelData = data[model];
                ['limited', 'moderate', 'extensive'].forEach(group => {
                    if (modelData[group].sampleSize > 0) {
                        averageData[group].accuracy += modelData[group].accuracy;
                        averageData[group].count++;
                    }
                });
            }
        });
        
        // Calculate means
        ['limited', 'moderate', 'extensive'].forEach(group => {
            if (averageData[group].count > 0) {
                averageData[group].accuracy = averageData[group].accuracy / averageData[group].count;
            }
        });
        
        // Draw data lines and points for each model
        const models = Object.keys(data).sort();
        
        models.forEach((model, modelIndex) => {
            // Skip if model is not active
            if (!activeModels.has(model)) {
                return;
            }
            
            const color = modelColors[modelIndex % modelColors.length];
            const modelData = data[model];
            
            // Draw line
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            let firstPoint = true;
            knowledgeGroups.forEach((group, index) => {
                const x = padding.left + index * xStep;
                const accuracy = modelData[group].accuracy;
                const y = displayHeight - padding.bottom - ((accuracy - yMin) / yRange) * chartHeight;
                
                if (firstPoint) {
                    ctx.moveTo(x, y);
                    firstPoint = false;
                } else {
                    ctx.lineTo(x, y);
                }
            });
            
            ctx.stroke();
            
            // Draw points
            knowledgeGroups.forEach((group, index) => {
                const x = padding.left + index * xStep;
                const accuracy = modelData[group].accuracy;
                const y = displayHeight - padding.bottom - ((accuracy - yMin) / yRange) * chartHeight;
                const sampleSize = modelData[group].sampleSize;
                
                // Skip if no data
                if (sampleSize === 0) {
                    return;
                }
                
                // Draw point
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, 2 * Math.PI);
                ctx.fill();
                
                // White center for better visibility
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, 2 * Math.PI);
                ctx.fill();
            });
        });
        
        // Draw average line (thicker and dashed)
        if (averageData.limited.count > 0) {
            ctx.strokeStyle = '#111827';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]);
            ctx.beginPath();
            
            let firstPoint = true;
            knowledgeGroups.forEach((group, index) => {
                const x = padding.left + index * xStep;
                const accuracy = averageData[group].accuracy;
                const y = displayHeight - padding.bottom - ((accuracy - yMin) / yRange) * chartHeight;
                
                if (firstPoint) {
                    ctx.moveTo(x, y);
                    firstPoint = false;
                } else {
                    ctx.lineTo(x, y);
                }
            });
            
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw average points
            knowledgeGroups.forEach((group, index) => {
                const x = padding.left + index * xStep;
                const accuracy = averageData[group].accuracy;
                const y = displayHeight - padding.bottom - ((accuracy - yMin) / yRange) * chartHeight;
                
                // Draw larger point for average
                ctx.fillStyle = '#111827';
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, 2 * Math.PI);
                ctx.fill();
                
                // White center
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(x, y, 2.5, 0, 2 * Math.PI);
                ctx.fill();
                
                // Add label for average value
                ctx.fillStyle = '#111827';
                ctx.font = 'bold 11px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(accuracy.toFixed(1) + '%', x, y - 8);
            });
            
            // Add "Average" label
            ctx.fillStyle = '#111827';
            ctx.font = 'bold 12px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('Average', displayWidth - padding.right + 10, 
                        displayHeight - padding.bottom - ((averageData.extensive.accuracy - yMin) / yRange) * chartHeight + 4);
        }
    }
    
    function createLegend(data) {
        const legendContainer = document.getElementById('trendsLegend');
        if (!legendContainer) return;
        
        const models = Object.keys(data).sort();
        
        let legendHTML = '<div style="font-size: 13px; font-weight: 600; margin-bottom: 10px;">Models (click to toggle):</div>';
        legendHTML += '<div style="display: flex; flex-wrap: wrap;">';
        
        models.forEach((model, index) => {
            const color = modelColors[index % modelColors.length];
            const shortName = formatModelName(model);
            
            legendHTML += `
                <div class="legend-item" data-model="${model}" onclick="toggleModel('${model}')">
                    <div class="legend-color" style="background: ${color};"></div>
                    <span class="legend-label">${shortName}</span>
                </div>
            `;
        });
        
        legendHTML += '</div>';
        legendContainer.innerHTML = legendHTML;
    }
    
    function createStatsTable(data) {
        const container = document.getElementById('statsTable');
        if (!container) return;
        
        const models = Object.keys(data).sort();
        
        let tableHTML = `
            <table class="stats-table">
                <thead>
                    <tr>
                        <th>Model</th>
                        <th>Limited</th>
                        <th>Moderate</th>
                        <th>Extensive</th>
                        <th>Δ Lim→Mod</th>
                        <th>Δ Mod→Ext</th>
                        <th>Δ Total</th>
                        <th>Total Predictions</th>
                    </tr>
                </thead>
                <tbody>
        `;
        
        models.forEach((model, index) => {
            const modelData = data[model];
            const limitedAcc = modelData.limited.accuracy;
            const moderateAcc = modelData.moderate.accuracy;
            const extensiveAcc = modelData.extensive.accuracy;
            
            // Calculate incremental improvements
            const improvementLimToMod = moderateAcc - limitedAcc;
            const improvementModToExt = extensiveAcc - moderateAcc;
            const improvementTotal = extensiveAcc - limitedAcc;
            
            const totalPredictions = modelData.limited.sampleSize + 
                                    modelData.moderate.sampleSize + 
                                    modelData.extensive.sampleSize;
            
            // Color coding for improvements
            const getImprovementClass = (value) => {
                return value > 2 ? 'improvement-positive' : 
                       value < -2 ? 'improvement-negative' : 
                       'improvement-neutral';
            };
            
            tableHTML += `
                <tr>
                    <td style="font-weight: 600;">${formatModelName(model)}</td>
                    <td>${limitedAcc.toFixed(1)}% <span style="color: #9ca3af; font-size: 11px;">(n=${modelData.limited.sampleSize})</span></td>
                    <td>${moderateAcc.toFixed(1)}% <span style="color: #9ca3af; font-size: 11px;">(n=${modelData.moderate.sampleSize})</span></td>
                    <td>${extensiveAcc.toFixed(1)}% <span style="color: #9ca3af; font-size: 11px;">(n=${modelData.extensive.sampleSize})</span></td>
                    <td class="${getImprovementClass(improvementLimToMod)}">${improvementLimToMod > 0 ? '+' : ''}${improvementLimToMod.toFixed(1)}%</td>
                    <td class="${getImprovementClass(improvementModToExt)}">${improvementModToExt > 0 ? '+' : ''}${improvementModToExt.toFixed(1)}%</td>
                    <td class="${getImprovementClass(improvementTotal)}" style="font-weight: 600;">${improvementTotal > 0 ? '+' : ''}${improvementTotal.toFixed(1)}%</td>
                    <td>${totalPredictions.toLocaleString()}</td>
                </tr>
            `;
        });
        
        // Calculate and add average row
        let avgLimited = 0, avgModerate = 0, avgExtensive = 0, totalModels = 0;
        let totalPreds = 0;
        
        models.forEach(model => {
            const modelData = data[model];
            if (modelData.limited.sampleSize > 0) {
                avgLimited += modelData.limited.accuracy;
                avgModerate += modelData.moderate.accuracy;
                avgExtensive += modelData.extensive.accuracy;
                totalModels++;
                totalPreds += modelData.limited.sampleSize + modelData.moderate.sampleSize + modelData.extensive.sampleSize;
            }
        });
        
        if (totalModels > 0) {
            avgLimited = avgLimited / totalModels;
            avgModerate = avgModerate / totalModels;
            avgExtensive = avgExtensive / totalModels;
            
            const avgImprovementLimToMod = avgModerate - avgLimited;
            const avgImprovementModToExt = avgExtensive - avgModerate;
            const avgImprovementTotal = avgExtensive - avgLimited;
            
            const getImprovementClass = (value) => {
                return value > 2 ? 'improvement-positive' : 
                       value < -2 ? 'improvement-negative' : 
                       'improvement-neutral';
            };
            
            tableHTML += `
                <tr style="border-top: 3px solid #1f2937; background: #f9fafb; font-weight: bold;">
                    <td style="font-weight: 800;">Average (${totalModels} models)</td>
                    <td>${avgLimited.toFixed(1)}%</td>
                    <td>${avgModerate.toFixed(1)}%</td>
                    <td>${avgExtensive.toFixed(1)}%</td>
                    <td class="${getImprovementClass(avgImprovementLimToMod)}">${avgImprovementLimToMod > 0 ? '+' : ''}${avgImprovementLimToMod.toFixed(1)}%</td>
                    <td class="${getImprovementClass(avgImprovementModToExt)}">${avgImprovementModToExt > 0 ? '+' : ''}${avgImprovementModToExt.toFixed(1)}%</td>
                    <td class="${getImprovementClass(avgImprovementTotal)}" style="font-weight: 800;">${avgImprovementTotal > 0 ? '+' : ''}${avgImprovementTotal.toFixed(1)}%</td>
                    <td>${Math.round(totalPreds / totalModels).toLocaleString()}</td>
                </tr>
            `;
        }
       
       tableHTML += '</tbody></table>';
       container.innerHTML = tableHTML;
    }

    function updateDatasetSummary(result, errorMessage) {
        const summaryEl = document.getElementById('trendsDatasetSummary');
        if (!summaryEl) return;

        if (errorMessage) {
            summaryEl.innerHTML = `<span style="color: #dc2626;">${errorMessage}</span>`;
            return;
        }

        if (!result || !globalData) {
            summaryEl.textContent = 'No data available';
            return;
        }

        const meta = DATASET_METADATA[currentDataset] || { label: currentDataset };
        const predictionCount = result.total_results || globalData.length;
        const modelCount = result.models ? result.models.length : new Set(globalData.map(d => d.model)).size;
        const knowledgeCount = result.knowledge_groups ? result.knowledge_groups.length : new Set(globalData.map(d => d.knowledge_group)).size;
        const speciesCount = result.species_count || new Set(globalData.map(d => d.binomial_name)).size;

        summaryEl.textContent = `${meta.label}: ${predictionCount.toLocaleString()} predictions • ${modelCount} models • ${knowledgeCount} knowledge groups • ${speciesCount.toLocaleString()} species`;
    }

    function getDatasetLabel(datasetName) {
        const meta = DATASET_METADATA[datasetName];
        if (meta && meta.label) {
            return meta.label;
        }
        return datasetName.replace(/_/g, ' ');
    }

    function showLoadingState() {
        const legendContainer = document.getElementById('trendsLegend');
        if (legendContainer) {
            legendContainer.innerHTML = '<div class="loading-state"><i class="fas fa-spinner fa-spin"></i> Loading dataset…</div>';
        }

        const statsContainer = document.getElementById('statsTable');
        if (statsContainer) {
            statsContainer.innerHTML = '';
        }

        const summaryEl = document.getElementById('trendsDatasetSummary');
        if (summaryEl) {
            summaryEl.innerHTML = '<span class="loading-state"><i class="fas fa-spinner fa-spin"></i> Loading…</span>';
        }
    }
    
    // Toggle model visibility
    window.toggleModel = function(model) {
        if (activeModels.has(model)) {
            activeModels.delete(model);
        } else {
            activeModels.add(model);
        }
        
        // Update legend appearance
        const legendItem = document.querySelector(`.legend-item[data-model="${model}"]`);
        if (legendItem) {
            legendItem.classList.toggle('disabled');
        }
        
        // Redraw chart
        drawTrendsChart(chartData);
    };
    
    function normalizePhenotypeValue(phenotype, value) {
        if (value === null || value === undefined) {
            return null;
        }

        const trimmed = String(value).trim();
        if (!trimmed) {
            return null;
        }

        const normalized = trimmed.toLowerCase();
        if (normalized === 'na' || normalized === 'n/a' || normalized === '-') {
            return null;
        }

        if (phenotype === 'gram_staining') {
            if (normalized.includes('positive')) return 'positive';
            if (normalized.includes('negative')) return 'negative';
            if (normalized.includes('variable')) return 'variable';
        }

        if (phenotype === 'biosafety_level') {
            if (normalized.includes('1')) return 'level_1';
            if (normalized.includes('2')) return 'level_2';
            if (normalized.includes('3')) return 'level_3';
        }

        if (phenotype === 'cell_shape') {
            if (normalized.includes('bacillus')) return 'bacillus';
            if (normalized.includes('coccus')) return 'coccus';
            if (normalized.includes('spirillum')) return 'spirillum';
            if (normalized.includes('tail')) return 'tail';
            if (normalized.includes('filamentous')) return 'filamentous';
        }

        if (normalized === 'true' || normalized === 't' || normalized === 'yes' || normalized === '1') {
            return true;
        }
        if (normalized === 'false' || normalized === 'f' || normalized === 'no' || normalized === '0') {
            return false;
        }

        return normalized;
    }

    function calculateBalancedAccuracy(phenotype, observations) {
        const truths = observations.map(o => o.truth);
        const preds = observations.map(o => o.prediction);

        const isBoolean = typeof truths[0] === 'boolean' || typeof preds[0] === 'boolean';

        if (isBoolean) {
            let tp = 0, tn = 0, fp = 0, fn = 0;
            observations.forEach(({ truth, prediction }) => {
                if (prediction === true && truth === true) tp++;
                else if (prediction === true && truth === false) fp++;
                else if (prediction === false && truth === false) tn++;
                else if (prediction === false && truth === true) fn++;
            });

            const sensitivity = tp + fn > 0 ? tp / (tp + fn) : 0;
            const specificity = tn + fp > 0 ? tn / (tn + fp) : 0;
            return (sensitivity + specificity) / 2;
        }

        const labels = Array.from(new Set(truths.concat(preds)));
        if (labels.length === 0) {
            return NaN;
        }

        const counts = {};
        labels.forEach(label => {
            counts[label] = { tp: 0, fn: 0 };
        });

        observations.forEach(({ truth, prediction }) => {
            if (!counts[truth]) {
                counts[truth] = { tp: 0, fn: 0 };
            }
            if (!counts[prediction]) {
                counts[prediction] = { tp: 0, fn: 0 };
            }

            if (truth === prediction) {
                counts[truth].tp += 1;
            } else {
                counts[truth].fn += 1;
            }
        });

        const recalls = labels.map(label => {
            const { tp, fn } = counts[label] || { tp: 0, fn: 0 };
            return tp + fn > 0 ? tp / (tp + fn) : 0;
        });

        const recallSum = recalls.reduce((sum, value) => sum + value, 0);
        return recallSum / recalls.length;
    }
    
    function formatModelName(modelName) {
        if (!modelName.includes('/')) return modelName;
        const [provider, model] = modelName.split('/');
        const providerMap = {
            'anthropic': 'Anthropic',
            'openai': 'OpenAI',
            'google': 'Google',
            'meta-llama': 'Meta',
            'mistralai': 'Mistral',
            'cohere': 'Cohere',
            'deepseek': 'DeepSeek'
        };
        const displayProvider = providerMap[provider] || provider.charAt(0).toUpperCase() + provider.slice(1);
        return `${displayProvider} ${model}`;
    }
    
    function showError(message) {
        const canvas = document.getElementById('trendsCanvas');
        if (canvas) {
            const ctx = canvas.getContext('2d');
            if (ctx) {
                const dpr = window.devicePixelRatio || 1;
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.scale(dpr, dpr);
                const displayWidth = canvas.width / dpr;
                const displayHeight = canvas.height / dpr;
                ctx.fillStyle = '#6b7280';
                ctx.font = '14px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(message, displayWidth / 2, displayHeight / 2);
            }
        }

        const legendContainer = document.getElementById('trendsLegend');
        if (legendContainer) {
            legendContainer.innerHTML = `<div style="color: #dc2626;">${message}</div>`;
        }

        const statsContainer = document.getElementById('statsTable');
        if (statsContainer) {
            statsContainer.innerHTML = `<div style="padding: 16px; color: #dc2626;">${message}</div>`;
        }
    }
})();
</script>
