<!-- Model Parameters vs Accuracy -->
<style>
    .parameters-accuracy-container {
        padding: var(--spacing-component) 0;
    }

    .params-chart-wrapper {
        background: var(--bg-secondary);
        border-radius: 12px;
        padding: var(--spacing-element);
        margin-bottom: var(--spacing-component);
        height: 500px;
        position: relative;
        overflow: hidden;
    }

    .params-chart-canvas-container {
        position: relative;
        height: 450px;
        width: 100%;
    }

    #paramsAccuracyChart {
        display: block !important;
        max-width: 100% !important;
        max-height: 450px !important;
    }

    .params-chart-controls {
        display: flex;
        gap: var(--spacing-element);
        margin-bottom: var(--spacing-element);
        flex-wrap: wrap;
        align-items: center;
        justify-content: center;
    }

    .params-control-group {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .params-control-group label {
        font-weight: 500;
        font-size: 14px;
    }

    .params-control-group select {
        padding: 6px 12px;
        font-size: 14px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        background: white;
        cursor: pointer;
    }

    .params-metadata-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: var(--spacing-element);
        margin-top: var(--spacing-component);
    }

    .params-stat-card {
        background: white;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: var(--spacing-small);
    }

    .params-stat-card h4 {
        font-size: 14px;
        font-weight: 600;
        color: var(--text-secondary);
        margin-bottom: 8px;
    }

    .params-stat-value {
        font-size: 24px;
        font-weight: 700;
        color: var(--text-primary);
    }

    .params-stat-description {
        font-size: 12px;
        color: var(--text-secondary);
        margin-top: 4px;
    }

    .params-loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 255, 0.95);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 100;
        border-radius: 12px;
    }

    .params-loading-spinner {
        width: 50px;
        height: 50px;
        border: 4px solid #f3f3f3;
        border-top: 4px solid #22c55e;
        border-radius: 50%;
        animation: paramsSpin 1s linear infinite;
        margin-bottom: 20px;
    }

    @keyframes paramsSpin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .params-loading-text {
        font-size: 16px;
        color: #666;
        font-weight: 500;
    }

    .params-loading-subtext {
        font-size: 14px;
        color: #999;
        margin-top: 8px;
    }

    .params-chart-legend {
        display: flex;
        justify-content: center;
        gap: var(--spacing-element);
        margin-top: var(--spacing-element);
        flex-wrap: wrap;
    }

    .params-legend-item {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 12px;
    }

    .params-legend-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
    }
</style>

<div class="parameters-accuracy-container">
    <div class="params-chart-controls">
        <div class="params-control-group">
            <label for="paramsDatasetSelect">Dataset:</label>
            <select id="paramsDatasetSelect">
                <option value="">Loading datasets...</option>
            </select>
        </div>
        <div class="params-control-group">
            <label for="paramsMetricSelect">Metric:</label>
            <select id="paramsMetricSelect">
                <option value="balanced_accuracy">Balanced Accuracy</option>
                <option value="precision">Precision</option>
                <option value="recall">Recall</option>
                <option value="f1">F1 Score</option>
            </select>
        </div>
        <div class="params-control-group">
            <label for="paramsPhenotypeSelect">Phenotype:</label>
            <select id="paramsPhenotypeSelect">
                <option value="average">All Phenotypes (Average)</option>
                <option value="gram_staining">Gram Staining</option>
                <option value="motility">Motility</option>
                <option value="extreme_environment_tolerance">Extreme Environment Tolerance</option>
                <option value="biofilm_formation">Biofilm Formation</option>
                <option value="animal_pathogenicity">Animal Pathogenicity</option>
                <option value="biosafety_level">Biosafety Level</option>
                <option value="host_association">Host Association</option>
                <option value="plant_pathogenicity">Plant Pathogenicity</option>
                <option value="spore_formation">Spore Formation</option>
                <option value="hemolysis">Hemolysis</option>
                <option value="cell_shape">Cell Shape</option>
            </select>
        </div>
    </div>

    <div class="params-chart-wrapper">
        <div class="params-loading-overlay" id="paramsChartLoadingOverlay" style="display: none;">
            <div class="params-loading-spinner"></div>
            <div class="params-loading-text">Loading Data...</div>
            <div class="params-loading-subtext" id="paramsLoadingStatus">Fetching predictions and calculating metrics</div>
        </div>
        <div class="params-chart-canvas-container">
            <canvas id="paramsAccuracyChart"></canvas>
        </div>
        <div class="params-chart-legend" id="paramsChartLegend"></div>
    </div>

    <div class="params-metadata-stats">
        <div class="params-stat-card">
            <h4>Models with Size Data</h4>
            <div class="params-stat-value" id="modelsWithParams">0</div>
            <div class="params-stat-description" id="modelsWithParamsDesc">out of 0 total models</div>
        </div>
        <div class="params-stat-card">
            <h4>Size Range</h4>
            <div class="params-stat-value" id="sizeRange">-</div>
            <div class="params-stat-description">Parameters (B)</div>
        </div>
        <div class="params-stat-card">
            <h4>Correlation</h4>
            <div class="params-stat-value" id="paramsCorrelation">-</div>
            <div class="params-stat-description" id="paramsCorrelationDesc">Size vs. Performance</div>
        </div>
        <div class="params-stat-card">
            <h4>Most Efficient Model</h4>
            <div class="params-stat-value" id="mostEfficient">-</div>
            <div class="params-stat-description">Best performance per parameter</div>
        </div>
    </div>
</div>

<script src="/static/js/phenotype_metrics.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.29.4/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment@1.0.1/dist/chartjs-adapter-moment.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function() {
    let predictionData = [];
    let groundTruthData = {};
    let modelMetadata = {};
    let paramsChart = null;
    let fieldDefinitions = {};
    let metricsCache = [];
    let metricsIndex = new Map();
    let availablePhenotypes = [];

    const EXCLUDED_PHENOTYPES = new Set(['aerophilicity', 'health_association']);
    const AVERAGE_PHENOTYPES = new Set(['gram_staining', 'motility', 'extreme_environment_tolerance', 'biofilm_formation', 'animal_pathogenicity', 'biosafety_level', 'host_association', 'plant_pathogenicity', 'spore_formation', 'cell_shape']);
    const SAMPLE_SIZE_THRESHOLD = 100;

    loadModelMetadata();
    initializeDatasetSelector();

    async function loadModelMetadata() {
        try {
            const response = await fetch('/static/data/year_size.tsv');
            const text = await response.text();
            const lines = text.trim().split('\n');
            const headers = lines[0].split('\t');

            modelMetadata = {};
            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split('\t');
                const row = {};
                headers.forEach((header, index) => {
                    row[header] = values[index] || '';
                });

                const modelName = row['Model'];
                if (modelName) {
                    const variants = [
                        modelName,
                        modelName.toLowerCase(),
                        modelName.toLowerCase().replace(/\s+/g, ''),
                        modelName.toLowerCase().replace(/[-_\s]+/g, ''),
                        modelName.replace(/-/g, ''),
                        modelName.replace(/[_\-\s]/g, '')
                    ];
                    variants.forEach(key => {
                        modelMetadata[key] = row;
                    });
                }
            }
        } catch (error) {
            console.error('Error loading model metadata:', error);
            modelMetadata = {};
        }
    }

    async function initializeDatasetSelector() {
        try {
            const response = await fetch('/api/ground_truth/datasets');
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const result = await response.json();

            const select = document.getElementById('paramsDatasetSelect');
            if (!result.success || !result.datasets || result.datasets.length === 0) {
                select.innerHTML = '<option value="">No datasets available</option>';
                return;
            }

            select.innerHTML = '<option value="">Select a dataset...</option>';
            let waTestDataset = null;

            result.datasets.forEach(dataset => {
                const option = document.createElement('option');
                option.value = dataset.dataset_name;
                option.textContent = `${dataset.dataset_name} (${dataset.species_count} species)`;
                option.dataset = {
                    template: dataset.template_name,
                    count: dataset.species_count
                };
                select.appendChild(option);
                if (dataset.dataset_name === 'WA_Test_Dataset') {
                    waTestDataset = dataset;
                }
            });

            select.addEventListener('change', async (event) => {
                if (event.target.value) {
                    await loadPerformanceData(event.target.value);
                }
            });

            document.getElementById('paramsMetricSelect').addEventListener('change', updateChart);
            document.getElementById('paramsPhenotypeSelect').addEventListener('change', updateChart);

            if (waTestDataset) {
                select.value = 'WA_Test_Dataset';
                await loadPerformanceData('WA_Test_Dataset');
            }
        } catch (error) {
            console.error('Error loading datasets:', error);
            const select = document.getElementById('paramsDatasetSelect');
            select.innerHTML = '<option value="">Error loading datasets</option>';
        }
    }

    function showLoading(message = 'Loading data...') {
        const overlay = document.getElementById('paramsChartLoadingOverlay');
        const status = document.getElementById('paramsLoadingStatus');
        if (overlay) {
            overlay.style.display = 'flex';
            if (status) {
                status.textContent = message;
            }
        }
    }

    function hideLoading() {
        const overlay = document.getElementById('paramsChartLoadingOverlay');
        if (overlay) {
            overlay.style.display = 'none';
        }
    }

    async function loadPerformanceData(datasetName) {
        try {
            showLoading('Fetching prediction data...');
            const select = document.getElementById('paramsDatasetSelect');
            const option = select.selectedOptions[0];
            const templateName = option?.dataset.template || '';
            const details = document.getElementById('datasetDetails');

            let speciesFile = 'wa_with_gcount.txt';
            if (datasetName.toLowerCase().includes('artificial')) {
                speciesFile = 'artificial.txt';
            }

            const predResponse = await fetch(`/api/phenotype_analysis_filtered?species_file=${encodeURIComponent(speciesFile)}`);
            const predResult = await predResponse.json();

            if (!predResult.data || predResult.data.length === 0) {
                throw new Error('No prediction data available');
            }
            predictionData = predResult.data;

            showLoading('Loading ground truth data...');
            const gtResponse = await fetch(`/api/ground_truth/data?dataset=${datasetName}&per_page=20000`);
            const gtResult = await gtResponse.json();
            if (!gtResult.success || !gtResult.data) {
                throw new Error('Failed to load ground truth data');
            }

            groundTruthData = {};
            gtResult.data.forEach(item => {
                if (item.binomial_name) {
                    groundTruthData[item.binomial_name.toLowerCase()] = item;
                }
            });

            fieldDefinitions = {};
            if (templateName) {
                showLoading('Loading phenotype definitions...');
                const templateResp = await fetch(`/api/template_field_definitions?template=${templateName}`);
                const templateResult = await templateResp.json();
                if (templateResult.success && templateResult.field_definitions) {
                    fieldDefinitions = templateResult.field_definitions;
                }
            }

            availablePhenotypes = Object.keys(fieldDefinitions || {}).filter(ph => !EXCLUDED_PHENOTYPES.has(ph));
            if (!availablePhenotypes.length && predictionData.length) {
                availablePhenotypes = Object.keys(predictionData[0] || {})
                    .filter(key => !['model', 'binomial_name'].includes(key))
                    .filter(ph => !EXCLUDED_PHENOTYPES.has(ph));
            }

            metricsCache = window.PhenotypeMetrics.calculateMetrics(predictionData, groundTruthData, {
                phenotypes: availablePhenotypes
            });
            console.log('Metrics cache computed:', metricsCache.length, 'phenotypes:', availablePhenotypes.length);
            metricsIndex = new Map();
            metricsCache.forEach(metric => {
                metricsIndex.set(`${metric.model}||${metric.phenotype}`, metric);
            });
            console.log('Metrics cache computed:', metricsCache.length, 'phenotypes:', availablePhenotypes.length);

            const uniqueModels = new Set(predictionData.map(p => p.model));
            const uniqueSpecies = new Set(predictionData.map(p => p.binomial_name));
            if (details) {
                details.innerHTML = `<span>${uniqueSpecies.size} species • ${uniqueModels.size} models • ${predictionData.length.toLocaleString()} predictions</span>`;
            }

            const infoSection = document.getElementById('initialMessage');
            if (infoSection) {
                infoSection.style.display = 'none';
            }
            const resultsSection = document.getElementById('resultsArea');
            if (resultsSection) {
                resultsSection.style.display = 'block';
            }

            updateChart();
        } catch (error) {
            console.error('Error loading performance data:', error);
            alert('Error loading performance data: ' + error.message);
            hideLoading();
        }
    }

    function findModelMetadata(modelName) {
        if (!modelMetadata || !modelName) return null;
        let cleanModelName = modelName;
        if (modelName.includes('/')) {
            const parts = modelName.split('/');
            cleanModelName = parts[parts.length - 1];
        }

        const candidates = [
            modelName,
            cleanModelName,
            modelName.toLowerCase(),
            cleanModelName.toLowerCase(),
            modelName.toLowerCase().replace(/[-_\s]+/g, ''),
            cleanModelName.toLowerCase().replace(/[-_\s]+/g, '')
        ];

        for (const key of candidates) {
            if (modelMetadata[key]) {
                return modelMetadata[key];
            }
        }

        const fallback = Object.keys(modelMetadata).find(key => {
            const normalizedKey = key.toLowerCase().replace(/[-_\s]+/g, '');
            const normalizedTarget = cleanModelName.toLowerCase().replace(/[-_\s]+/g, '');
            return normalizedKey === normalizedTarget ||
                   normalizedKey.includes(normalizedTarget) ||
                   normalizedTarget.includes(normalizedKey);
        });

        return fallback ? modelMetadata[fallback] : null;
    }

    function parseParameters(paramStr) {
        if (!paramStr || paramStr === '' || paramStr === 'Unknown') return null;
        const cleanStr = paramStr.replace(/,/g, '');
        const num = parseFloat(cleanStr);
        return Number.isFinite(num) && num > 0 ? num : null;
    }

    function formatParameters(num) {
        if (num >= 1e12) return (num / 1e12).toFixed(1) + 'T';
        if (num >= 1e9) return (num / 1e9).toFixed(1) + 'B';
        if (num >= 1e6) return (num / 1e6).toFixed(1) + 'M';
        if (num >= 1e3) return (num / 1e3).toFixed(1) + 'K';
        return num.toString();
    }

    function updateChart() {
        if (!predictionData.length || !metricsCache.length) {
            return;
        }

        showLoading('Calculating metrics...');

        const metricSelection = document.getElementById('paramsMetricSelect').value;
        const phenotypeSelection = document.getElementById('paramsPhenotypeSelect').value;

        const metricKeyMap = {
            balanced_accuracy: 'balancedAcc',
            precision: 'precision',
            recall: 'recall',
            f1: 'f1'
        };
        const metricKey = metricKeyMap[metricSelection] || 'balancedAcc';

        const predictionsByModel = new Map();
        predictionData.forEach(pred => {
            if (!pred.model) return;
            if (!predictionsByModel.has(pred.model)) {
                predictionsByModel.set(pred.model, []);
            }
            predictionsByModel.get(pred.model).push(pred);
        });

        const chartData = [];
        let modelsWithParams = 0;
        const totalModels = predictionsByModel.size;

        predictionsByModel.forEach((rows, model) => {
            const meta = findModelMetadata(model);
            const parameters = meta ? parseParameters(meta['Parameters']) : null;
            if (!parameters) {
                return;
            }

            let metricValue = null;
            let phenotypeCount = 0;
            let aggregateSampleSize = 0;

            if (phenotypeSelection === 'average') {
                const validMetrics = metricsCache
                    .filter(metric => metric.model === model && AVERAGE_PHENOTYPES.has(metric.phenotype) && Number.isFinite(metric[metricKey]) && metric.sampleSize >= SAMPLE_SIZE_THRESHOLD);

                if (validMetrics.length === 0) {
                    return;
                }

                metricValue = validMetrics.reduce((sum, metric) => sum + metric[metricKey], 0) / validMetrics.length;
                phenotypeCount = validMetrics.length;
                aggregateSampleSize = validMetrics.reduce((sum, metric) => sum + metric.sampleSize, 0);
            } else {
                const metric = metricsIndex.get(`${model}||${phenotypeSelection}`);
                if (!metric || !Number.isFinite(metric[metricKey]) || metric.sampleSize < SAMPLE_SIZE_THRESHOLD) {
                    return;
                }
                metricValue = metric[metricKey];
                phenotypeCount = 1;
                aggregateSampleSize = metric.sampleSize;
            }

            if (metricValue === null || metricValue === undefined) {
                return;
            }

            modelsWithParams++;
            chartData.push({
                x: metricValue,
                y: parameters,
                model,
                organization: meta['Organization'] || 'Unknown',
                parameters,
                parameterStr: formatParameters(parameters),
                phenotype_count: phenotypeCount,
                sampleSize: aggregateSampleSize,
                publicationDate: meta['Publication date'] || 'Unknown'
            });
        });

        setTimeout(() => {
            updateStatistics(chartData, metricSelection, modelsWithParams, totalModels);
            createScatterChart(chartData, metricSelection);
            hideLoading();
        }, 100);
    }

    function updateStatistics(chartData, metric, modelsWithParams, totalModels) {
        document.getElementById('modelsWithParams').textContent = modelsWithParams;
        document.getElementById('modelsWithParamsDesc').textContent = `out of ${totalModels} total models`;

        if (chartData.length > 0) {
            const parameters = chartData.map(d => d.parameters);
            const minParams = Math.min(...parameters);
            const maxParams = Math.max(...parameters);
            document.getElementById('sizeRange').textContent = `${formatParameters(minParams)} - ${formatParameters(maxParams)}`;

            const correlation = calculateCorrelation(chartData);
            document.getElementById('paramsCorrelation').textContent = correlation.toFixed(3);
            document.getElementById('paramsCorrelationDesc').textContent =
                correlation > 0.3 ? 'Larger models perform better' :
                correlation < -0.3 ? 'Smaller models perform better' : 'No clear relationship';

            const efficiency = chartData.map(d => ({
                model: d.model,
                efficiency: d.x / Math.log10(d.parameters)
            }));
            const mostEfficient = efficiency.reduce((best, current) =>
                current.efficiency > best.efficiency ? current : best
            );
            document.getElementById('mostEfficient').textContent = mostEfficient.model.split('/').pop();
        } else {
            document.getElementById('sizeRange').textContent = '-';
            document.getElementById('paramsCorrelation').textContent = '-';
            document.getElementById('paramsCorrelationDesc').textContent = 'Size vs. Performance';
            document.getElementById('mostEfficient').textContent = '-';
        }
    }

    function calculateCorrelation(data) {
        if (data.length < 2) return 0;
        const xValues = data.map(d => d.x);
        const yValues = data.map(d => Math.log10(d.y));

        const n = xValues.length;
        const sumX = xValues.reduce((a, b) => a + b, 0);
        const sumY = yValues.reduce((a, b) => a + b, 0);
        const sumXY = xValues.reduce((sum, x, i) => sum + x * yValues[i], 0);
        const sumX2 = xValues.reduce((sum, x) => sum + x * x, 0);
        const sumY2 = yValues.reduce((sum, y) => sum + y * y, 0);

        const numerator = (n * sumXY) - (sumX * sumY);
        const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
        const correlation = denominator !== 0 ? numerator / denominator : 0;
        return Number.isFinite(correlation) ? correlation : 0;
    }

    function createScatterChart(data, metric) {
        const canvas = document.getElementById('paramsAccuracyChart');
        if (!canvas) {
            console.error('Canvas element not found');
            return;
        }

        if (!data || data.length === 0) {
            console.warn('No data to display in chart');
            if (paramsChart) {
                paramsChart.destroy();
                paramsChart = null;
            }
            return;
        }

        const xValues = data.map(d => d.x);
        const minX = Math.min(...xValues);
        const maxX = Math.max(...xValues);
        const xPadding = (maxX - minX) * 0.05;
        const xMin = Math.max(0, minX - xPadding);
        const xMax = Math.min(1, maxX + xPadding);

        if (paramsChart) {
            paramsChart.destroy();
            paramsChart = null;
        }
        const existingChart = Chart.getChart(canvas);
        if (existingChart) {
            existingChart.destroy();
        }

        const ctx = canvas.getContext('2d');
        const organizations = [...new Set(data.map(d => d.organization))];
        const colors = ['#60A5FA', '#C084FC', '#86EFAC', '#FCA5A5', '#FDBA74', '#67E8F9', '#A5B4FC', '#FDE047', '#C7D2FE', '#FED7AA'];
        const colorMap = {};
        organizations.forEach((org, index) => {
            colorMap[org] = colors[index % colors.length];
        });

        const datasets = organizations.map(org => ({
            label: org,
            data: data.filter(d => d.organization === org),
            backgroundColor: colorMap[org],
            borderColor: colorMap[org],
            borderWidth: 2,
            pointRadius: 6,
            pointHoverRadius: 8,
            showLine: false
        }));

        const prettyMetric = metric.replace('_', ' ').replace(/\w/g, l => l.toUpperCase());

        paramsChart = new Chart(ctx, {
            type: 'scatter',
            data: { datasets },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const point = context.raw;
                                return [
                                    `Model: ${point.model}`,
                                    `Parameters: ${point.parameterStr}`,
                                    `${prettyMetric}: ${point.x.toFixed(3)}`,
                                    `Organization: ${point.organization}`,
                                    `Published: ${point.publicationDate}`,
                                    `Phenotypes evaluated: ${point.phenotype_count}`,
                                    `Samples: ${point.sampleSize}`
                                ];
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        type: 'linear',
                        position: 'bottom',
                        title: { display: true, text: prettyMetric },
                        min: xMin,
                        max: xMax,
                        ticks: {
                            callback: function(value) {
                                return Number(value).toFixed(2);
                            }
                        },
                        grid: { display: true, color: 'rgba(0, 0, 0, 0.05)' }
                    },
                    y: {
                        type: 'logarithmic',
                        title: { display: true, text: 'Model Parameters (log scale)' },
                        ticks: {
                            callback: function(value) {
                                return formatParameters(value);
                            }
                        },
                        grid: { display: true, color: 'rgba(0, 0, 0, 0.05)' }
                    }
                }
            }
        });

        updateLegend(organizations, colorMap);
    }
    function updateLegend(organizations, colorMap) {
        const legendContainer = document.getElementById('paramsChartLegend');
        if (!legendContainer) return;
        legendContainer.innerHTML = '';

        organizations.slice(0, 10).forEach(org => {
            const item = document.createElement('div');
            item.className = 'params-legend-item';
            item.innerHTML = `
                <div class="params-legend-dot" style="background: ${colorMap[org]}"></div>
                <span>${org}</span>
            `;
            legendContainer.appendChild(item);
        });

        if (organizations.length > 10) {
            const item = document.createElement('div');
            item.className = 'params-legend-item';
            item.innerHTML = `<span>... and ${organizations.length - 10} more</span>`;
            legendContainer.appendChild(item);
        }
    }

});
</script>
