<!-- Dataset Expansion Visualization -->
<div id="datasetExpansionContent">
    <style>
    /* Dataset Expansion Styles */
    .expansion-section {
        padding: 0;
        background: transparent;
    }

    /* Controls Panel */
    .expansion-controls-panel {
        display: flex;
        gap: 20px;
        align-items: flex-end;
        margin-bottom: 30px;
        padding: 20px;
        background: #f8f9fa;
        border-radius: 8px;
        border: 1px solid #dee2e6;
    }

    .expansion-dataset-selector {
        flex: 1;
    }

    .expansion-dataset-selector label {
        display: block;
        margin-bottom: 8px;
        font-weight: 500;
        color: #495057;
        font-size: 14px;
    }

    .expansion-dataset-select {
        width: 100%;
        padding: 10px 12px;
        border: 1px solid #ced4da;
        border-radius: 6px;
        background: white;
        color: #495057;
        font-size: 14px;
        cursor: pointer;
    }

    .expansion-dataset-select:focus {
        outline: none;
        border-color: #22c55e;
        box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.1);
    }

    .expansion-dataset-details {
        margin-top: 8px;
        font-size: 12px;
        color: #6c757d;
    }

    /* Visualization Container */
    .expansion-viz-container {
        display: none;
        background: white;
        border-radius: 12px;
        padding: 32px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
    }

    .expansion-header {
        text-align: center;
        margin-bottom: 40px;
    }

    .expansion-title {
        font-size: 28px;
        font-weight: 700;
        color: #1a202c;
        margin: 0 0 8px 0;
    }

    .expansion-subtitle {
        font-size: 15px;
        color: #718096;
        font-weight: 400;
    }

    /* Chart Container */
    .expansion-chart-wrapper {
        background: #fafbfc;
        border: 1px solid #e1e4e8;
        border-radius: 10px;
        padding: 24px;
    }

    .chart-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 24px;
        padding-bottom: 16px;
        border-bottom: 2px solid #e2e8f0;
    }

    .chart-title {
        font-size: 18px;
        font-weight: 600;
        color: #2d3748;
    }

    .chart-legend {
        display: flex;
        gap: 20px;
        font-size: 13px;
    }

    .legend-item {
        display: flex;
        align-items: center;
        gap: 6px;
    }

    .legend-color {
        width: 16px;
        height: 16px;
        border-radius: 3px;
    }

    .legend-color.ground-truth {
        background: linear-gradient(135deg, #3b82f6, #2563eb);
    }

    .legend-color.llm-added {
        background: linear-gradient(135deg, #ef4444, #dc2626);
    }

    /* SVG Container */
    .expansion-svg-container {
        width: 100%;
        overflow-x: auto;
    }

    /* Loading State */
    .expansion-loading {
        text-align: center;
        padding: 60px 20px;
        color: #6c757d;
    }

    .expansion-loading i {
        font-size: 48px;
        color: #dee2e6;
        margin-bottom: 16px;
    }

    /* Summary Stats */
    .expansion-stats {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 20px;
        margin-top: 24px;
    }

    .stat-card {
        background: white;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        padding: 16px;
        text-align: center;
    }

    .stat-value {
        font-size: 28px;
        font-weight: 700;
        color: #1a202c;
        margin-bottom: 4px;
    }

    .stat-label {
        font-size: 13px;
        color: #718096;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    /* Responsive */
    @media (max-width: 768px) {
        .expansion-stats {
            grid-template-columns: 1fr;
        }
    }
    </style>

    <!-- Dataset Selector -->
    <div class="expansion-controls-panel">
        <div class="expansion-dataset-selector">
            <label>Ground Truth Dataset:</label>
            <select id="expansionGroundTruthDataset" class="expansion-dataset-select">
                <option value="">Loading datasets...</option>
            </select>
            <div class="expansion-dataset-details" id="expansionDatasetDetails"></div>
        </div>
    </div>

    <!-- Visualization Container -->
    <div id="expansionVizContainer" class="expansion-viz-container">
        <div class="expansion-header">
            <h2 class="expansion-title">Dataset Expansion Analysis</h2>
            <p class="expansion-subtitle">LLM-generated annotations vs ground truth data</p>
        </div>

        <div class="expansion-chart-wrapper">
            <div class="chart-header">
                <h3 class="chart-title">Added Phenotype Annotations</h3>
                <div class="chart-legend">
                    <div class="legend-item">
                        <div class="legend-color ground-truth"></div>
                        <span>Ground Truth</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color llm-added"></div>
                        <span>LLM Added</span>
                    </div>
                </div>
            </div>
            <div id="expansionChart" class="expansion-svg-container"></div>
        </div>

        <div class="expansion-stats" id="expansionStats">
            <!-- Stats will be populated dynamically -->
        </div>
    </div>

    <!-- Loading State -->
    <div class="expansion-loading" id="expansionLoadingState">
        <i class="fas fa-database"></i>
        <p>Select a dataset to view expansion analysis</p>
    </div>

    <script>
    /* ===== Dataset Expansion Visualization ===== */
    (function() {
        'use strict';
        
        let groundTruthData = null;
        let predictionData = null;
        
        // Initialize the component
        function initExpansion() {
            loadGroundTruthDatasets();
        }
        
        // Load available ground truth datasets
        async function loadGroundTruthDatasets() {
            try {
                const response = await fetch('/api/ground_truth/datasets');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const result = await response.json();
                
                if (result.success && result.datasets) {
                    const select = document.getElementById('expansionGroundTruthDataset');
                    
                    if (result.datasets.length === 0) {
                        select.innerHTML = '';
                        const emptyOpt = document.createElement('option');
                        emptyOpt.value = '';
                        emptyOpt.textContent = 'No datasets available';
                        select.appendChild(emptyOpt);
                        return;
                    }
                    
                    // Build options
                    select.innerHTML = '';
                    let waTestDataset = null;
                    
                    // Add default option
                    const defaultOpt = document.createElement('option');
                    defaultOpt.value = '';
                    defaultOpt.textContent = 'Select a dataset...';
                    select.appendChild(defaultOpt);
                    
                    // Add dataset options
                    result.datasets.forEach(dataset => {
                        const opt = document.createElement('option');
                        opt.value = dataset.dataset_name;
                        opt.textContent = dataset.dataset_name;
                        opt.dataset.template = dataset.template_name;
                        opt.dataset.count = dataset.species_count;
                        select.appendChild(opt);
                        
                        if (dataset.dataset_name === 'WA_Test_Dataset') {
                            waTestDataset = dataset;
                        }
                    });
                    
                    // Add change listener
                    select.addEventListener('change', () => {
                        updateDatasetInfo();
                        if (select.value) {
                            performAnalysis();
                        }
                    });
                    
                    // Auto-select WA_Test_Dataset if available
                    if (waTestDataset) {
                        select.value = 'WA_Test_Dataset';
                        updateDatasetInfo();
                        setTimeout(() => performAnalysis(), 500);
                    }
                }
            } catch (error) {
                console.error('Error loading datasets:', error);
            }
        }
        
        // Update dataset information display
        function updateDatasetInfo() {
            const select = document.getElementById('expansionGroundTruthDataset');
            const details = document.getElementById('expansionDatasetDetails');
            
            if (select.value) {
                const option = select.selectedOptions[0];
                const count = option.dataset.count;
                details.innerHTML = `<span>${count} species</span>`;
            } else {
                details.innerHTML = '';
                document.getElementById('expansionVizContainer').style.display = 'none';
                document.getElementById('expansionLoadingState').style.display = 'block';
            }
        }
        
        // Load prediction data
        async function loadPredictionData(speciesFile) {
            if (!speciesFile) {
                return null;
            }
            
            try {
                const response = await fetch(`/api/phenotype_analysis_filtered?species_file=${encodeURIComponent(speciesFile)}`);
                const result = await response.json();
                
                if (!result.error && result.data) {
                    return result.data;
                }
                return null;
            } catch (error) {
                console.error('Error loading prediction data:', error);
                return null;
            }
        }
        
        // Perform analysis
        async function performAnalysis() {
            const select = document.getElementById('expansionGroundTruthDataset');
            const datasetName = select.value;
            
            if (!datasetName) {
                return;
            }
            
            const templateName = select.selectedOptions[0].dataset.template;
            
            // Determine species file
            let speciesFile = 'wa_with_gcount.txt';
            if (datasetName.includes('Artificial') || datasetName.includes('artificial')) {
                speciesFile = 'artificial.txt';
            }
            
            // Show loading
            const details = document.getElementById('expansionDatasetDetails');
            details.innerHTML = '<span><i class="fas fa-spinner fa-spin"></i> Loading data...</span>';
            
            try {
                // Load ground truth data
                const gtResp = await fetch(`/api/ground_truth/data?dataset=${datasetName}&per_page=10000`);
                const gtResult = await gtResp.json();
                
                if (!gtResult.success) {
                    throw new Error('Failed to load ground truth data');
                }
                
                groundTruthData = gtResult.data;
                
                // Load prediction data
                predictionData = await loadPredictionData(speciesFile);
                
                if (!predictionData) {
                    throw new Error('Failed to load prediction data');
                }
                
                // Update details
                const uniqueModels = [...new Set(predictionData.map(p => p.model))];
                const uniqueSpecies = [...new Set(predictionData.map(p => p.binomial_name))];
                details.innerHTML = `<span>${uniqueSpecies.length} species â€¢ ${uniqueModels.length} models</span>`;
                
                // Analyze and visualize
                analyzeExpansion();
                
                // Show visualization
                document.getElementById('expansionVizContainer').style.display = 'block';
                document.getElementById('expansionLoadingState').style.display = 'none';
                
            } catch (error) {
                console.error('Error analyzing data:', error);
                details.innerHTML = '<span style="color: #dc2626;">Failed to load data</span>';
            }
        }
        
        // Analyze dataset expansion
        function analyzeExpansion() {
            // Get phenotype fields (excluding some with low counts)
            const phenotypes = [
                'motility',
                'animal_pathogenicity', 
                'cell_shape',
                'extreme_environment_tolerance',
                'host_association',
                'spore_formation',
                'biosafety_level',
                'plant_pathogenicity',
                'gram_staining',
                'biofilm_formation'
            ];
            
            // Count annotations per phenotype
            const expansionData = [];
            
            phenotypes.forEach(phenotype => {
                // Count ground truth entries
                let gtCount = 0;
                groundTruthData.forEach(item => {
                    const value = normalizeValue(item[phenotype]);
                    if (value !== null && value !== '') {
                        gtCount++;
                    }
                });
                
                // Count LLM predictions (using first model for consistency)
                const firstModel = predictionData.length > 0 ? 
                    [...new Set(predictionData.map(p => p.model))][0] : null;
                
                let llmCount = 0;
                if (firstModel) {
                    const modelPredictions = predictionData.filter(p => p.model === firstModel);
                    
                    modelPredictions.forEach(pred => {
                        const value = normalizeValue(pred[phenotype]);
                        if (value !== null && value !== '') {
                            llmCount++;
                        }
                    });
                }
                
                expansionData.push({
                    phenotype: formatPhenotypeName(phenotype),
                    groundTruth: gtCount,
                    llmAdded: Math.max(0, llmCount - gtCount),
                    total: llmCount
                });
            });
            
            // Sort by total annotations
            expansionData.sort((a, b) => b.total - a.total);
            
            // Render chart
            renderExpansionChart(expansionData);
            
            // Update stats
            updateStats(expansionData);
        }
        
        // Render the expansion chart
        function renderExpansionChart(data) {
            const container = document.getElementById('expansionChart');
            container.innerHTML = '';
            
            // Dimensions
            const margin = { top: 20, right: 80, bottom: 60, left: 140 };
            const width = 700;
            const barHeight = 28;
            const barSpacing = 8;
            const height = (barHeight + barSpacing) * data.length + margin.top + margin.bottom;
            const chartWidth = width - margin.left - margin.right;
            
            // Create SVG
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', width);
            svg.setAttribute('height', height);
            svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
            container.appendChild(svg);
            
            // Add gradients
            const defs = document.createElementNS(svg.namespaceURI, 'defs');
            
            // Blue gradient for ground truth
            const blueGradient = document.createElementNS(svg.namespaceURI, 'linearGradient');
            blueGradient.setAttribute('id', 'expansionBlueGradient');
            blueGradient.setAttribute('x1', '0%');
            blueGradient.setAttribute('x2', '100%');
            
            const blueStop1 = document.createElementNS(svg.namespaceURI, 'stop');
            blueStop1.setAttribute('offset', '0%');
            blueStop1.setAttribute('stop-color', '#60a5fa');
            blueGradient.appendChild(blueStop1);
            
            const blueStop2 = document.createElementNS(svg.namespaceURI, 'stop');
            blueStop2.setAttribute('offset', '100%');
            blueStop2.setAttribute('stop-color', '#3b82f6');
            blueGradient.appendChild(blueStop2);
            
            // Red gradient for LLM added
            const redGradient = document.createElementNS(svg.namespaceURI, 'linearGradient');
            redGradient.setAttribute('id', 'expansionRedGradient');
            redGradient.setAttribute('x1', '0%');
            redGradient.setAttribute('x2', '100%');
            
            const redStop1 = document.createElementNS(svg.namespaceURI, 'stop');
            redStop1.setAttribute('offset', '0%');
            redStop1.setAttribute('stop-color', '#f87171');
            redGradient.appendChild(redStop1);
            
            const redStop2 = document.createElementNS(svg.namespaceURI, 'stop');
            redStop2.setAttribute('offset', '100%');
            redStop2.setAttribute('stop-color', '#ef4444');
            redGradient.appendChild(redStop2);
            
            defs.appendChild(blueGradient);
            defs.appendChild(redGradient);
            svg.appendChild(defs);
            
            // Scale
            const maxValue = Math.max(...data.map(d => d.total));
            const xScale = val => margin.left + (val / maxValue) * chartWidth;
            const yScale = idx => margin.top + idx * (barHeight + barSpacing) + barHeight / 2;
            
            // Draw grid lines
            for (let v = 0; v <= maxValue; v += Math.ceil(maxValue / 5)) {
                const x = xScale(v);
                const line = document.createElementNS(svg.namespaceURI, 'line');
                line.setAttribute('x1', x);
                line.setAttribute('x2', x);
                line.setAttribute('y1', margin.top - 10);
                line.setAttribute('y2', height - margin.bottom);
                line.setAttribute('stroke', '#e2e8f0');
                line.setAttribute('stroke-width', '0.5');
                svg.appendChild(line);
                
                // Grid label
                const label = document.createElementNS(svg.namespaceURI, 'text');
                label.setAttribute('x', x);
                label.setAttribute('y', height - margin.bottom + 20);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('font-size', '11');
                label.setAttribute('fill', '#94a3b8');
                label.textContent = v;
                svg.appendChild(label);
            }
            
            // Draw bars
            data.forEach((item, idx) => {
                const y = yScale(idx);
                
                // Phenotype label
                const label = document.createElementNS(svg.namespaceURI, 'text');
                label.setAttribute('x', margin.left - 10);
                label.setAttribute('y', y);
                label.setAttribute('text-anchor', 'end');
                label.setAttribute('dominant-baseline', 'middle');
                label.setAttribute('font-size', '12');
                label.setAttribute('font-weight', '500');
                label.setAttribute('fill', '#4a5568');
                label.textContent = item.phenotype;
                svg.appendChild(label);
                
                // Ground truth bar (blue)
                if (item.groundTruth > 0) {
                    const gtBar = document.createElementNS(svg.namespaceURI, 'rect');
                    gtBar.setAttribute('x', margin.left);
                    gtBar.setAttribute('y', y - barHeight/2);
                    gtBar.setAttribute('width', xScale(item.groundTruth) - margin.left);
                    gtBar.setAttribute('height', barHeight);
                    gtBar.setAttribute('rx', 4);
                    gtBar.setAttribute('fill', 'url(#expansionBlueGradient)');
                    
                    const tooltipText = `${item.phenotype}\nGround Truth: ${item.groundTruth} annotations`;
                    gtBar.innerHTML = `<title>${tooltipText}</title>`;
                    svg.appendChild(gtBar);
                }
                
                // LLM added bar (red, stacked)
                if (item.llmAdded > 0) {
                    const llmBar = document.createElementNS(svg.namespaceURI, 'rect');
                    llmBar.setAttribute('x', xScale(item.groundTruth));
                    llmBar.setAttribute('y', y - barHeight/2);
                    llmBar.setAttribute('width', xScale(item.llmAdded) - margin.left);
                    llmBar.setAttribute('height', barHeight);
                    llmBar.setAttribute('rx', 4);
                    llmBar.setAttribute('fill', 'url(#expansionRedGradient)');
                    
                    const tooltipText = `${item.phenotype}\nLLM Added: ${item.llmAdded} new annotations`;
                    llmBar.innerHTML = `<title>${tooltipText}</title>`;
                    svg.appendChild(llmBar);
                }
                
                // Total count label
                if (item.total > 0) {
                    const totalLabel = document.createElementNS(svg.namespaceURI, 'text');
                    totalLabel.setAttribute('x', xScale(item.total) + 8);
                    totalLabel.setAttribute('y', y);
                    totalLabel.setAttribute('dominant-baseline', 'middle');
                    totalLabel.setAttribute('font-size', '11');
                    totalLabel.setAttribute('font-weight', '600');
                    totalLabel.setAttribute('fill', '#2d3748');
                    totalLabel.textContent = item.total;
                    svg.appendChild(totalLabel);
                }
            });
            
            // X-axis label
            const xLabel = document.createElementNS(svg.namespaceURI, 'text');
            xLabel.setAttribute('x', margin.left + chartWidth / 2);
            xLabel.setAttribute('y', height - 10);
            xLabel.setAttribute('text-anchor', 'middle');
            xLabel.setAttribute('font-size', '13');
            xLabel.setAttribute('font-weight', '600');
            xLabel.setAttribute('fill', '#4a5568');
            xLabel.textContent = 'Number of Annotations';
            svg.appendChild(xLabel);
        }
        
        // Update statistics
        function updateStats(data) {
            const totalGT = data.reduce((sum, d) => sum + d.groundTruth, 0);
            const totalLLM = data.reduce((sum, d) => sum + d.llmAdded, 0);
            const totalAnnotations = data.reduce((sum, d) => sum + d.total, 0);
            
            const expansionRate = totalGT > 0 ? ((totalLLM / totalGT) * 100).toFixed(1) : 0;
            
            const statsContainer = document.getElementById('expansionStats');
            statsContainer.innerHTML = `
                <div class="stat-card">
                    <div class="stat-value">${totalGT.toLocaleString()}</div>
                    <div class="stat-label">Ground Truth</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${totalLLM.toLocaleString()}</div>
                    <div class="stat-label">LLM Added</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value">${expansionRate}%</div>
                    <div class="stat-label">Expansion Rate</div>
                </div>
            `;
        }
        
        // Helper function to normalize values
        function normalizeValue(value) {
            if (value === null || value === undefined || value === '') {
                return null;
            }
            
            const strValue = String(value).trim().toLowerCase();
            const missingTokens = ['n/a', 'na', 'null', 'none', 'nan', 'undefined', '-', 'unknown', 'missing'];
            
            if (missingTokens.includes(strValue)) {
                return null;
            }
            
            return strValue;
        }
        
        // Format phenotype name
        function formatPhenotypeName(phenotype) {
            return phenotype
                .replace(/_/g, ' ')
                .replace('extreme environment tolerance', 'Extreme env. tol.')
                .replace('animal pathogenicity', 'Animal path.')
                .replace('plant pathogenicity', 'Plant pathogenicity')
                .replace('host association', 'Host association')
                .replace('spore formation', 'Spore formation')
                .replace('biosafety level', 'Biosafety level')
                .replace('gram staining', 'Gram staining')
                .replace('biofilm formation', 'Biofilm formation')
                .split(' ')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');
        }
        
        // Initialize on DOM ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initExpansion);
        } else {
            initExpansion();
        }
    })();
    </script>
</div>