<section class="section-callout section-callout--purple">
    <div class="section-callout__content">
        <div class="section-callout__header">
            <h3 class="section-callout__title">Full Results: Model Performance Analysis</h3>
            <p class="section-callout__text">Comprehensive analysis of all tested models, showing their quality scores and knowledge distribution patterns across different query templates.</p>
        </div>
        
        <div id="knowledgeAnalysisContent" class="knowledge-analysis-content-container">
            <div class="loading-container">
                <div class="loading-progress">
                    <div class="loading-progress-bar"></div>
                </div>
                <div class="loading-text">Loading knowledge analysis data...</div>
            </div>
        </div>
    </div>
</section>

<style>
/* Clean, plain table styling */
.hidden-row {
    display: none;
}

/* Loading animation styles */
.loading-container {
    text-align: center;
    padding: 40px 20px;
}

.loading-progress {
    width: 200px;
    height: 4px;
    background: #f3f4f6;
    border-radius: 2px;
    margin: 0 auto 16px;
    overflow: hidden;
}

.loading-progress-bar {
    height: 100%;
    background: #7c3aed;
    width: 30%;
    border-radius: 2px;
    animation: loading 1.5s ease-in-out infinite;
}

@keyframes loading {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(400%); }
}

.loading-text {
    color: #6b7280;
    font-size: 14px;
}

/* Bar chart styles */
.bar-chart-container {
    background: transparent;
    border-radius: 6px;
    overflow: hidden;
    border: 1px solid #f3f4f6;
}

.bar-chart-segments {
    display: flex;
    height: 24px;
    width: 100%;
    font-size: 11px;
    font-weight: 500;
    color: white;
}

.bar-segment {
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    cursor: pointer;
    transition: opacity 0.2s;
}

.bar-segment:hover {
    opacity: 0.9;
}

.bar-segment.na {
    background: linear-gradient(135deg, #e2e3e5 0%, #d6d8db 100%);
    color: #6b7280;
}

.bar-segment.limited {
    background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
    color: #806520;
}

.bar-segment.moderate {
    background: linear-gradient(135deg, #d1ecf1 0%, #bee5eb 100%);
    color: #0c5460;
}

.bar-segment.extensive {
    background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
    color: #155724;
}

.bar-segment.failed {
    background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
    color: #721c24;
}

.bar-number {
    font-size: 10px;
    display: none;
}

.bar-segment.show-number .bar-number {
    display: inline;
}
</style>

<script>
// Self-contained script for knowledge analysis content
(function() {
    console.log('[KnowledgeAnalysis] Script starting...');
    
    // Initialize when DOM is ready
    function init() {
        console.log('[KnowledgeAnalysis] Initializing...');
        initializeKnowledgeAnalysis();
    }
    
    // Check if DOM is already loaded
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        // DOM is already ready, run init with a small delay
        setTimeout(init, 100);
    }
    
    // Function to find container with fallback
    function findContainer() {
        // Try direct ID first
        let container = document.getElementById('knowledgeAnalysisContent');
        if (container) {
            console.log('[KnowledgeAnalysis] Found container by ID');
            return container;
        }
        
        // Try class name
        container = document.querySelector('.knowledge-analysis-content-container');
        if (container) {
            console.log('[KnowledgeAnalysis] Found container by class');
            return container;
        }
        
        // For component viewer - find within section-callout
        const sectionCallout = document.querySelector('.section-callout__content');
        if (sectionCallout) {
            container = sectionCallout.querySelector('#knowledgeAnalysisContent') || 
                       sectionCallout.querySelector('.knowledge-analysis-content-container');
            if (container) {
                console.log('[KnowledgeAnalysis] Found container in section-callout');
                return container;
            }
        }
        
        console.error('[KnowledgeAnalysis] Container not found!');
        return null;
    }
    
    // Transform API data to expected format
    function transformKnowledgeData(knowledgeAnalysis) {
        console.log('[KnowledgeAnalysis] Transforming data...');
        const modelData = {};
        const templateSet = new Set();
        const inputTypeSet = new Set();
        
        // Process only files with type columns
        // The data structure is: file -> types -> inputType -> template -> model -> stats
        // We need to transform it to: model -> template -> inputType -> stats
        
        Object.entries(knowledgeAnalysis).forEach(([fileName, fileData]) => {
            console.log('[KnowledgeAnalysis] Processing file:', fileName);
            
            // Only process files that have type columns
            if (!fileData.has_type_column || !fileData.types) {
                console.warn('[KnowledgeAnalysis] Skipping file (no type column):', fileName);
                return;
            }
            
            // Process each input type
            Object.entries(fileData.types).forEach(([inputType, templateData]) => {
                inputTypeSet.add(inputType);
                
                // Process each template
                Object.entries(templateData).forEach(([templateName, models]) => {
                    templateSet.add(templateName);
                    
                    // Process each model
                    Object.entries(models).forEach(([modelName, stats]) => {
                        // Initialize model data structure if needed
                        if (!modelData[modelName]) {
                            modelData[modelName] = {};
                        }
                        if (!modelData[modelName][templateName]) {
                            modelData[modelName][templateName] = {};
                        }
                        
                        // Store the stats
                        modelData[modelName][templateName][inputType] = stats;
                    });
                });
            });
        });
        
        const result = {
            modelData: modelData,
            templateArray: Array.from(templateSet).sort(),
            inputTypeArray: Array.from(inputTypeSet).sort()
        };
        
        console.log('[KnowledgeAnalysis] Transformed data:', {
            models: Object.keys(modelData).length,
            templates: result.templateArray.length,
            inputTypes: result.inputTypeArray.length,
            firstModel: Object.keys(modelData)[0]
        });
        
        return result;
    }
    
    // Initialize function
    function initializeKnowledgeAnalysis() {
        console.log('[KnowledgeAnalysis] Initializing component...');
        loadKnowledgeAnalysisData();
    }
    
    // Function to render knowledge analysis tables
    function renderKnowledgeAnalysis(data) {
        const container = findContainer();
        if (!container) {
            console.error('[KnowledgeAnalysis] Cannot render - no container found');
            return;
        }
        
        container.innerHTML = '';
        
        // Extract model data and templates
        const { modelData, templateArray, inputTypeArray } = data;
        
        // Calculate overall model scores
        const overallModelScores = calculateOverallModelScores(modelData, templateArray);
        const sortedModels = Object.entries(overallModelScores)
            .map(([modelName, scores]) => ({ modelName, ...scores }))
            .sort((a, b) => b.averageQualityScore - a.averageQualityScore);
        
        // Create overview section
        let html = `
        <div class="knowledge-analysis-overview">
            <h3 class="section-title" style="font-size: 24px; margin-bottom: 12px;">Model Performance Overview</h3>
            <p class="article-text" style="margin-bottom: 20px;">Summary of all ${sortedModels.length} models tested across ${templateArray.length} query templates, showing their ability to correctly identify fictional bacterial species.</p>
            
            <div class="summary-stats" style="display: flex; gap: 48px; margin-bottom: 24px;">
                <div style="text-align: center;">
                    <div style="font-size: 48px; font-weight: 700; color: #7c3aed; line-height: 1;">${sortedModels.length}</div>
                    <div style="font-size: 14px; color: var(--gray-600); margin-top: 8px;">Models Tested</div>
                </div>
                <div style="text-align: center;">
                    <div style="font-size: 48px; font-weight: 700; color: #7c3aed; line-height: 1;">${templateArray.length}</div>
                    <div style="font-size: 14px; color: var(--gray-600); margin-top: 8px;">Query Templates</div>
                </div>
                <div style="text-align: center;">
                    <div style="font-size: 48px; font-weight: 700; color: #7c3aed; line-height: 1;">${inputTypeArray.length}</div>
                    <div style="font-size: 14px; color: var(--gray-600); margin-top: 8px;">Input Types</div>
                </div>
            </div>
        `;
        
        // Add model ranking table
        html += `
            <div class="model-ranking-table" style="margin-top: 32px;">
                <h4 style="font-size: 18px; margin-bottom: 20px; font-weight: 600;">Complete Model Ranking</h4>
                <div class="table-wrapper" style="background: transparent;">
                    <table class="ranking-table" style="width: 100%; border-collapse: collapse; background: transparent;">
                        <thead>
                            <tr style="border-bottom: 1px solid #f3f4f6;">
                                <th style="width: 60px; padding: 12px 8px; text-align: left; font-weight: 500; color: #9ca3af; font-size: 13px;">RANK</th>
                                <th style="padding: 12px 8px; text-align: left; font-weight: 500; color: #9ca3af; font-size: 13px;">MODEL</th>
                                <th style="padding: 12px 8px; text-align: center; font-weight: 500; color: #9ca3af; font-size: 13px;">QUALITY SCORE</th>
                                <th style="padding: 12px 8px; text-align: center; font-weight: 500; color: #9ca3af; font-size: 13px;">SAMPLES</th>
                                <th style="padding: 12px 8px; text-align: left; font-weight: 500; color: #9ca3af; font-size: 13px;">KNOWLEDGE DISTRIBUTION</th>
                            </tr>
                        </thead>
                        <tbody>
        `;
        
        // Show top 10 models initially
        const displayCount = Math.min(10, sortedModels.length);
        sortedModels.slice(0, displayCount).forEach((model, index) => {
            const displayName = model.modelName.split('/').pop();
            html += `
                <tr style="border-bottom: 1px solid #f3f4f6;">
                    <td style="padding: 16px 8px; text-align: center; font-weight: 600; color: #9ca3af;">${index + 1}</td>
                    <td style="padding: 16px 8px; font-weight: 500; color: #111827;">${displayName}</td>
                    <td style="padding: 16px 8px; text-align: center;">
                        <span style="font-weight: 600; color: #7c3aed; font-size: 16px;">${model.averageQualityScore.toFixed(2)}</span>
                    </td>
                    <td style="padding: 16px 8px; text-align: center; color: #6b7280;">${model.totalSamples}</td>
                    <td style="padding: 16px 8px;">${createKnowledgeBarChart(model.distribution)}</td>
                </tr>
            `;
        });
        
        html += `
                        </tbody>
                    </table>
                </div>
        `;
        
        if (sortedModels.length > displayCount) {
            html += `
                <div style="text-align: center; margin-top: 16px;">
                    <p style="font-size: 14px; color: var(--gray-600);">
                        Showing top ${displayCount} of ${sortedModels.length} models. 
                        View individual template results below for complete analysis.
                    </p>
                </div>
            `;
        }
        
        html += `
            </div>
        </div>
        `;
        
        // Add the template analysis tables with spacing
        html += '<div style="margin-top: 48px;">';
        html += renderTemplateAnalysisTables(templateArray, inputTypeArray, modelData);
        html += '</div>';
        
        container.innerHTML = html;
    }
    
    // Render template analysis tables
    function renderTemplateAnalysisTables(templateArray, inputTypeArray, modelData) {
        let html = '';
        
        // Template descriptions
        const templateDescriptions = {
            'template1_knowlege': 'Basic knowledge level assessment template (limited, moderate, extensive)',
            'template2_knowlege': 'Knowledge level assessment template with NA support', 
            'template3_knowlege': 'Alternative knowledge level assessment template with NA support'
        };
        
        // Create compact table layout for each template
        templateArray.forEach((templateName, templateIndex) => {
            // Section header with title and description
            html += `<div class="template-section-header" style="margin-top: 48px; margin-bottom: 24px;">`;
            html += `<h3 style="font-size: 24px; font-weight: 600; margin-bottom: 8px;">${templateName}</h3>`;
            html += `<p style="font-size: 16px; color: #6b7280; line-height: 1.6;">${templateDescriptions[templateName] || 'Template for model evaluation'}. The bar charts below show response distributions for each model across the artificial species categories.</p>`;
            html += `</div>`;
            
            html += createBarChartLegend();
            
            html += `<div class="table-fade" id="table-fade-${templateIndex}" style="margin-top: 16px;">`;
            html += `<div style="overflow-x: auto;">`;
            html += `<table style="width: 100%; border-collapse: collapse; background: transparent;">`;
            
            // Header row
            html += `<thead><tr>`;
            html += `<th>Model</th>`;
            inputTypeArray.forEach(inputType => {
                const displayType = formatTypeName(inputType);
                html += `<th>${displayType}</th>`;
            });
            html += `<th style="text-align: center; width: 120px;">Quality Score</th>`;
            html += `</tr></thead>`;
            
            // Data rows
            html += `<tbody>`;
            
            // Calculate metrics for sorting
            const modelScores = Object.entries(modelData)
                .filter(([modelName, templates]) => templates[templateName])
                .map(([modelName, templates]) => {
                    let totalQualityScore = 0;
                    let totalSamples = 0;
                    
                    inputTypeArray.forEach(inputType => {
                        const data = templates[templateName][inputType];
                        if (data) {
                            const naFailedCount = (data.NA || 0) + (data.no_result || 0) + (data.inference_failed || 0);
                            const limitedCount = data.limited || 0;
                            const moderateCount = data.moderate || 0;
                            const extensiveCount = data.extensive || 0;
                            
                            totalQualityScore += (naFailedCount * 3) + (limitedCount * 2) + (moderateCount * 1) + (extensiveCount * 0);
                            totalSamples += data.total || 0;
                        }
                    });
                    
                    return {
                        modelName,
                        templates: templates[templateName],
                        qualityScore: totalQualityScore,
                        totalSamples,
                        averageQualityScore: totalSamples > 0 ? totalQualityScore / totalSamples : 0
                    };
                })
                .sort((a, b) => {
                    // Sort by quality score (higher is better)
                    if (b.averageQualityScore !== a.averageQualityScore) {
                        return b.averageQualityScore - a.averageQualityScore;
                    }
                    // Secondary: by total quality score
                    if (b.qualityScore !== a.qualityScore) {
                        return b.qualityScore - a.qualityScore;
                    }
                    // Final fallback: alphabetical by model name
                    return a.modelName.localeCompare(b.modelName);
                });
            
            modelScores.forEach(({modelName, templates, averageQualityScore, qualityScore, totalSamples}, index) => {
                const isHidden = index >= 3;
                html += `<tr class="${isHidden ? 'hidden-row' : ''}">`;
                html += `<td class="model-name-cell">${modelName.split('/').pop()}</td>`;
                
                inputTypeArray.forEach(inputType => {
                    html += `<td class="chart-cell">`;
                    if (templates[inputType]) {
                        html += createDetailedKnowledgeBarChart(templates[inputType]);
                    } else {
                        html += '<div class="no-data">No data</div>';
                    }
                    html += `</td>`;
                });
                
                // Add quality score column
                html += `<td class="quality-score-cell">`;
                if (totalSamples > 0) {
                    html += `<span class="quality-score-value">${averageQualityScore.toFixed(2)}</span>`;
                } else {
                    html += '<span style="color: #6c757d; font-style: italic; font-size: 11px;">No data</span>';
                }
                html += `</td>`;
                
                html += `</tr>`;
            });
            html += `</tbody></table>`;
            html += `</div>`;
            
            // Add expand/collapse button if there are more than 3 models
            if (modelScores.length > 3) {
                html += `<div class="table-controls">`;
                html += `<button class="expand-button" onclick="toggleTableExpansion(this, ${templateIndex})">`;
                html += `<span>Show ${modelScores.length - 3} more models</span>`;
                html += `<svg class="expand-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">`;
                html += `<path d="M6 9l6 6 6-6"/>`;
                html += `</svg>`;
                html += `</button>`;
                html += `</div>`;
            }
            
            html += `</div>`;
        });
        
        return html;
    }
    
    // Create bar chart legend
    function createBarChartLegend() {
        return `
            <div class="legend" style="margin-bottom: 16px;">
                <div style="display: flex; align-items: center; gap: 8px; font-size: 13px; color: var(--gray-700);" title="Model can provide in-depth, reference-level information.">
                    <div style="width: 14px; height: 14px; border-radius: 4px; border: 1px solid rgba(0,0,0,0.1); background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);"></div>
                    <span>Extensive</span>
                </div>
                <div style="display: flex; align-items: center; gap: 8px; font-size: 13px; color: var(--gray-700);" title="Model can give several specific details.">
                    <div style="width: 14px; height: 14px; border-radius: 4px; border: 1px solid rgba(0,0,0,0.1); background: linear-gradient(135deg, #d1ecf1 0%, #bee5eb 100%);"></div>
                    <span>Moderate</span>
                </div>
                <div style="display: flex; align-items: center; gap: 8px; font-size: 13px; color: var(--gray-700);" title="Model knows only basic facts or context.">
                    <div style="width: 14px; height: 14px; border-radius: 4px; border: 1px solid rgba(0,0,0,0.1); background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);"></div>
                    <span>Limited</span>
                </div>
                <div style="display: flex; align-items: center; gap: 8px; font-size: 13px; color: var(--gray-700);" title="Model doesn't know or no information available.">
                    <div style="width: 14px; height: 14px; border-radius: 4px; border: 1px solid rgba(0,0,0,0.1); background: linear-gradient(135deg, #e2e3e5 0%, #d6d8db 100%);"></div>
                    <span>NA</span>
                </div>
                <div style="display: flex; align-items: center; gap: 8px; font-size: 13px; color: var(--gray-700);" title="Model failed to generate a response or the response was not valid.">
                    <div style="width: 14px; height: 14px; border-radius: 4px; border: 1px solid rgba(0,0,0,0.1); background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);"></div>
                    <span>Failed</span>
                </div>
            </div>
        `;
    }
    
    // Create detailed knowledge bar chart (different from the simple one)
    function createDetailedKnowledgeBarChart(data) {
        const total = data.total || 0;
        if (total === 0) {
            return '<div class="no-data">No data</div>';
        }
        
        // Calculate percentages
        const segments = [
            { type: 'na', count: data.NA || 0, class: 'na' },
            { type: 'limited', count: data.limited || 0, class: 'limited' },
            { type: 'moderate', count: data.moderate || 0, class: 'moderate' },
            { type: 'extensive', count: data.extensive || 0, class: 'extensive' },
            { type: 'failed', count: (data.no_result || 0) + (data.inference_failed || 0), class: 'failed' }
        ].filter(seg => seg.count > 0);
        
        let html = '<div class="bar-chart-container">';
        html += '<div class="bar-chart-segments">';
        
        segments.forEach(seg => {
            const percentage = (seg.count / total * 100).toFixed(1);
            const showNumber = seg.count >= 5 || percentage >= 10;
            
            html += `<div class="bar-segment ${seg.class} ${showNumber ? 'show-number' : ''}" 
                        style="width: ${percentage}%"
                        data-count="${seg.count}"
                        data-type="${seg.type}"
                        data-total="${total}"
                        onmouseover="showBarTooltip(event, this)"
                        onmouseout="hideBarTooltip()">`;
            html += `<span class="bar-number">${seg.count}</span>`;
            html += '</div>';
        });
        
        html += '</div>';
        html += '</div>';
        
        return html;
    }
    
    // Format type name
    function formatTypeName(typeName) {
        // Format type names for display
        const typeDescriptions = {
            'random_words': 'Random Words',
            'latin_random_words': 'Fictional Latin',
            'real_genus_latin_strain': 'Real Genus + Fake Species',
            'latin_genus_real_strain': 'Fake Genus + Real Species'
        };
        return typeDescriptions[typeName] || typeName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
    }
    
    // Calculate overall model scores
    function calculateOverallModelScores(modelData, templateArray) {
        const overallModelScores = {};
        Object.entries(modelData).forEach(([modelName, templates]) => {
            let totalScore = 0;
            let totalSamples = 0;
            let dist = { NA: 0, limited: 0, moderate: 0, extensive: 0, no_result: 0, inference_failed: 0, total: 0 };

            templateArray.forEach(templateName => {
                if (templates[templateName]) {
                    const templateData = templates[templateName];
                    Object.values(templateData).forEach(stats => {
                        const naFailedCount = (stats.NA || 0) + (stats.no_result || 0) + (stats.inference_failed || 0);
                        const limitedCount = stats.limited || 0;
                        const moderateCount = stats.moderate || 0;
                        const extensiveCount = stats.extensive || 0;
                        totalScore += (naFailedCount * 3) + (limitedCount * 2) + (moderateCount * 1) + (extensiveCount * 0);
                        totalSamples += stats.total || 0;

                        dist.NA += stats.NA || 0;
                        dist.limited += stats.limited || 0;
                        dist.moderate += stats.moderate || 0;
                        dist.extensive += stats.extensive || 0;
                        dist.no_result += stats.no_result || 0;
                        dist.inference_failed += stats.inference_failed || 0;
                        dist.total += stats.total || 0;
                    });
                }
            });
            if (totalSamples > 0) {
                overallModelScores[modelName] = {
                    averageQualityScore: totalScore / totalSamples,
                    totalSamples: totalSamples,
                    distribution: dist
                };
            }
        });
        return overallModelScores;
    }
    
    // Create knowledge bar chart
    function createKnowledgeBarChart(dist) {
        if (!dist || dist.total === 0) return '<div class="no-data">No data</div>';
        
        const segments = [
            { type: 'NA', count: (dist.NA || 0) + (dist.no_result || 0) + (dist.inference_failed || 0), class: 'na' },
            { type: 'limited', count: dist.limited || 0, class: 'limited' },
            { type: 'moderate', count: dist.moderate || 0, class: 'moderate' },
            { type: 'extensive', count: dist.extensive || 0, class: 'extensive' }
        ].filter(seg => seg.count > 0);
        
        let html = '<div class="bar-chart-container"><div class="bar-chart-segments">';
        segments.forEach(seg => {
            const pct = (seg.count / dist.total * 100).toFixed(1);
            html += `<div class="bar-segment ${seg.class}" style="width:${pct}%">${pct > 10 ? seg.count : ''}</div>`;
        });
        html += '</div></div>';
        return html;
    }
    
    // Load knowledge analysis data
    async function loadKnowledgeAnalysisData() {
        console.log('[KnowledgeAnalysis] Loading data...');
        const container = findContainer();
        if (!container) {
            console.error('[KnowledgeAnalysis] Cannot load - no container found');
            return;
        }
        
        try {
            console.log('[KnowledgeAnalysis] Fetching from /api/knowledge_analysis_data...');
            const response = await fetch('/api/knowledge_analysis_data');
            console.log('[KnowledgeAnalysis] Response status:', response.status);
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            console.log('[KnowledgeAnalysis] Raw data received:', data);
            
            if (data.knowledge_analysis) {
                // Transform the data to expected format
                const transformedData = transformKnowledgeData(data.knowledge_analysis);
                
                // Store data globally for other functions
                window.knowledgeData = transformedData;
                
                // Render the data
                renderKnowledgeAnalysis(transformedData);
            } else {
                console.error('[KnowledgeAnalysis] No knowledge_analysis in response');
                container.innerHTML = '<div class="error-message">No knowledge analysis data available</div>';
            }
        } catch (error) {
            console.error('[KnowledgeAnalysis] Failed to load data:', error);
            container.innerHTML = '<div class="error-message">Failed to load data. Please try again later.</div>';
        }
    }
    
})();

// Global functions for table interactions
function toggleTableExpansion(button, tableIndex) {
    const tableFade = document.getElementById(`table-fade-${tableIndex}`);
    const hiddenRows = tableFade.querySelectorAll('.hidden-row');
    const isExpanded = button.dataset.expanded === 'true';
    
    hiddenRows.forEach(row => {
        row.style.display = isExpanded ? 'none' : 'table-row';
    });
    
    button.dataset.expanded = !isExpanded;
    const span = button.querySelector('span');
    const svg = button.querySelector('svg');
    if (isExpanded) {
        span.textContent = `Show ${hiddenRows.length} more models`;
        svg.style.transform = 'rotate(0deg)';
    } else {
        span.textContent = 'Show less';
        svg.style.transform = 'rotate(180deg)';
    }
}

// Tooltip functions
let tooltipElement = null;

function showBarTooltip(event, element) {
    // Remove any existing tooltip
    hideBarTooltip();
    
    const count = element.getAttribute('data-count');
    const type = element.getAttribute('data-type');
    const total = element.getAttribute('data-total');
    const percentage = ((count / total) * 100).toFixed(1);
    
    const typeLabels = {
        'na': 'NA',
        'limited': 'Limited',
        'moderate': 'Moderate',
        'extensive': 'Extensive',
        'failed': 'Failed'
    };
    
    // Create tooltip
    tooltipElement = document.createElement('div');
    tooltipElement.className = 'tooltip';
    tooltipElement.innerHTML = `
        <strong>${typeLabels[type] || type}</strong><br>
        ${count} responses (${percentage}%)
    `;
    
    // Style the tooltip
    tooltipElement.style.cssText = `
        position: absolute;
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 12px;
        white-space: nowrap;
        z-index: 1000;
        pointer-events: none;
    `;
    
    document.body.appendChild(tooltipElement);
    
    // Position tooltip
    const rect = element.getBoundingClientRect();
    const tooltipRect = tooltipElement.getBoundingClientRect();
    
    tooltipElement.style.left = `${rect.left + rect.width / 2 - tooltipRect.width / 2}px`;
    tooltipElement.style.top = `${rect.top - tooltipRect.height - 8}px`;
}

function hideBarTooltip() {
    if (tooltipElement) {
        tooltipElement.remove();
        tooltipElement = null;
    }
}
</script>