{% extends "base.html" %}

{% block title %}Hallucination Test - LLM-BioEval{% endblock %}

{% block extra_head %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/article_styles.css') }}">
<style>
    /* Remove main content padding override - let layout.css handle it */

    /* Hero Header Section - Using layout system */
    .hero-header {
        /* Remove custom positioning, use layout.css defaults */
        position: relative;
        overflow: hidden;
    }

    /* Header animation canvas */
    .hero-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        opacity: 0.15;
        z-index: 1;
    }

    /* Color transition overlay */
    .hero-header::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(135deg, 
            rgba(99, 102, 241, 0.1) 0%,
            rgba(168, 85, 247, 0.08) 25%,
            rgba(59, 130, 246, 0.1) 50%,
            rgba(147, 51, 234, 0.08) 75%,
            rgba(79, 172, 254, 0.1) 100%);
        z-index: 2;
        animation: colorShift 15s ease-in-out infinite;
    }

    @keyframes colorShift {
        0%, 100% { 
            background: linear-gradient(135deg, 
                rgba(99, 102, 241, 0.1) 0%,
                rgba(168, 85, 247, 0.08) 25%,
                rgba(59, 130, 246, 0.1) 50%,
                rgba(147, 51, 234, 0.08) 75%,
                rgba(79, 172, 254, 0.1) 100%);
        }
        50% { 
            background: linear-gradient(135deg, 
                rgba(147, 51, 234, 0.12) 0%,
                rgba(79, 172, 254, 0.1) 25%,
                rgba(99, 102, 241, 0.08) 50%,
                rgba(168, 85, 247, 0.1) 75%,
                rgba(59, 130, 246, 0.12) 100%);
        }
    }

    /* Hero content uses layout system alignment */
    .hero-content {
        position: relative;
        z-index: 3;
        text-align: left;
        color: var(--gray-900);
    }

    .hero-title {
        font-size: 48px;
        font-weight: 800;
        line-height: 1.1;
        margin-bottom: var(--spacing-element);
        letter-spacing: -0.02em;
        color: var(--gray-900);
    }

    /* Hero author styling moved to article_styles.css - using .hero-author--purple */

    .hero-subtitle {
        font-size: 20px;
        font-weight: 400;
        line-height: 1.6;
        color: var(--gray-600);
        max-width: 700px;
        margin: 0;
    }

    /* Article layout already handled by layout.css */
    
    /* Background animation canvas */
    .background-canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 300px;
        height: 100%;
        pointer-events: none;
        opacity: 0.03;
        z-index: 0;
    }
    
    /* Article section styling moved to article_styles.css */
    
    /* Title and text styles moved to article_styles.css */

    /* Ensure article-text inside section-full uses full width */
    .section-full .article-text {
        max-width: none;
        width: 100%;
    }

    .section-full .article-text p {
        max-width: none;
    }

    /* Experimental Flow section uses section-callout--purple from article_styles.css */

    /* Wide sections use section-wide from article_styles.css */
    
    .flow-diagram-wrapper {
        max-width: var(--container-standard);
        margin: 0 auto;
        padding: 0 var(--padding-container);
    }

    @media (max-width: 768px) {
        .flow-diagram-wrapper {
            padding: 0 20px;
        }
    }
    
    .flow-diagram {
        display: flex;
        align-items: center;
        justify-content: flex-start;
        gap: calc(var(--spacing-element) * 0.833);
        flex-wrap: wrap;
        margin-bottom: var(--spacing-element);
    }
    
    /* correlation special layout */
    .corr-legacy { display: none !important; }
    .flow-result-box { background: #FAFAFA; border: 1px solid var(--gray-200); border-radius: 12px; padding: var(--spacing-small); min-width: 120px; text-align: center; box-shadow: 0 2px 6px rgba(0,0,0,0.05);}    
    /* Grid for correlation demo */
    .flow-grid { display: grid; grid-template-columns: auto 60px auto 60px auto 60px auto; grid-template-rows: auto auto; align-items: center; gap: calc(var(--spacing-element) * 0.833); }
    .grid-species { grid-row: 1 / span 2; grid-column: 1; }
    .grid-correlation { grid-row: 1 / span 2; grid-column: 7; }
    
    /* Column wrapper to stack boxes */
    .flow-column {
        display: flex;
        flex-direction: column;
        gap: calc(var(--spacing-element) * 0.833);
    }
    
    .flow-box {
        background: #FAFAFA;
        border: 1px solid var(--gray-200);
        border-radius: 12px;
        padding: var(--spacing-element);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
        transition: all 0.3s ease;
        flex-shrink: 0;
    }
    
    .flow-box:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }
    
    /* Input Box */
    .flow-input {
        text-align: center;
        min-width: 240px;
    }
    
    .flow-species {
        font-size: 20px;
        font-style: italic;
        font-weight: 300;
        color: #7c3aed;
        margin-bottom: calc(var(--spacing-small) / 2);
    }
    
    .flow-label {
        font-size: 13px;
        color: var(--gray-600);
    }
    
    /* Query Box */
    .flow-query {
        min-width: 260px;
    }
    
    .query-title {
        font-size: 16px;
        font-weight: 600;
        color: var(--gray-900);
        margin-bottom: var(--spacing-small);
        text-align: center;
    }
    
    .query-templates {
        display: flex;
        flex-direction: column;
        gap: calc(var(--spacing-small) / 2);
    }
    
    .query-template {
        display: flex;
        align-items: center;
        gap: calc(var(--spacing-small) * 0.625);
        font-size: 13px;
        color: var(--gray-600);
        padding: calc(var(--spacing-small) / 4) calc(var(--spacing-small) / 2);
        border-radius: 6px;
        transition: all 0.3s ease;
        cursor: pointer;
    }
    
    .query-template:hover {
        background: var(--gray-50);
    }
    
    .query-template.active {
        background: rgba(99, 102, 241, 0.1);
        color: var(--primary);
    }
    
    .template-number {
        width: 28px;
        height: 20px;
        background: var(--gray-100);
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 600;
        font-size: 11px;
        color: var(--gray-700);
        transition: all 0.3s ease;
    }
    
    .query-template.active .template-number {
        background: var(--primary);
        color: white;
    }
    
    .template-type {
        font-size: 12px;
    }
    
    /* Output Box */
    .flow-output {
        min-width: 280px;
    }
    
    .output-title {
        font-size: 16px;
        font-weight: 600;
        color: var(--gray-900);
        margin-bottom: var(--spacing-small);
        text-align: center;
    }
    
    .output-options {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
        gap: calc(var(--spacing-small) / 2);
        justify-content: center;
        max-width: 400px;
        position: relative;
    }
    
    .output-option {
        padding: calc(var(--spacing-small) * 0.375) calc(var(--spacing-small) * 0.75);
        border-radius: 6px;
        font-size: 13px;
        font-weight: 500;
        position: relative;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        border: 1px solid transparent;
        min-height: 32px;
        gap: calc(var(--spacing-small) * 0.375);
    }
    
    .output-option.good {
        background: rgba(16, 185, 129, 0.1);
        color: #059669;
        border-color: rgba(16, 185, 129, 0.2);
    }
    
    .output-option.caution {
        background: rgba(245, 158, 11, 0.1);
        color: #d97706;
        border-color: rgba(245, 158, 11, 0.2);
    }
    
    .output-option.bad {
        background: rgba(239, 68, 68, 0.1);
        color: #dc2626;
        border-color: rgba(239, 68, 68, 0.2);
    }
    
    .output-option.worst {
        background: rgba(127, 29, 29, 0.1);
        color: #991b1b;
        border-color: rgba(127, 29, 29, 0.2);
    }
    
    /* Expectation indicators */
    .expectation-indicator {
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .expectation-indicator span {
        font-size: 14px;
        font-weight: 700;
        display: none;
        transition: all 0.3s ease;
        margin-left: 2px;
    }
    
    .expectation-indicator .expect-none {
        color: #dc2626;
    }
    
    .expectation-indicator .expect-q1,
    .expectation-indicator .expect-q2,
    .expectation-indicator .expect-q3 {
        color: #059669;
    }
    
    /* Show indicators during animation */
    .output-option.highlight .expectation-indicator span {
        display: inline-block !important;
        animation: checkmarkAppear 0.5s ease-out;
    }
    
    @keyframes checkmarkAppear {
        0% {
            transform: scale(0);
            opacity: 0;
        }
        50% {
            transform: scale(1.2);
        }
        100% {
            transform: scale(1);
            opacity: 1;
        }
    }
    
    /* Highlight animation */
    .output-option.highlight {
        animation: pulse 2s ease-in-out infinite;
        box-shadow: 0 0 0 3px currentColor, 0 6px 20px rgba(0, 0, 0, 0.15);
        font-weight: 700;
        transform: scale(1.03);
        border-color: currentColor !important;
    }
    
    @keyframes pulse {
        0%, 100% {
            opacity: 1;
            transform: scale(1.03);
        }
        50% {
            opacity: 0.9;
            transform: scale(1.05);
        }
    }
    
    /* Legend */
    .flow-legend {
        display: flex;
        justify-content: center;
        gap: var(--spacing-component);
        margin-top: var(--spacing-element);
        padding-top: var(--spacing-element);
        border-top: 1px solid rgba(0, 0, 0, 0.1);
    }
    
    .legend-item {
        display: flex;
        align-items: center;
        gap: calc(var(--spacing-small) / 2);
        font-size: 13px;
        color: var(--gray-600);
    }
    
    .legend-symbol {
        font-weight: 600;
        color: var(--gray-700);
    }
    
    .legend-symbol.success {
        color: #10b981;
    }
    
    .legend-symbol.caution {
        color: #f59e0b;
    }
    
    /* Arrows */
    .flow-arrow {
        color: var(--gray-400);
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
    }
    
    /* Responsive adjustments */
    @media (max-width: 1024px) {
        .flow-diagram {
            gap: calc(var(--spacing-small) * 0.75);
            padding: calc(var(--spacing-small) * 0.625) calc(var(--spacing-element) * 0.833);
        }
        
        .flow-box {
            padding: calc(var(--spacing-element) * 0.833);
        }
        
        .flow-arrow svg {
            width: 40px;
        }
        
        .flow-legend {
            flex-wrap: wrap;
            gap: var(--spacing-small);
        }
        
        .output-options {
            grid-template-columns: repeat(auto-fit, minmax(70px, 1fr));
            gap: calc(var(--spacing-small) * 0.375);
            max-width: 320px;
        }
        
        .output-option {
            padding: calc(var(--spacing-small) / 2) calc(var(--spacing-small) * 0.625);
            font-size: 12px;
            min-height: 28px;
        }
    }

    /* Responsive Design */
    @media (max-width: 768px) {
        .hero-header {
            padding: 60px 0 80px;
        }

        .hero-content {
            padding: 0 24px;
        }
        
        .hero-title {
            font-size: 40px;
        }
        
        .hero-subtitle {
            font-size: 18px;
        }
        
        .article-container {
            padding: 32px 16px;
        }
        
        .section-title {
            font-size: 24px;
        }
        
        .article-text {
            font-size: 16px;
        }
    }

    /* Species Animation Styles */
    .species-animation-container {
        text-align: center;
        padding: 16px 0 12px 0;
    }
    
    .callout .species-animation-container {
        margin: 0;
    }
    
    .callout-compact {
        padding: 16px 20px !important;
    }
    
    .species-animated {
        font-size: 24px;
        font-style: italic;
        font-weight: 300;
        letter-spacing: 0.02em;
        color: var(--gray-900);
        margin-bottom: 12px;
        min-height: 36px;
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 8px;
    }
    
    .genus-part, .species-part {
        position: relative;
        display: inline-block;
        transition: all 0.3s ease;
    }
    
    .species-part.fictional,
    .genus-part.fictional {
        color: #7c3aed;
    }
    
    .skeleton-word {
        display: inline-block;
        height: 24px;
        background: linear-gradient(90deg, 
            rgba(147, 51, 234, 0.1) 25%, 
            rgba(99, 102, 241, 0.15) 50%, 
            rgba(147, 51, 234, 0.1) 75%);
        background-size: 200% 100%;
        animation: loading 1.5s infinite;
        border-radius: 4px;
        vertical-align: middle;
    }
    
    .animation-label {
        font-size: 13px;
        color: var(--gray-600);
        font-style: normal;
        transition: all 0.3s ease;
    }

    .artificial-part {
        text-decoration: underline;
        text-decoration-thickness: 2px;
        text-underline-offset: 2px;
        color: #7c3aed;
    }

    /* Score example container callout fix */
    #scoreExampleContainer .callout {
        width: 100%;
        margin: 0;
    }
    
    /* Template showcase */
    .template-showcase {
        margin: 32px 0;
        padding: 24px;
        background: var(--gray-50);
        border: 1px solid var(--gray-200);
        border-radius: 12px;
        position: relative;
        overflow: hidden;
    }
    
    .template-showcase.loading .template-code {
        position: relative;
    }
    
    .template-code {
        background: #FAFAFA;
        border: 1px solid var(--gray-200);
        border-radius: 8px;
        padding: 20px;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 14px;
        line-height: 1.6;
        color: var(--gray-800);
        white-space: pre-wrap;
        margin-bottom: 16px;
        transition: all 0.3s ease;
    }
    
    /* Skeleton loading effect */
    .skeleton-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: #FAFAFA;
        z-index: 10;
        display: none;
        padding: 20px;
    }
    
    .template-showcase.loading .skeleton-overlay {
        display: block;
    }
    
    .skeleton-line {
        height: 14px;
        background: linear-gradient(90deg, 
            rgba(147, 51, 234, 0.08) 25%, 
            rgba(99, 102, 241, 0.12) 50%, 
            rgba(147, 51, 234, 0.08) 75%);
        background-size: 200% 100%;
        animation: loading 1.5s infinite;
        margin-bottom: 10px;
        border-radius: 4px;
    }
    
    .skeleton-line:nth-child(2) { width: 80%; }
    .skeleton-line:nth-child(3) { width: 90%; }
    .skeleton-line:nth-child(4) { width: 70%; }
    
    @keyframes loading {
        0% { background-position: 200% 0; }
        100% { background-position: -200% 0; }
    }
    
    .template-highlight {
        background: rgba(245, 158, 11, 0.2);
        padding: 2px 6px;
        border-radius: 4px;
        font-weight: 600;
        color: #d97706;
    }
    
    .template-caption {
        font-size: 14px;
        color: var(--gray-600);
        font-style: italic;
        text-align: center;
    }
    
    /* Data visualization section */
    .data-section {
        margin: 48px 0;
        padding: 48px 32px;
        background: var(--gray-50);
        border: 1px solid var(--gray-200);
        border-radius: 12px;
    }
    
    .template-content {
        display: block;
    }
    
    /* Legend */
    .legend-container {
        background: #FAFAFA;
        border: 1px solid var(--gray-200);
        border-radius: 12px;
        padding: 24px;
        margin-bottom: 32px;
    }
    
    .legend-title {
        font-size: 16px;
        font-weight: 600;
        margin-bottom: 16px;
        color: var(--gray-900);
    }
    
    /* Responsive adjustments */
    @media (max-width: 768px) {
        .article-title {
            font-size: 36px;
        }
        
        .section-title {
            font-size: 24px;
        }
        
        .article-text {
            font-size: 16px;
        }

        .article-content {
            max-width: 100%;
        }

        
        #scoreExampleContainer {
            float: none !important;
            width: 100% !important;
            margin: 24px 0 !important;
        }
        
        #scoreExampleContainer .callout {
            width: 100%;
            margin-left: 0;
        }
    }

    .output-option.hide {
        opacity: 0;
        transform: scale(0.9);
        pointer-events: none;
        transition: all 0.4s ease;
        filter: blur(2px);
    }

    .query-description {
        font-size: 13px;
        color: var(--gray-700);
        font-weight: 500;
        margin-bottom: 8px;
        line-height: 1.5;
        letter-spacing: 0.02em;
    }
    
    /* NEW: Animated flow result text */
    .flow-result {
        font-size: 18px;
        font-weight: 600;
        margin-top: 6px;
        display: flex;
        justify-content: center;
        align-items: center;
    }

    /* NEW: container for downward arrow + result */
    .flow-down {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin-top: 8px;
    }
    .down-arrow {
        color: var(--gray-400);
        margin-bottom: 4px;
    }

    /* Correlation Flow Grid Styles */
    .flow-grid {
        display: grid;
        grid-template-columns: auto 60px auto 60px auto 60px auto;
        grid-template-rows: auto auto;
        align-items: center;
        gap: 20px;
        margin-bottom: 24px;
    }

    .grid-species { 
        grid-row: 1 / span 2; 
        grid-column: 1; 
    }
    
    .grid-correlation { 
        grid-row: 1 / span 2; 
        grid-column: 7; 
    }

    .flow-result-box {
        background: #FAFAFA;
        border: 1px solid var(--gray-200);
        border-radius: 12px;
        padding: 16px 24px;
        min-width: 120px;
        text-align: center;
        box-shadow: 0 2px 6px rgba(0,0,0,0.05);
        font-size: 16px;
        font-weight: 600;
        color: var(--gray-900);
        transition: all 0.3s ease;
    }

    .flow-result-box.highlight {
        animation: pulse 2s ease-in-out infinite;
        box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.3), 0 6px 20px rgba(0, 0, 0, 0.15);
        transform: scale(1.03);
    }

    /* Arrow styling for correlation flow */
    .flow-arrow svg {
        color: var(--gray-400);
        transition: all 0.3s ease;
    }

    .flow-arrow.active svg {
        color: var(--primary);
        filter: drop-shadow(0 2px 4px rgba(99, 102, 241, 0.3));
    }

    .output-description {
        font-size: 11px;
        color: var(--gray-500);
        font-weight: 400;
        margin-bottom: 8px;
        line-height: 1.4;
        letter-spacing: 0.01em;
    }

    /* Loading and empty states */
    .loading-container {
        text-align: center;
        padding: 40px 20px;
    }
    
    .loading-progress {
        width: 200px;
        height: 4px;
        background: var(--gray-200);
        border-radius: 2px;
        margin: 0 auto 16px;
        overflow: hidden;
    }
    
    .loading-progress-bar {
        width: 30%;
        height: 100%;
        background: var(--primary, #6366f1);
        animation: loading-move 2s infinite;
    }
    
    @keyframes loading-move {
        0% { transform: translateX(-100%); }
        100% { transform: translateX(400%); }
    }
    
    .loading-text {
        color: var(--gray-600);
        font-size: 14px;
    }
    
    .empty-state {
        text-align: center;
        padding: 40px 20px;
        color: var(--gray-600);
    }
    
    .empty-state h3 {
        color: var(--gray-900);
        margin-bottom: 8px;
    }
    
    .knowledge-analysis-table {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 18px;
        font-size: 14px;
    }
    
    .knowledge-analysis-table th,
    .knowledge-analysis-table td {
        padding: 8px 12px;
        border: 1px solid var(--gray-200);
        text-align: left;
    }
    
    .knowledge-analysis-table th {
        background: #FAFAFA;
        font-weight: 600;
    }
    
    /* Model name cell styling */
    .model-name-cell {
        background-color: var(--gray-50);
        font-weight: 600;
        color: var(--gray-700);
        text-align: left;
        padding-left: 10px;
        font-size: 11px;
        white-space: nowrap;
        max-width: 200px;
        overflow: hidden;
        text-overflow: ellipsis;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    }
    
    .chart-cell {
        padding: 4px 8px;
    }
    
    .no-data {
        text-align: center;
        color: var(--gray-500);
        font-style: italic;
        font-size: 11px;
    }
    
    /* Analysis stats cards */
    .analysis-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
    }
    
    .stat-card {
        background: white;
        border: 2px solid var(--gray-200);
        border-radius: 8px;
        padding: 20px;
        text-align: center;
        box-shadow: var(--shadow-sm);
    }
    
    .stat-card.positive {
        border-color: #28a745;
        background-color: #f8fff9;
    }
    
    .stat-card.negative {
        border-color: #dc3545;
        background-color: #fff8f8;
    }
    
    .stat-card.neutral {
        border-color: var(--gray-400);
        background-color: var(--gray-50);
    }
    
    .stat-number {
        font-size: 28px;
        font-weight: 700;
        color: var(--gray-900);
        margin-bottom: 5px;
    }
    
    .stat-label {
        font-size: 14px;
        color: var(--gray-600);
        font-weight: 500;
    }
    
    .model-name {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 18px;
    }
    
    /* Template header styles */
    .template-header-with-description {
        margin-bottom: 15px;
    }
    
    .template-header-link {
        color: var(--gray-900);
        text-decoration: none;
        transition: color 0.2s;
    }
    
    .template-header-link:hover {
        color: var(--primary);
        text-decoration: underline;
    }
    
    .template-description-text {
        margin: 0;
        color: var(--gray-600);
        font-size: 13px;
        font-style: italic;
        line-height: 1.4;
    }
    
    /* Knowledge Analysis Container */
    .knowledge-analysis-container {
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 20px;
    }
    
    /* Dynamic Stats Text */
    .dynamic-stats {
        background: linear-gradient(135deg, 
            rgba(99, 102, 241, 0.05) 0%,
            rgba(168, 85, 247, 0.03) 50%,
            rgba(59, 130, 246, 0.05) 100%);
        border: 1px solid rgba(99, 102, 241, 0.1);
        border-radius: 12px;
        padding: 20px 28px;
        margin-bottom: 48px;
        font-size: 16px;
        line-height: 1.8;
        color: var(--gray-700);
    }
    
    /* Winner showcase */
    .winner-showcase {
        background: linear-gradient(135deg, 
            rgba(16, 185, 129, 0.05) 0%,
            rgba(34, 197, 94, 0.03) 100%);
        border: 1px solid rgba(16, 185, 129, 0.2);
        border-radius: 12px;
        padding: 24px;
        margin: 32px 0;
    }
    
    .winner-showcase h4 {
        color: var(--gray-900);
        font-size: 16px;
        font-weight: 600;
        margin: 0 0 16px 0;
    }
    
    .winner-example {
        display: flex;
        align-items: center;
        gap: 24px;
        margin-bottom: 16px;
    }
    
    .winner-model-name {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-weight: 600;
        font-size: 14px;
        color: var(--gray-900);
        min-width: 120px;
    }
    
    .winner-category {
        font-size: 13px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: var(--gray-600);
        min-width: 180px;
    }
    
    .winner-bar-chart {
        flex: 1;
        max-width: 400px;
    }
    
    .winner-description {
        font-size: 14px;
        color: var(--gray-600);
        line-height: 1.6;
        margin-top: 12px;
    }
    
    /* Expandable table */
    .table-controls {
        display: flex;
        justify-content: center;
        margin-top: 16px;
        margin-bottom: -1px;
    }
    
    .expand-button {
        background: #FAFAFA;
        border: 1px solid var(--gray-200);
        border-bottom: none;
        border-radius: 8px 8px 0 0;
        padding: 8px 20px;
        font-size: 13px;
        font-weight: 500;
        color: var(--gray-700);
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: 8px;
    }
    
    .expand-button:hover {
        background: var(--gray-50);
        color: var(--gray-900);
    }
    
    .expand-icon {
        width: 16px;
        height: 16px;
        transition: transform 0.3s ease;
    }
    
    .expand-button.expanded .expand-icon {
        transform: rotate(180deg);
    }
    
    .knowledge-analysis-table tbody tr.hidden-row {
        display: none;
    }
    
    .knowledge-analysis-table tbody tr.hidden-row.show {
        display: table-row;
    }
    
    .table-fade {
        position: relative;
    }
    
    .table-fade::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 60px;
        background: linear-gradient(to bottom, transparent, rgba(255, 255, 255, 0.9));
        pointer-events: none;
        transition: opacity 0.3s ease;
    }
    
    .table-fade.expanded::after {
        opacity: 0;
    }
    
    .stat-value {
        display: inline-block;
        font-weight: 700;
        color: var(--gray-900);
        background: rgba(99, 102, 241, 0.1);
        border-radius: 6px;
        margin: 0 2px;
        padding: 2px 6px;
        font-size: inherit;
    }
    
    .model-highlight {
        display: inline-block;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-weight: 600;
        background: rgba(124, 58, 237, 0.1);
        color: #7c3aed;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: inherit;
    }
    
    .model-lowlight {
        display: inline-block;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-weight: 600;
        background: rgba(220, 53, 69, 0.1);
        color: #dc3545;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: inherit;
    }
    
    /* Remove container styling from knowledge tables */
    .knowledge-analysis-table-wrapper {
        margin-bottom: 48px;
    }
    
    .knowledge-analysis-table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        font-size: 13px;
        background: #FAFAFA;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
    }
    
    .knowledge-analysis-table th {
        background: #FAFAFA;
        padding: 16px 20px;
        text-align: left;
        font-weight: 600;
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: var(--gray-600);
        border-bottom: 1px solid var(--gray-200);
    }
    
    .knowledge-analysis-table td {
        padding: 12px 20px;
        border-bottom: 1px solid var(--gray-100);
        vertical-align: middle;
    }
    
    .knowledge-analysis-table tbody tr:last-child td {
        border-bottom: none;
    }
    
    .knowledge-analysis-table tbody tr:hover {
        background: rgba(99, 102, 241, 0.02);
    }
    
    /* Template header without box */
    .template-section-header {
        margin-bottom: 24px;
        padding-bottom: 16px;
        border-bottom: 2px solid var(--gray-100);
    }
    
    .template-section-title {
        font-size: 20px;
        font-weight: 600;
        color: var(--gray-900);
        margin: 0 0 8px 0;
    }
    
    .template-section-description {
        font-size: 14px;
        color: var(--gray-600);
        font-style: italic;
        margin: 0;
    }
    
    /* Enhanced bar chart styles */
    .bar-chart-container {
        width: 100%;
        height: 24px;
        background: var(--gray-100);
        border-radius: 12px;
        overflow: hidden;
        position: relative;
    }
    
    .bar-chart-segments {
        display: flex;
        height: 100%;
        width: 100%;
    }
    
    .bar-segment {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 11px;
        font-weight: 600;
        position: relative;
        transition: all 0.2s ease;
        cursor: pointer;
    }
    
    .bar-segment:hover {
        filter: brightness(1.1);
        z-index: 10;
    }
    
    .bar-segment.knowledge-limited {
        background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
        color: #856404;
    }
    
    .bar-segment.knowledge-moderate {
        background: linear-gradient(135deg, #d1ecf1 0%, #bee5eb 100%);
        color: #0c5460;
    }
    
    .bar-segment.knowledge-extensive {
        background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
        color: #155724;
    }
    
    .bar-segment.knowledge-na {
        background: linear-gradient(135deg, #e2e3e5 0%, #d6d8db 100%);
        color: #383d41;
    }
    
    .bar-segment.knowledge-no-result,
    .bar-segment.knowledge-failed {
        background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
        color: #721c24;
    }
    
    .bar-number {
        font-size: 12px;
        font-weight: 700;
        text-shadow: 0 1px 2px rgba(255,255,255,0.5);
        opacity: 0;
        transition: opacity 0.2s ease;
    }
    
    .bar-segment:hover .bar-number,
    .bar-segment.show-number .bar-number {
        opacity: 1;
    }
    
    /* Quality score styling */
    .quality-score-cell {
        text-align: center;
        font-weight: 700;
        font-size: 14px;
    }
    
    .quality-score-value {
        display: inline-block;
        padding: 4px 12px;
        border-radius: 20px;
        background: linear-gradient(135deg, 
            rgba(99, 102, 241, 0.1) 0%,
            rgba(168, 85, 247, 0.08) 100%);
        color: var(--primary);
        cursor: help;
        transition: all 0.2s ease;
    }
    
    .quality-score-value:hover {
        background: linear-gradient(135deg, 
            rgba(99, 102, 241, 0.2) 0%,
            rgba(168, 85, 247, 0.15) 100%);
        transform: scale(1.05);
    }
    
    /* Compact Score Example */
    .score-example-compact {
        background: linear-gradient(135deg, 
            rgba(147, 51, 234, 0.05) 0%,
            rgba(99, 102, 241, 0.03) 100%);
        border: 1px solid rgba(147, 51, 234, 0.15);
        border-radius: 12px;
        padding: 20px;
        margin: 32px 0;
        font-size: 13px;
    }
    
    .score-example-header {
        display: flex;
        align-items: center;
        gap: 16px;
        margin-bottom: 16px;
        padding-bottom: 12px;
        border-bottom: 1px solid rgba(147, 51, 234, 0.1);
    }
    
    .score-model-name {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-weight: 600;
        color: var(--gray-900);
        background: rgba(147, 51, 234, 0.1);
        padding: 4px 12px;
        border-radius: 6px;
        font-size: 14px;
    }
    
    .score-template-name {
        font-size: 12px;
        color: var(--gray-600);
        background: var(--gray-100);
        padding: 3px 8px;
        border-radius: 4px;
        font-weight: 500;
    }
    
    .score-breakdown-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 16px;
        margin-bottom: 16px;
    }
    
    .score-type-breakdown {
        background: #FAFAFA;
        border: 1px solid var(--gray-200);
        border-radius: 8px;
        padding: 12px;
    }
    
    .score-type-title {
        font-weight: 600;
        color: var(--gray-900);
        margin-bottom: 8px;
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }
    
    .score-items {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-bottom: 8px;
    }
    
    .score-item {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 11px;
        font-weight: 600;
        padding: 3px 8px;
        border-radius: 4px;
        border: 1px solid transparent;
    }
    
    .score-item.good {
        background: rgba(16, 185, 129, 0.1);
        color: #059669;
        border-color: rgba(16, 185, 129, 0.2);
    }
    
    .score-item.caution {
        background: rgba(245, 158, 11, 0.1);
        color: #d97706;
        border-color: rgba(245, 158, 11, 0.2);
    }
    
    .score-item.bad {
        background: rgba(239, 68, 68, 0.1);
        color: #dc2626;
        border-color: rgba(239, 68, 68, 0.2);
    }
    
    .score-item.worst {
        background: rgba(127, 29, 29, 0.1);
        color: #991b1b;
        border-color: rgba(127, 29, 29, 0.2);
    }
    
    .score-subtotal {
        font-weight: 600;
        color: var(--gray-700);
        font-size: 12px;
        text-align: right;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    }
    
    .score-final {
        background: #FAFAFA;
        border: 2px solid rgba(147, 51, 234, 0.2);
        border-radius: 8px;
        padding: 12px 16px;
        text-align: center;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
    }
    
    .score-calculation {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 14px;
        color: var(--gray-700);
        font-weight: 500;
    }
    
    .score-result {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 18px;
        font-weight: 700;
        color: var(--gray-900);
        background: rgba(147, 51, 234, 0.1);
        padding: 6px 12px;
        border-radius: 6px;
    }
    
    @media (max-width: 768px) {
        .score-breakdown-grid {
            grid-template-columns: 1fr;
            gap: 12px;
        }
        
        .score-example-header {
            flex-direction: column;
            align-items: flex-start;
            gap: 8px;
        }
        
        .score-final {
            flex-direction: column;
            gap: 8px;
        }
    }

    /* Correlation Tooltip and Scatter Plot Styles */
    .correlation-tooltip {
        position: fixed;
        z-index: 1000;
        pointer-events: none;
        filter: drop-shadow(0 2px 12px rgba(0,0,0,0.15));
    }
    .correlation-tooltip-content {
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 12px;
        width: 280px;
    }
    .correlation-tooltip-header {
        font-weight: 700;
        margin-bottom: 10px;
        padding-bottom: 8px;
        border-bottom: 2px solid #e9ecef;
        color: #2c3e50;
        font-size: 12px;
    }
    .scatter-plot-container {
        width: 256px;
        height: 180px;
        position: relative;
        margin: 8px 0;
    }
    .scatter-plot-canvas {
        width: 256px;
        height: 180px;
    }

    .article-container > .article-main > article > p:last-of-type {
        margin-bottom: 10px !important;
    }

    .performer-score strong {
        font-weight: 700;
        color: var(--gray-900);
    }

    .worst-performer-section {
        margin: 32px 0;
    }
    .performer-card.worst {
        background: linear-gradient(135deg, #fff1f2, #ffe4e6);
        border-color: #fecaca;
    }
    .performer-card.worst .performer-rank {
        background: rgba(239, 68, 68, 0.1);
        color: #dc2626;
    }

    .histogram-chart {
        display: flex;
        align-items: flex-end;
        gap: 2px;
        height: 200px;
        border-bottom: 2px solid var(--gray-300);
        padding-bottom: 4px;
        margin-bottom: 8px;
    }
    .histogram-bin {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-end;
        text-align: center;
    }
    .histogram-bar {
        width: 90%;
        background: linear-gradient(to top, var(--primary), #a78bfa);
        border-radius: 4px 4px 0 0;
        color: white;
        font-size: 12px;
        font-weight: 600;
        line-height: 1.5;
        padding: 4px 2px;
        transition: all 0.2s ease;
        position: relative;
        min-height: 20px;
        display: flex;
        align-items: flex-start;
        justify-content: center;
    }
    .histogram-bar.bad { background: linear-gradient(to top, #ef4444, #f87171); }
    .histogram-bar.moderate { background: linear-gradient(to top, #f59e0b, #fcd34d); }
    .histogram-bar.good { background: linear-gradient(to top, #22c55e, #86efac); }
    .histogram-bar:hover {
        filter: brightness(1.1);
    }
    .histogram-label {
        margin-top: 8px;
        font-size: 12px;
        color: var(--gray-600);
    }
    .histogram-legend {
        display: flex;
        justify-content: center;
        gap: 24px;
        margin-top: 16px;
    }
    .histogram-legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 13px;
        color: var(--gray-600);
    }
    .histogram-legend-color {
        width: 16px;
        height: 16px;
        border-radius: 4px;
    }


    .performers-list {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 24px;
        margin-top: 16px;
    }
    .performer-card {
        background: linear-gradient(135deg, rgba(248, 250, 252, 0.8) 0%, rgba(241, 245, 249, 0.8) 100%);
        border: 1px solid rgba(16, 185, 129, 0.2);
        border-radius: 8px;
        padding: 16px;
        box-shadow: var(--shadow-sm);
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 16px;
    }
    .performer-rank {
        font-size: 14px;
        font-weight: 600;
        color: var(--gray-700);
        background: rgba(16, 185, 129, 0.1);
        border-radius: 4px;
        padding: 4px 8px;
        margin-bottom: 8px;
    }
    .performer-name {
        font-size: 16px;
        font-weight: 600;
        color: var(--gray-900);
        margin-bottom: 4px;
    }
    .performer-score {
        font-size: 14px;
        color: var(--gray-700);
        margin-bottom: 8px;
    }
    .performer-dist-chart {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .performer-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }


    .output-option.hide {
        opacity: 0;
        transform: scale(0.9);
        pointer-events: none;
        transition: all 0.4s ease;
        filter: blur(2px);
    }

    .query-description {
        font-size: 13px;
        color: var(--gray-700);
        font-weight: 500;
        margin-bottom: 8px;
        line-height: 1.5;
        letter-spacing: 0.02em;
    }

    .output-description {
        font-size: 11px;
        color: var(--gray-500);
        font-weight: 400;
        margin-bottom: 8px;
        line-height: 1.4;
        letter-spacing: 0.01em;
    }

    /* Loading and empty states */
    .loading-container {
        text-align: center;
        padding: 40px 20px;
    }
    
    .loading-progress {
        width: 200px;
        height: 4px;
        background: var(--gray-200);
        border-radius: 2px;
        margin: 0 auto 16px;
        overflow: hidden;
    }
    
    .loading-progress-bar {
        width: 30%;
        height: 100%;
        background: var(--primary, #6366f1);
        animation: loading-move 2s infinite;
    }
    
    @keyframes loading-move {
        0% { transform: translateX(-100%); }
        100% { transform: translateX(400%); }
    }
    
    .loading-text {
        color: var(--gray-600);
        font-size: 14px;
    }
    
    .empty-state {
        text-align: center;
        padding: 40px 20px;
        color: var(--gray-600);
    }
    
    .empty-state h3 {
        color: var(--gray-900);
        margin-bottom: 8px;
    }
    
    .knowledge-analysis-table {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 18px;
        font-size: 14px;
    }
    
    .knowledge-analysis-table th,
    .knowledge-analysis-table td {
        padding: 8px 12px;
        border: 1px solid var(--gray-200);
        text-align: left;
    }
    
    .knowledge-analysis-table th {
        background: #FAFAFA;
        font-weight: 600;
    }
    
    /* Model name cell styling */
    .model-name-cell {
        background-color: var(--gray-50);
        font-weight: 600;
        color: var(--gray-700);
        text-align: left;
        padding-left: 10px;
        font-size: 11px;
        white-space: nowrap;
        max-width: 200px;
        overflow: hidden;
        text-overflow: ellipsis;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    }
    
    .chart-cell {
        padding: 4px 8px;
    }
    
    .no-data {
        text-align: center;
        color: var(--gray-500);
        font-style: italic;
        font-size: 11px;
    }
    
    /* Analysis stats cards */
    .analysis-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
    }
    
    .stat-card {
        background: white;
        border: 2px solid var(--gray-200);
        border-radius: 8px;
        padding: 20px;
        text-align: center;
        box-shadow: var(--shadow-sm);
    }
    
    .stat-card.positive {
        border-color: #28a745;
        background-color: #f8fff9;
    }
    
    .stat-card.negative {
        border-color: #dc3545;
        background-color: #fff8f8;
    }
    
    .stat-card.neutral {
        border-color: var(--gray-400);
        background-color: var(--gray-50);
    }
    
    .stat-number {
        font-size: 28px;
        font-weight: 700;
        color: var(--gray-900);
        margin-bottom: 5px;
    }
    
    .stat-label {
        font-size: 14px;
        color: var(--gray-600);
        font-weight: 500;
    }
    
    .model-name {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 18px;
    }
    
    /* Template header styles */
    .template-header-with-description {
        margin-bottom: 15px;
    }
    
    .template-header-link {
        color: var(--gray-900);
        text-decoration: none;
        transition: color 0.2s;
    }
    
    .template-header-link:hover {
        color: var(--primary);
        text-decoration: underline;
    }
    
    .template-description-text {
        margin: 0;
        color: var(--gray-600);
        font-size: 13px;
        font-style: italic;
        line-height: 1.4;
    }
    
    /* Knowledge Analysis Container */
    .knowledge-analysis-container {
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 20px;
    }
    
    /* Dynamic Stats Text */
    .dynamic-stats {
        background: linear-gradient(135deg, 
            rgba(99, 102, 241, 0.05) 0%,
            rgba(168, 85, 247, 0.03) 50%,
            rgba(59, 130, 246, 0.05) 100%);
        border: 1px solid rgba(99, 102, 241, 0.1);
        border-radius: 12px;
        padding: 20px 28px;
        margin-bottom: 48px;
        font-size: 16px;
        line-height: 1.8;
        color: var(--gray-700);
    }
    
    /* Winner showcase */
    .winner-showcase {
        background: linear-gradient(135deg, 
            rgba(16, 185, 129, 0.05) 0%,
            rgba(34, 197, 94, 0.03) 100%);
        border: 1px solid rgba(16, 185, 129, 0.2);
        border-radius: 12px;
        padding: 24px;
        margin: 32px 0;
    }
    
    .winner-showcase h4 {
        color: var(--gray-900);
        font-size: 16px;
        font-weight: 600;
        margin: 0 0 16px 0;
    }
    
    .winner-example {
        display: flex;
        align-items: center;
        gap: 24px;
        margin-bottom: 16px;
    }
    
    .winner-model-name {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-weight: 600;
        font-size: 14px;
        color: var(--gray-900);
        min-width: 120px;
    }
    
    .winner-category {
        font-size: 13px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: var(--gray-600);
        min-width: 180px;
    }
    
    .winner-bar-chart {
        flex: 1;
        max-width: 400px;
    }
    
    .winner-description {
        font-size: 14px;
        color: var(--gray-600);
        line-height: 1.6;
        margin-top: 12px;
    }
    
    /* Expandable table */
    .table-controls {
        display: flex;
        justify-content: center;
        margin-top: 16px;
        margin-bottom: -1px;
    }
    
    .expand-button {
        background: #FAFAFA;
        border: 1px solid var(--gray-200);
        border-bottom: none;
        border-radius: 8px 8px 0 0;
        padding: 8px 20px;
        font-size: 13px;
        font-weight: 500;
        color: var(--gray-700);
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: 8px;
    }
    
    .expand-button:hover {
        background: var(--gray-50);
        color: var(--gray-900);
    }
    
    .expand-icon {
        width: 16px;
        height: 16px;
        transition: transform 0.3s ease;
    }
    
    .expand-button.expanded .expand-icon {
        transform: rotate(180deg);
    }
    
    .knowledge-analysis-table tbody tr.hidden-row {
        display: none;
    }
    
    .knowledge-analysis-table tbody tr.hidden-row.show {
        display: table-row;
    }
    
    .table-fade {
        position: relative;
    }
    
    .table-fade::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 60px;
        background: linear-gradient(to bottom, transparent, rgba(255, 255, 255, 0.9));
        pointer-events: none;
        transition: opacity 0.3s ease;
    }
    
    .table-fade.expanded::after {
        opacity: 0;
    }
    
    .stat-value {
        display: inline-block;
        font-weight: 700;
        color: var(--gray-900);
        background: rgba(99, 102, 241, 0.1);
        border-radius: 6px;
        margin: 0 2px;
        padding: 2px 6px;
        font-size: inherit;
    }
    
    .model-highlight {
        display: inline-block;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-weight: 600;
        background: rgba(124, 58, 237, 0.1);
        color: #7c3aed;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: inherit;
    }
    
    .model-lowlight {
        display: inline-block;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-weight: 600;
        background: rgba(220, 53, 69, 0.1);
        color: #dc3545;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: inherit;
    }
    
    /* Remove container styling from knowledge tables */
    .knowledge-analysis-table-wrapper {
        margin-bottom: 48px;
    }
    
    .knowledge-analysis-table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        font-size: 13px;
        background: #FAFAFA;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
    }
    
    .knowledge-analysis-table th {
        background: #FAFAFA;
        padding: 16px 20px;
        text-align: left;
        font-weight: 600;
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: var(--gray-600);
        border-bottom: 1px solid var(--gray-200);
    }
    
    .knowledge-analysis-table td {
        padding: 12px 20px;
        border-bottom: 1px solid var(--gray-100);
        vertical-align: middle;
    }
    
    .knowledge-analysis-table tbody tr:last-child td {
        border-bottom: none;
    }
    
    .knowledge-analysis-table tbody tr:hover {
        background: rgba(99, 102, 241, 0.02);
    }
    
    /* Template header without box */
    .template-section-header {
        margin-bottom: 24px;
        padding-bottom: 16px;
        border-bottom: 2px solid var(--gray-100);
    }
    
    .template-section-title {
        font-size: 20px;
        font-weight: 600;
        color: var(--gray-900);
        margin: 0 0 8px 0;
    }
    
    .template-section-description {
        font-size: 14px;
        color: var(--gray-600);
        font-style: italic;
        margin: 0;
    }
    
    /* Enhanced bar chart styles */
    .bar-chart-container {
        width: 100%;
        height: 24px;
        background: var(--gray-100);
        border-radius: 12px;
        overflow: hidden;
        position: relative;
    }
    
    .bar-chart-segments {
        display: flex;
        height: 100%;
        width: 100%;
    }
    
    .bar-segment {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 11px;
        font-weight: 600;
        position: relative;
        transition: all 0.2s ease;
        cursor: pointer;
    }
    
    .bar-segment:hover {
        filter: brightness(1.1);
        z-index: 10;
    }
    
    .bar-segment.knowledge-limited {
        background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
        color: #856404;
    }
    
    .bar-segment.knowledge-moderate {
        background: linear-gradient(135deg, #d1ecf1 0%, #bee5eb 100%);
        color: #0c5460;
    }
    
    .bar-segment.knowledge-extensive {
        background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
        color: #155724;
    }
    
    .bar-segment.knowledge-na {
        background: linear-gradient(135deg, #e2e3e5 0%, #d6d8db 100%);
        color: #383d41;
    }
    
    .bar-segment.knowledge-no-result,
    .bar-segment.knowledge-failed {
        background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
        color: #721c24;
    }
    
    .bar-number {
        font-size: 12px;
        font-weight: 700;
        text-shadow: 0 1px 2px rgba(255,255,255,0.5);
        opacity: 0;
        transition: opacity 0.2s ease;
    }
    
    .bar-segment:hover .bar-number,
    .bar-segment.show-number .bar-number {
        opacity: 1;
    }
    
    /* Quality score styling */
    .quality-score-cell {
        text-align: center;
        font-weight: 700;
        font-size: 14px;
    }
    
    .quality-score-value {
        display: inline-block;
        padding: 4px 12px;
        border-radius: 20px;
        background: linear-gradient(135deg, 
            rgba(99, 102, 241, 0.1) 0%,
            rgba(168, 85, 247, 0.08) 100%);
        color: var(--primary);
        cursor: help;
        transition: all 0.2s ease;
    }
    
    .quality-score-value:hover {
        background: linear-gradient(135deg, 
            rgba(99, 102, 241, 0.2) 0%,
            rgba(168, 85, 247, 0.15) 100%);
        transform: scale(1.05);
    }
    
    /* Compact Score Example */
    .score-example-compact {
        background: linear-gradient(135deg, 
            rgba(147, 51, 234, 0.05) 0%,
            rgba(99, 102, 241, 0.03) 100%);
        border: 1px solid rgba(147, 51, 234, 0.15);
        border-radius: 12px;
        padding: 20px;
        margin: 32px 0;
        font-size: 13px;
    }
    
    .score-example-header {
        display: flex;
        align-items: center;
        gap: 16px;
        margin-bottom: 16px;
        padding-bottom: 12px;
        border-bottom: 1px solid rgba(147, 51, 234, 0.1);
    }
    
    .score-model-name {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-weight: 600;
        color: var(--gray-900);
        background: rgba(147, 51, 234, 0.1);
        padding: 4px 12px;
        border-radius: 6px;
        font-size: 14px;
    }
    
    .score-template-name {
        font-size: 12px;
        color: var(--gray-600);
        background: var(--gray-100);
        padding: 3px 8px;
        border-radius: 4px;
        font-weight: 500;
    }
    
    .score-breakdown-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 16px;
        margin-bottom: 16px;
    }
    
    .score-type-breakdown {
        background: #FAFAFA;
        border: 1px solid var(--gray-200);
        border-radius: 8px;
        padding: 12px;
    }
    
    .score-type-title {
        font-weight: 600;
        color: var(--gray-900);
        margin-bottom: 8px;
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }
    
    .score-items {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-bottom: 8px;
    }
    
    .score-item {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 11px;
        font-weight: 600;
        padding: 3px 8px;
        border-radius: 4px;
        border: 1px solid transparent;
    }
    
    .score-item.good {
        background: rgba(16, 185, 129, 0.1);
        color: #059669;
        border-color: rgba(16, 185, 129, 0.2);
    }
    
    .score-item.caution {
        background: rgba(245, 158, 11, 0.1);
        color: #d97706;
        border-color: rgba(245, 158, 11, 0.2);
    }
    
    .score-item.bad {
        background: rgba(239, 68, 68, 0.1);
        color: #dc2626;
        border-color: rgba(239, 68, 68, 0.2);
    }
    
    .score-item.worst {
        background: rgba(127, 29, 29, 0.1);
        color: #991b1b;
        border-color: rgba(127, 29, 29, 0.2);
    }
    
    .score-subtotal {
        font-weight: 600;
        color: var(--gray-700);
        font-size: 12px;
        text-align: right;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    }
    
    .score-final {
        background: #FAFAFA;
        border: 2px solid rgba(147, 51, 234, 0.2);
        border-radius: 8px;
        padding: 12px 16px;
        text-align: center;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
    }
    
    .score-calculation {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 14px;
        color: var(--gray-700);
        font-weight: 500;
    }
    
    .score-result {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 18px;
        font-weight: 700;
        color: var(--gray-900);
        background: rgba(147, 51, 234, 0.1);
        padding: 6px 12px;
        border-radius: 6px;
    }
    
    @media (max-width: 768px) {
        .score-breakdown-grid {
            grid-template-columns: 1fr;
            gap: 12px;
        }
        
        .score-example-header {
            flex-direction: column;
            align-items: flex-start;
            gap: 8px;
        }
        
        .score-final {
            flex-direction: column;
            gap: 8px;
        }
    }

    .article-container > .article-main > article > p:last-of-type {
        margin-bottom: 10px !important;
    }

    .performer-score strong {
        font-weight: 700;
        color: var(--gray-900);
    }

    .worst-performer-section {
        margin: 32px 0;
    }
    .performer-card.worst {
        background: linear-gradient(135deg, #fff1f2, #ffe4e6);
        border-color: #fecaca;
    }
    .performer-card.worst .performer-rank {
        background: rgba(239, 68, 68, 0.1);
        color: #dc2626;
    }

    .histogram-chart {
        display: flex;
        align-items: flex-end;
        gap: 2px;
        height: 200px;
        border-bottom: 2px solid var(--gray-300);
        padding-bottom: 4px;
        margin-bottom: 8px;
    }
    .histogram-bin {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-end;
        text-align: center;
    }
    .histogram-bar {
        width: 90%;
        background: linear-gradient(to top, var(--primary), #a78bfa);
        border-radius: 4px 4px 0 0;
        color: white;
        font-size: 12px;
        font-weight: 600;
        line-height: 1.5;
        padding: 4px 2px;
        transition: all 0.2s ease;
        position: relative;
        min-height: 20px;
        display: flex;
        align-items: flex-start;
        justify-content: center;
    }
    .histogram-bar.bad { background: linear-gradient(to top, #ef4444, #f87171); }
    .histogram-bar.moderate { background: linear-gradient(to top, #f59e0b, #fcd34d); }
    .histogram-bar.good { background: linear-gradient(to top, #22c55e, #86efac); }
    .histogram-bar:hover {
        filter: brightness(1.1);
    }
    .histogram-label {
        margin-top: 8px;
        font-size: 12px;
        color: var(--gray-600);
    }
    .histogram-legend {
        display: flex;
        justify-content: center;
        gap: 24px;
        margin-top: 16px;
    }
    .histogram-legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 13px;
        color: var(--gray-600);
    }
    .histogram-legend-color {
        width: 16px;
        height: 16px;
        border-radius: 4px;
    }


    .performers-list {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 24px;
        margin-top: 16px;
    }
    .performer-card {
        background: linear-gradient(135deg, rgba(248, 250, 252, 0.8) 0%, rgba(241, 245, 249, 0.8) 100%);
        border: 1px solid rgba(16, 185, 129, 0.2);
        border-radius: 8px;
        padding: 16px;
        box-shadow: var(--shadow-sm);
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 16px;
    }
    .performer-rank {
        font-size: 14px;
        font-weight: 600;
        color: var(--gray-700);
        background: rgba(16, 185, 129, 0.1);
        border-radius: 4px;
        padding: 4px 8px;
        margin-bottom: 8px;
    }
    .performer-name {
        font-size: 16px;
        font-weight: 600;
        color: var(--gray-900);
        margin-bottom: 4px;
    }
    .performer-score {
        font-size: 14px;
        color: var(--gray-700);
        margin-bottom: 8px;
    }
    .performer-dist-chart {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .performer-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }


    .output-option.hide {
        opacity: 0;
        transform: scale(0.9);
        pointer-events: none;
        transition: all 0.4s ease;
        filter: blur(2px);
    }

    .query-description {
        font-size: 13px;
        color: var(--gray-700);
        font-weight: 500;
        margin-bottom: 8px;
        line-height: 1.5;
        letter-spacing: 0.02em;
    }

    .output-description {
        font-size: 11px;
        color: var(--gray-500);
        font-weight: 400;
        margin-bottom: 8px;
        line-height: 1.4;
        letter-spacing: 0.01em;
    }

    /* Loading and empty states */
    .loading-container {
        text-align: center;
        padding: 40px 20px;
    }
    
    .loading-progress {
        width: 200px;
        height: 4px;
        background: var(--gray-200);
        border-radius: 2px;
        margin: 0 auto 16px;
        overflow: hidden;
    }
    
    .loading-progress-bar {
        width: 30%;
        height: 100%;
        background: var(--primary, #6366f1);
        animation: loading-move 2s infinite;
    }
    
    @keyframes loading-move {
        0% { transform: translateX(-100%); }
        100% { transform: translateX(400%); }
    }
    
    .loading-text {
        color: var(--gray-600);
        font-size: 14px;
    }
    
    .empty-state {
        text-align: center;
        padding: 40px 20px;
        color: var(--gray-600);
    }
    
    .empty-state h3 {
        color: var(--gray-900);
        margin-bottom: 8px;
    }
    
    .knowledge-analysis-table {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 18px;
        font-size: 14px;
    }
    
    .knowledge-analysis-table th,
    .knowledge-analysis-table td {
        padding: 8px 12px;
        border: 1px solid var(--gray-200);
        text-align: left;
    }
    
    .knowledge-analysis-table th {
        background: #FAFAFA;
        font-weight: 600;
    }
    
    /* Model name cell styling */
    .model-name-cell {
        background-color: var(--gray-50);
        font-weight: 600;
        color: var(--gray-700);
        text-align: left;
        padding-left: 10px;
        font-size: 11px;
        white-space: nowrap;
        max-width: 200px;
        overflow: hidden;
        text-overflow: ellipsis;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    }
    
    .chart-cell {
        padding: 4px 8px;
    }
    
    .no-data {
        text-align: center;
        color: var(--gray-500);
        font-style: italic;
        font-size: 11px;
    }
    
    /* Analysis stats cards */
    .analysis-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
    }
    
    .stat-card {
        background: white;
        border: 2px solid var(--gray-200);
        border-radius: 8px;
        padding: 20px;
        text-align: center;
        box-shadow: var(--shadow-sm);
    }
    
    .stat-card.positive {
        border-color: #28a745;
        background-color: #f8fff9;
    }
    
    .stat-card.negative {
        border-color: #dc3545;
        background-color: #fff8f8;
    }
    
    .stat-card.neutral {
        border-color: var(--gray-400);
        background-color: var(--gray-50);
    }
    
    .stat-number {
        font-size: 28px;
        font-weight: 700;
        color: var(--gray-900);
        margin-bottom: 5px;
    }
    
    .stat-label {
        font-size: 14px;
        color: var(--gray-600);
        font-weight: 500;
    }
    
    .model-name {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 18px;
    }
    
    /* Template header styles */
    .template-header-with-description {
        margin-bottom: 15px;
    }
    
    .template-header-link {
        color: var(--gray-900);
        text-decoration: none;
        transition: color 0.2s;
    }
    
    .template-header-link:hover {
        color: var(--primary);
        text-decoration: underline;
    }
    
    .template-description-text {
        margin: 0;
        color: var(--gray-600);
        font-size: 13px;
        font-style: italic;
        line-height: 1.4;
    }
    
    /* Knowledge Analysis Container */
    .knowledge-analysis-container {
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 20px;
    }
    
    /* Dynamic Stats Text */
    .dynamic-stats {
        background: linear-gradient(135deg, 
            rgba(99, 102, 241, 0.05) 0%,
            rgba(168, 85, 247, 0.03) 50%,
            rgba(59, 130, 246, 0.05) 100%);
        border: 1px solid rgba(99, 102, 241, 0.1);
        border-radius: 12px;
        padding: 20px 28px;
        margin-bottom: 48px;
        font-size: 16px;
        line-height: 1.8;
        color: var(--gray-700);
    }
    
    /* Winner showcase */
    .winner-showcase {
        background: linear-gradient(135deg, 
            rgba(16, 185, 129, 0.05) 0%,
            rgba(34, 197, 94, 0.03) 100%);
        border: 1px solid rgba(16, 185, 129, 0.2);
        border-radius: 12px;
        padding: 24px;
        margin: 32px 0;
    }
    
    .winner-showcase h4 {
        color: var(--gray-900);
        font-size: 16px;
        font-weight: 600;
        margin: 0 0 16px 0;
    }
    
    .winner-example {
        display: flex;
        align-items: center;
        gap: 24px;
        margin-bottom: 16px;
    }
    
    .winner-model-name {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-weight: 600;
        font-size: 14px;
        color: var(--gray-900);
        min-width: 120px;
    }
    
    .winner-category {
        font-size: 13px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: var(--gray-600);
        min-width: 180px;
    }
    
    .winner-bar-chart {
        flex: 1;
        max-width: 400px;
    }
    
    .winner-description {
        font-size: 14px;
        color: var(--gray-600);
        line-height: 1.6;
        margin-top: 12px;
    }
    
    /* Expandable table */
    .table-controls {
        display: flex;
        justify-content: center;
        margin-top: 16px;
        margin-bottom: -1px;
    }
    
    .expand-button {
        background: #FAFAFA;
        border: 1px solid var(--gray-200);
        border-bottom: none;
        border-radius: 8px 8px 0 0;
        padding: 8px 20px;
        font-size: 13px;
        font-weight: 500;
        color: var(--gray-700);
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: 8px;
    }
    
    .expand-button:hover {
        background: var(--gray-50);
        color: var(--gray-900);
    }
    
    .expand-icon {
        width: 16px;
        height: 16px;
        transition: transform 0.3s ease;
    }
    
    .expand-button.expanded .expand-icon {
        transform: rotate(180deg);
    }
    
    .knowledge-analysis-table tbody tr.hidden-row {
        display: none;
    }
    
    .knowledge-analysis-table tbody tr.hidden-row.show {
        display: table-row;
    }
    
    .table-fade {
        position: relative;
    }
    
    .table-fade::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 60px;
        background: linear-gradient(to bottom, transparent, rgba(255, 255, 255, 0.9));
        pointer-events: none;
        transition: opacity 0.3s ease;
    }
    
    .table-fade.expanded::after {
        opacity: 0;
    }
    
    .stat-value {
        display: inline-block;
        font-weight: 700;
        color: var(--gray-900);
        background: rgba(99, 102, 241, 0.1);
        border-radius: 6px;
        margin: 0 2px;
        padding: 2px 6px;
        font-size: inherit;
    }
    
    .model-highlight {
        display: inline-block;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-weight: 600;
        background: rgba(124, 58, 237, 0.1);
        color: #7c3aed;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: inherit;
    }
    
    .model-lowlight {
        display: inline-block;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-weight: 600;
        background: rgba(220, 53, 69, 0.1);
        color: #dc3545;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: inherit;
    }
    
    /* Remove container styling from knowledge tables */
    .knowledge-analysis-table-wrapper {
        margin-bottom: 48px;
    }
    
    .knowledge-analysis-table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        font-size: 13px;
        background: #FAFAFA;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
    }
    
    .knowledge-analysis-table th {
        background: #FAFAFA;
        padding: 16px 20px;
        text-align: left;
        font-weight: 600;
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: var(--gray-600);
        border-bottom: 1px solid var(--gray-200);
    }
    
    .knowledge-analysis-table td {
        padding: 12px 20px;
        border-bottom: 1px solid var(--gray-100);
        vertical-align: middle;
    }
    
    .knowledge-analysis-table tbody tr:last-child td {
        border-bottom: none;
    }
    
    .knowledge-analysis-table tbody tr:hover {
        background: rgba(99, 102, 241, 0.02);
    }
    
    /* Template header without box */
    .template-section-header {
        margin-bottom: 24px;
        padding-bottom: 16px;
        border-bottom: 2px solid var(--gray-100);
    }
    
    .template-section-title {
        font-size: 20px;
        font-weight: 600;
        color: var(--gray-900);
        margin: 0 0 8px 0;
    }
    
    .template-section-description {
        font-size: 14px;
        color: var(--gray-600);
        font-style: italic;
        margin: 0;
    }
    
    /* Enhanced bar chart styles */
    .bar-chart-container {
        width: 100%;
        height: 24px;
        background: var(--gray-100);
        border-radius: 12px;
        overflow: hidden;
        position: relative;
    }
    
    .bar-chart-segments {
        display: flex;
        height: 100%;
        width: 100%;
    }
    
    .bar-segment {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 11px;
        font-weight: 600;
        position: relative;
        transition: all 0.2s ease;
        cursor: pointer;
    }
    
    .bar-segment:hover {
        filter: brightness(1.1);
        z-index: 10;
    }
    
    .bar-segment.knowledge-limited {
        background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
        color: #856404;
    }
    
    .bar-segment.knowledge-moderate {
        background: linear-gradient(135deg, #d1ecf1 0%, #bee5eb 100%);
        color: #0c5460;
    }
    
    .bar-segment.knowledge-extensive {
        background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
        color: #155724;
    }
    
    .bar-segment.knowledge-na {
        background: linear-gradient(135deg, #e2e3e5 0%, #d6d8db 100%);
        color: #383d41;
    }
    
    .bar-segment.knowledge-no-result,
    .bar-segment.knowledge-failed {
        background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
        color: #721c24;
    }
    
    .bar-number {
        font-size: 12px;
        font-weight: 700;
        text-shadow: 0 1px 2px rgba(255,255,255,0.5);
        opacity: 0;
        transition: opacity 0.2s ease;
    }
    
    .bar-segment:hover .bar-number,
    .bar-segment.show-number .bar-number {
        opacity: 1;
    }
    
    /* Quality score styling */
    .quality-score-cell {
        text-align: center;
        font-weight: 700;
        font-size: 14px;
    }
    
    .quality-score-value {
        display: inline-block;
        padding: 4px 12px;
        border-radius: 20px;
        background: linear-gradient(135deg, 
            rgba(99, 102, 241, 0.1) 0%,
            rgba(168, 85, 247, 0.08) 100%);
        color: var(--primary);
        cursor: help;
        transition: all 0.2s ease;
    }
    
    .quality-score-value:hover {
        background: linear-gradient(135deg, 
            rgba(99, 102, 241, 0.2) 0%,
            rgba(168, 85, 247, 0.15) 100%);
        transform: scale(1.05);
    }
    
    /* Compact Score Example */
    .score-example-compact {
        background: linear-gradient(135deg, 
            rgba(147, 51, 234, 0.05) 0%,
            rgba(99, 102, 241, 0.03) 100%);
        border: 1px solid rgba(147, 51, 234, 0.15);
        border-radius: 12px;
        padding: 20px;
        margin: 32px 0;
        font-size: 13px;
    }
    
    .score-example-header {
        display: flex;
        align-items: center;
        gap: 16px;
        margin-bottom: 16px;
        padding-bottom: 12px;
        border-bottom: 1px solid rgba(147, 51, 234, 0.1);
    }
    
    .score-model-name {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-weight: 600;
        color: var(--gray-900);
        background: rgba(147, 51, 234, 0.1);
        padding: 4px 12px;
        border-radius: 6px;
        font-size: 14px;
    }
    
    .score-template-name {
        font-size: 12px;
        color: var(--gray-600);
        background: var(--gray-100);
        padding: 3px 8px;
        border-radius: 4px;
        font-weight: 500;
    }
    
    .score-breakdown-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 16px;
        margin-bottom: 16px;
    }
    
    .score-type-breakdown {
        background: #FAFAFA;
        border: 1px solid var(--gray-200);
        border-radius: 8px;
        padding: 12px;
    }
    
    .score-type-title {
        font-weight: 600;
        color: var(--gray-900);
        margin-bottom: 8px;
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }
    
    .score-items {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-bottom: 8px;
    }
    
    .score-item {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 11px;
        font-weight: 600;
        padding: 3px 8px;
        border-radius: 4px;
        border: 1px solid transparent;
    }
    
    .score-item.good {
        background: rgba(16, 185, 129, 0.1);
        color: #059669;
        border-color: rgba(16, 185, 129, 0.2);
    }
    
    .score-item.caution {
        background: rgba(245, 158, 11, 0.1);
        color: #d97706;
        border-color: rgba(245, 158, 11, 0.2);
    }
    
    .score-item.bad {
        background: rgba(239, 68, 68, 0.1);
        color: #dc2626;
        border-color: rgba(239, 68, 68, 0.2);
    }
    
    .score-item.worst {
        background: rgba(127, 29, 29, 0.1);
        color: #991b1b;
        border-color: rgba(127, 29, 29, 0.2);
    }
    
    .score-subtotal {
        font-weight: 600;
        color: var(--gray-700);
        font-size: 12px;
        text-align: right;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    }
    
    .score-final {
        background: #FAFAFA;
        border: 2px solid rgba(147, 51, 234, 0.2);
        border-radius: 8px;
        padding: 12px 16px;
        text-align: center;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
    }
    
    .score-calculation {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 14px;
        color: var(--gray-700);
        font-weight: 500;
    }
    
    .score-result {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 18px;
        font-weight: 700;
        color: var(--gray-900);
        background: rgba(147, 51, 234, 0.1);
        padding: 6px 12px;
        border-radius: 6px;
    }
    
    @media (max-width: 768px) {
        .score-breakdown-grid {
            grid-template-columns: 1fr;
            gap: 12px;
        }
        
        .score-example-header {
            flex-direction: column;
            align-items: flex-start;
            gap: 8px;
        }
        
        .score-final {
            flex-direction: column;
            gap: 8px;
        }
    }

    .article-container > .article-main > article > p:last-of-type {
        margin-bottom: 10px !important;
    }

    .performer-score strong {
        font-weight: 700;
        color: var(--gray-900);
    }

    .worst-performer-section {
        margin: 32px 0;
    }
    .performer-card.worst .performer-rank {
        background: rgba(239, 68, 68, 0.1);
        color: #dc2626;
    }

    .histogram-chart {
        display: flex;
        align-items: flex-end;
        gap: 2px;
        height: 200px;
        border-bottom: 2px solid var(--gray-300);
        padding-bottom: 4px;
        margin-bottom: 8px;
    }
    .histogram-bin {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-end;
        text-align: center;
    }
    .histogram-bar {
        width: 90%;
        background: linear-gradient(to top, var(--primary), #a78bfa);
        border-radius: 4px 4px 0 0;
        color: white;
        font-size: 12px;
        font-weight: 600;
        line-height: 1.5;
        padding: 4px 2px;
        transition: all 0.2s ease;
        position: relative;
        min-height: 20px;
        display: flex;
        align-items: flex-start;
        justify-content: center;
    }
    .histogram-bar.bad { background: linear-gradient(to top, #ef4444, #f87171); }
    .histogram-bar.moderate { background: linear-gradient(to top, #f59e0b, #fcd34d); }
    .histogram-bar.good { background: linear-gradient(to top, #22c55e, #86efac); }
    .histogram-bar:hover {
        filter: brightness(1.1);
    }
    .histogram-label {
        margin-top: 8px;
        font-size: 12px;
        color: var(--gray-600);
    }
    .histogram-legend {
        display: flex;
        justify-content: center;
        gap: 24px;
        margin-top: 16px;
    }
    .histogram-legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 13px;
        color: var(--gray-600);
    }
    .histogram-legend-color {
        width: 16px;
        height: 16px;
        border-radius: 4px;
    }


    .performers-list {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 24px;
        margin-top: 16px;
    }
    .performer-card {
        background: linear-gradient(135deg, rgba(248, 250, 252, 0.8) 0%, rgba(241, 245, 249, 0.8) 100%);
        border: 1px solid rgba(16, 185, 129, 0.2);
        border-radius: 8px;
        padding: 16px;
        box-shadow: var(--shadow-sm);
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 16px;
    }
    .performer-rank {
        font-size: 14px;
        font-weight: 600;
        color: var(--gray-700);
        background: rgba(16, 185, 129, 0.1);
        border-radius: 4px;
        padding: 4px 8px;
        margin-bottom: 8px;
    }
    .performer-name {
        font-size: 16px;
        font-weight: 600;
        color: var(--gray-900);
        margin-bottom: 4px;
    }
    .performer-score {
        font-size: 14px;
        color: var(--gray-700);
        margin-bottom: 8px;
    }
    .performer-dist-chart {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .performer-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }


    .output-option.hide {
        opacity: 0;
        transform: scale(0.9);
        pointer-events: none;
        transition: all 0.4s ease;
        filter: blur(2px);
    }

    .query-description {
        font-size: 13px;
        color: var(--gray-700);
        font-weight: 500;
        margin-bottom: 8px;
        line-height: 1.5;
        letter-spacing: 0.02em;
    }

    .output-description {
        font-size: 11px;
        color: var(--gray-500);
        font-weight: 400;
        margin-bottom: 8px;
        line-height: 1.4;
        letter-spacing: 0.01em;
    }

    /* Loading and empty states */
    .loading-container {
        text-align: center;
        padding: 40px 20px;
    }
    
    .loading-progress {
        width: 200px;
        height: 4px;
        background: var(--gray-200);
        border-radius: 2px;
        margin: 0 auto 16px;
        overflow: hidden;
    }
    
    .loading-progress-bar {
        width: 30%;
        height: 100%;
        background: var(--primary, #6366f1);
        animation: loading-move 2s infinite;
    }
    
    @keyframes loading-move {
        0% { transform: translateX(-100%); }
        100% { transform: translateX(400%); }
    }
    
    .loading-text {
        color: var(--gray-600);
        font-size: 14px;
    }
    
    .empty-state {
        text-align: center;
        padding: 40px 20px;
        color: var(--gray-600);
    }
    
    .empty-state h3 {
        color: var(--gray-900);
        margin-bottom: 8px;
    }
    
    .knowledge-analysis-table {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 18px;
        font-size: 14px;
    }
    
    .knowledge-analysis-table th,
    .knowledge-analysis-table td {
        padding: 8px 12px;
        border: 1px solid var(--gray-200);
        text-align: left;
    }
    
    .knowledge-analysis-table th {
        background: #FAFAFA;
        font-weight: 600;
    }
    
    /* Model name cell styling */
    .model-name-cell {
        background-color: var(--gray-50);
        font-weight: 600;
        color: var(--gray-700);
        text-align: left;
        padding-left: 10px;
        font-size: 11px;
        white-space: nowrap;
        max-width: 200px;
        overflow: hidden;
        text-overflow: ellipsis;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    }
    
    .chart-cell {
        padding: 4px 8px;
    }
    
    .no-data {
        text-align: center;
        color: var(--gray-500);
        font-style: italic;
        font-size: 11px;
    }
    
    /* Analysis stats cards */
    .analysis-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
    }
    
    .stat-card {
        background: white;
        border: 2px solid var(--gray-200);
        border-radius: 8px;
        padding: 20px;
        text-align: center;
        box-shadow: var(--shadow-sm);
    }
    
    .stat-card.positive {
        border-color: #28a745;
        background-color: #f8fff9;
    }
    
    .stat-card.negative {
        border-color: #dc3545;
        background-color: #fff8f8;
    }
    
    .stat-card.neutral {
        border-color: var(--gray-400);
        background-color: var(--gray-50);
    }
    
    .stat-number {
        font-size: 28px;
        font-weight: 700;
        color: var(--gray-900);
        margin-bottom: 5px;
    }
    
    .stat-label {
        font-size: 14px;
        color: var(--gray-600);
        font-weight: 500;
    }
    
    .model-name {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 18px;
    }
    
    /* Template header styles */
    .template-header-with-description {
        margin-bottom: 15px;
    }
    
    .template-header-link {
        color: var(--gray-900);
        text-decoration: none;
        transition: color 0.2s;
    }
    
    .template-header-link:hover {
        color: var(--primary);
        text-decoration: underline;
    }
    
    .template-description-text {
        margin: 0;
        color: var(--gray-600);
        font-size: 13px;
        font-style: italic;
        line-height: 1.4;
    }
    
    /* Knowledge Analysis Container */
    .knowledge-analysis-container {
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 20px;
    }
    
    /* Dynamic Stats Text */
    .dynamic-stats {
        background: linear-gradient(135deg, 
            rgba(99, 102, 241, 0.05) 0%,
            rgba(168, 85, 247, 0.03) 50%,
            rgba(59, 130, 246, 0.05) 100%);
        border: 1px solid rgba(99, 102, 241, 0.1);
        border-radius: 12px;
        padding: 20px 28px;
        margin-bottom: 48px;
        font-size: 16px;
        line-height: 1.8;
        color: var(--gray-700);
    }
    
    /* Winner showcase */
    .winner-showcase {
        background: linear-gradient(135deg, 
            rgba(16, 185, 129, 0.05) 0%,
            rgba(34, 197, 94, 0.03) 100%);
        border: 1px solid rgba(16, 185, 129, 0.2);
        border-radius: 12px;
        padding: 24px;
        margin: 32px 0;
    }
    
    .winner-showcase h4 {
        color: var(--gray-900);
        font-size: 16px;
        font-weight: 600;
        margin: 0 0 16px 0;
    }
    
    .winner-example {
        display: flex;
        align-items: center;
        gap: 24px;
        margin-bottom: 16px;
    }
    
    .winner-model-name {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-weight: 600;
        font-size: 14px;
        color: var(--gray-900);
        min-width: 120px;
    }
    
    .winner-category {
        font-size: 13px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: var(--gray-600);
        min-width: 180px;
    }
    
    .winner-bar-chart {
        flex: 1;
        max-width: 400px;
    }
    
    .winner-description {
        font-size: 14px;
        color: var(--gray-600);
        line-height: 1.6;
        margin-top: 12px;
    }
    
    /* Expandable table */
    .table-controls {
        display: flex;
        justify-content: center;
        margin-top: 16px;
        margin-bottom: -1px;
    }
    
    .expand-button {
        background: #FAFAFA;
        border: 1px solid var(--gray-200);
        border-bottom: none;
        border-radius: 8px 8px 0 0;
        padding: 8px 20px;
        font-size: 13px;
        font-weight: 500;
        color: var(--gray-700);
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: 8px;
    }
    
    .expand-button:hover {
        background: var(--gray-50);
        color: var(--gray-900);
    }
    
    .expand-icon {
        width: 16px;
        height: 16px;
        transition: transform 0.3s ease;
    }
    
    .expand-button.expanded .expand-icon {
        transform: rotate(180deg);
    }
    
    .knowledge-analysis-table tbody tr.hidden-row {
        display: none;
    }
    
    .knowledge-analysis-table tbody tr.hidden-row.show {
        display: table-row;
    }
    
    .table-fade {
        position: relative;
    }
    
    .table-fade::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 60px;
        background: linear-gradient(to bottom, transparent, rgba(255, 255, 255, 0.9));
        pointer-events: none;
        transition: opacity 0.3s ease;
    }
    
    .table-fade.expanded::after {
        opacity: 0;
    }
    
    .stat-value {
        display: inline-block;
        font-weight: 700;
        color: var(--gray-900);
        background: rgba(99, 102, 241, 0.1);
        border-radius: 6px;
        margin: 0 2px;
        padding: 2px 6px;
        font-size: inherit;
    }
    
    .model-highlight {
        display: inline-block;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-weight: 600;
        background: rgba(124, 58, 237, 0.1);
        color: #7c3aed;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: inherit;
    }
    
    .model-lowlight {
        display: inline-block;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-weight: 600;
        background: rgba(220, 53, 69, 0.1);
        color: #dc3545;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: inherit;
    }
    
    /* Remove container styling from knowledge tables */
    .knowledge-analysis-table-wrapper {
        margin-bottom: 48px;
    }
    
    .knowledge-analysis-table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        font-size: 13px;
        background: #FAFAFA;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
    }
    
    .knowledge-analysis-table th {
        background: #FAFAFA;
        padding: 16px 20px;
        text-align: left;
        font-weight: 600;
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: var(--gray-600);
        border-bottom: 1px solid var(--gray-200);
    }
    
    .knowledge-analysis-table td {
        padding: 12px 20px;
        border-bottom: 1px solid var(--gray-100);
        vertical-align: middle;
    }
    
    .knowledge-analysis-table tbody tr:last-child td {
        border-bottom: none;
    }
    
    .knowledge-analysis-table tbody tr:hover {
        background: rgba(99, 102, 241, 0.02);
    }
    
    /* Template header without box */
    .template-section-header {
        margin-bottom: 24px;
        padding-bottom: 16px;
        border-bottom: 2px solid var(--gray-100);
    }
    
    .template-section-title {
        font-size: 20px;
        font-weight: 600;
        color: var(--gray-900);
        margin: 0 0 8px 0;
    }
    
    .template-section-description {
        font-size: 14px;
        color: var(--gray-600);
        font-style: italic;
        margin: 0;
    }
    
    /* Enhanced bar chart styles */
    .bar-chart-container {
        width: 100%;
        height: 24px;
        background: var(--gray-100);
        border-radius: 12px;
        overflow: hidden;
        position: relative;
    }
    
    .bar-chart-segments {
        display: flex;
        height: 100%;
        width: 100%;
    }
    
    .bar-segment {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 11px;
        font-weight: 600;
        position: relative;
        transition: all 0.2s ease;
        cursor: pointer;
    }
    
    .bar-segment:hover {
        filter: brightness(1.1);
        z-index: 10;
    }
    
    .bar-segment.knowledge-moderate {
        background: linear-gradient(135deg, #d1ecf1 0%, #bee5eb 100%);
        color: #0c5460;
    }
    
    .bar-segment.knowledge-extensive {
        background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
        color: #155724;
    }
    
    .bar-segment.knowledge-na {
        background: linear-gradient(135deg, #e2e3e5 0%, #d6d8db 100%);
        color: #383d41;
    }
    
    .bar-segment.knowledge-no-result,
    .bar-segment.knowledge-failed {
        background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
        color: #721c24;
    }
    
    .bar-number {
        font-size: 12px;
        font-weight: 700;
        text-shadow: 0 1px 2px rgba(255,255,255,0.5);
        opacity: 0;
        transition: opacity 0.2s ease;
    }
    
    .bar-segment:hover .bar-number,
    .bar-segment.show-number .bar-number {
        opacity: 1;
    }
    
    /* Quality score styling */
    .quality-score-cell {
        text-align: center;
        font-weight: 700;
        font-size: 14px;
    }
    
    .quality-score-value {
        display: inline-block;
        padding: 4px 12px;
        border-radius: 20px;
        background: linear-gradient(135deg, 
            rgba(99, 102, 241, 0.1) 0%,
            rgba(168, 85, 247, 0.08) 100%);
        color: var(--primary);
        cursor: help;
        transition: all 0.2s ease;
    }
    
    .quality-score-value:hover {
        background: linear-gradient(135deg, 
            rgba(99, 102, 241, 0.2) 0%,
            rgba(168, 85, 247, 0.15) 100%);
        transform: scale(1.05);
    }
    
    /* Compact Score Example */
    .score-example-compact {
        background: linear-gradient(135deg, 
            rgba(147, 51, 234, 0.05) 0%,
            rgba(99, 102, 241, 0.03) 100%);
        border: 1px solid rgba(147, 51, 234, 0.15);
        border-radius: 12px;
        padding: 20px;
        margin: 32px 0;
        font-size: 13px;
    }
    
    .score-example-header {
        display: flex;
        align-items: center;
        gap: 16px;
        margin-bottom: 16px;
        padding-bottom: 12px;
        border-bottom: 1px solid rgba(147, 51, 234, 0.1);
    }
    
    .score-model-name {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-weight: 600;
        color: var(--gray-900);
        background: rgba(147, 51, 234, 0.1);
        padding: 4px 12px;
        border-radius: 6px;
        font-size: 14px;
    }
    
    .score-template-name {
        font-size: 12px;
        color: var(--gray-600);
        background: var(--gray-100);
        padding: 3px 8px;
        border-radius: 4px;
        font-weight: 500;
    }
    
    .score-breakdown-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 16px;
        margin-bottom: 16px;
    }
    
    .score-type-breakdown {
        background: #FAFAFA;
        border: 1px solid var(--gray-200);
        border-radius: 8px;
        padding: 12px;
    }
    
    .score-type-title {
        font-weight: 600;
        color: var(--gray-900);
        margin-bottom: 8px;
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }
    
    .score-items {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-bottom: 8px;
    }
    
    .score-item {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 11px;
        font-weight: 600;
        padding: 3px 8px;
        border-radius: 4px;
        border: 1px solid transparent;
    }
    
    .score-item.good {
        background: rgba(16, 185, 129, 0.1);
        color: #059669;
        border-color: rgba(16, 185, 129, 0.2);
    }
    
    .score-item.caution {
        background: rgba(245, 158, 11, 0.1);
        color: #d97706;
        border-color: rgba(245, 158, 11, 0.2);
    }
    
    .score-item.bad {
        background: rgba(239, 68, 68, 0.1);
        color: #dc2626;
        border-color: rgba(239, 68, 68, 0.2);
    }
    
    .score-item.worst {
        background: rgba(127, 29, 29, 0.1);
        color: #991b1b;
        border-color: rgba(127, 29, 29, 0.2);
    }
    
    .score-subtotal {
        font-weight: 600;
        color: var(--gray-700);
        font-size: 12px;
        text-align: right;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    }
    
    .score-final {
        background: #FAFAFA;
        border: 2px solid rgba(147, 51, 234, 0.2);
        border-radius: 8px;
        padding: 12px 16px;
        text-align: center;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
    }
    
    .score-calculation {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 14px;
        color: var(--gray-700);
        font-weight: 500;
    }
    
    .score-result {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 18px;
        font-weight: 700;
        color: var(--gray-900);
        background: rgba(147, 51, 234, 0.1);
        padding: 6px 12px;
        border-radius: 6px;
    }
    
    @media (max-width: 768px) {
        .score-breakdown-grid {
            grid-template-columns: 1fr;
            gap: 12px;
        }
        
        .score-example-header {
            flex-direction: column;
            align-items: flex-start;
            gap: 8px;
        }
        
        .score-final {
            flex-direction: column;
            gap: 8px;
        }
    }

    .article-container > .article-main > article > p:last-of-type {
        margin-bottom: 10px !important;
    }

    .performer-score strong {
        font-weight: 700;
        color: var(--gray-900);
    }

    .worst-performer-section {
        margin: 32px 0;
    }
    .performer-card.worst {
        background: linear-gradient(135deg, #fff1f2, #ffe4e6);
        border-color: #fecaca;
    }
    .performer-card.worst .performer-rank {
        background: rgba(239, 68, 68, 0.1);
        color: #dc2626;
    }

    .histogram-chart {
        display: flex;
        align-items: flex-end;
        gap: 2px;
        height: 200px;
        border-bottom: 2px solid var(--gray-300);
        padding-bottom: 4px;
        margin-bottom: 8px;
    }
    .histogram-bin {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-end;
        text-align: center;
    }
    .histogram-bar {
        width: 90%;
        background: linear-gradient(to top, var(--primary), #a78bfa);
        border-radius: 4px 4px 0 0;
        color: white;
        font-size: 12px;
        font-weight: 600;
        line-height: 1.5;
        padding: 4px 2px;
        transition: all 0.2s ease;
        position: relative;
        min-height: 20px;
        display: flex;
        align-items: flex-start;
        justify-content: center;
    }
    .histogram-bar.bad { background: linear-gradient(to top, #ef4444, #f87171); }
    .histogram-bar.moderate { background: linear-gradient(to top, #f59e0b, #fcd34d); }
    .histogram-bar.good { background: linear-gradient(to top, #22c55e, #86efac); }
    .histogram-bar:hover {
        filter: brightness(1.1);
    }
    .histogram-label {
        margin-top: 8px;
        font-size: 12px;
        color: var(--gray-600);
    }
    .histogram-legend {
        display: flex;
        justify-content: center;
        gap: 24px;
        margin-top: 16px;
    }
    .histogram-legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 13px;
        color: var(--gray-600);
    }
    .histogram-legend-color {
        width: 16px;
        height: 16px;
        border-radius: 4px;
    }


    .performers-list {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 24px;
        margin-top: 16px;
    }
    .performer-card {
        background: linear-gradient(135deg, rgba(248, 250, 252, 0.8) 0%, rgba(241, 245, 249, 0.8) 100%);
        border: 1px solid rgba(16, 185, 129, 0.2);
        border-radius: 8px;
        padding: 16px;
        box-shadow: var(--shadow-sm);
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 16px;
    }
    .performer-rank {
        font-size: 14px;
        font-weight: 600;
        color: var(--gray-700);
        background: rgba(16, 185, 129, 0.1);
        border-radius: 4px;
        padding: 4px 8px;
        margin-bottom: 8px;
    }
    .performer-name {
        font-size: 16px;
        font-weight: 600;
        color: var(--gray-900);
        margin-bottom: 4px;
    }
    .performer-score {
        font-size: 14px;
        color: var(--gray-700);
        margin-bottom: 8px;
    }
    .performer-dist-chart {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .performer-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }


    .output-option.hide {
        opacity: 0;
        transform: scale(0.9);
        pointer-events: none;
        transition: all 0.4s ease;
        filter: blur(2px);
    }

    .query-description {
        font-size: 13px;
        color: var(--gray-700);
        font-weight: 500;
        margin-bottom: 8px;
        line-height: 1.5;
        letter-spacing: 0.02em;
    }

    .output-description {
        font-size: 11px;
        color: var(--gray-500);
        font-weight: 400;
        margin-bottom: 8px;
        line-height: 1.4;
        letter-spacing: 0.01em;
    }

    /* Loading and empty states */
    .loading-container {
        text-align: center;
        padding: 40px 20px;
    }
    
    .loading-progress {
        width: 200px;
        height: 4px;
        background: var(--gray-200);
        border-radius: 2px;
        margin: 0 auto 16px;
        overflow: hidden;
    }
    
    .loading-progress-bar {
        width: 30%;
        height: 100%;
        background: var(--primary, #6366f1);
        animation: loading-move 2s infinite;
    }
    
    @keyframes loading-move {
        0% { transform: translateX(-100%); }
        100% { transform: translateX(400%); }
    }
    
    .loading-text {
        color: var(--gray-600);
        font-size: 14px;
    }
    
    .empty-state {
        text-align: center;
        padding: 40px 20px;
        color: var(--gray-600);
    }
    
    .empty-state h3 {
        color: var(--gray-900);
        margin-bottom: 8px;
    }
    
    .knowledge-analysis-table {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 18px;
        font-size: 14px;
    }
    
    .knowledge-analysis-table th,
    .knowledge-analysis-table td {
        padding: 8px 12px;
        border: 1px solid var(--gray-200);
        text-align: left;
    }
    
    .knowledge-analysis-table th {
        background: #FAFAFA;
        font-weight: 600;
    }
    
    /* Model name cell styling */
    .model-name-cell {
        background-color: var(--gray-50);
        font-weight: 600;
        color: var(--gray-700);
        text-align: left;
        padding-left: 10px;
        font-size: 11px;
        white-space: nowrap;
        max-width: 200px;
        overflow: hidden;
        text-overflow: ellipsis;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    }
    
    .chart-cell {
        padding: 4px 8px;
    }
    
    .no-data {
        text-align: center;
        color: var(--gray-500);
        font-style: italic;
        font-size: 11px;
    }
    
    /* Analysis stats cards */
    .analysis-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
    }
    
    .stat-card {
        background: white;
        border: 2px solid var(--gray-200);
        border-radius: 8px;
        padding: 20px;
        text-align: center;
        box-shadow: var(--shadow-sm);
    }
    
    .stat-card.positive {
        border-color: #28a745;
        background-color: #f8fff9;
    }
    
    .stat-card.negative {
        border-color: #dc3545;
        background-color: #fff8f8;
    }
    
    .stat-card.neutral {
        border-color: var(--gray-400);
        background-color: var(--gray-50);
    }
    
    .stat-number {
        font-size: 28px;
        font-weight: 700;
        color: var(--gray-900);
        margin-bottom: 5px;
    }
    
    .stat-label {
        font-size: 14px;
        color: var(--gray-600);
        font-weight: 500;
    }
    
    .model-name {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 18px;
    }
    
    /* Template header styles */
    .template-header-with-description {
        margin-bottom: 15px;
    }
    
    .template-header-link {
        color: var(--gray-900);
        text-decoration: none;
        transition: color 0.2s;
    }
    
    .template-header-link:hover {
        color: var(--primary);
        text-decoration: underline;
    }
    
    .template-description-text {
        margin: 0;
        color: var(--gray-600);
        font-size: 13px;
        font-style: italic;
        line-height: 1.4;
    }
    
    /* Knowledge Analysis Container */
    .knowledge-analysis-container {
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 20px;
    }
    
    /* Dynamic Stats Text */
    .dynamic-stats {
        background: linear-gradient(135deg, 
            rgba(99, 102, 241, 0.05) 0%,
            rgba(168, 85, 247, 0.03) 50%,
            rgba(59, 130, 246, 0.05) 100%);
        border: 1px solid rgba(99, 102, 241, 0.1);
        border-radius: 12px;
        padding: 20px 28px;
        margin-bottom: 48px;
        font-size: 16px;
        line-height: 1.8;
        color: var(--gray-700);
    }
    
    /* Winner showcase */
    .winner-showcase {
        background: linear-gradient(135deg, 
            rgba(16, 185, 129, 0.05) 0%,
            rgba(34, 197, 94, 0.03) 100%);
        border: 1px solid rgba(16, 185, 129, 0.2);
        border-radius: 12px;
        padding: 24px;
        margin: 32px 0;
    }
    
    .winner-showcase h4 {
        color: var(--gray-900);
        font-size: 16px;
        font-weight: 600;
        margin: 0 0 16px 0;
    }
    
    .winner-example {
        display: flex;
        align-items: center;
        gap: 24px;
        margin-bottom: 16px;
    }
    
    .winner-model-name {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-weight: 600;
        font-size: 14px;
        color: var(--gray-900);
        min-width: 120px;
    }
    
    .winner-category {
        font-size: 13px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: var(--gray-600);
        min-width: 180px;
    }
    
    .winner-bar-chart {
        flex: 1;
        max-width: 400px;
    }
    
    .winner-description {
        font-size: 14px;
        color: var(--gray-600);
        line-height: 1.6;
        margin-top: 12px;
    }
    
    /* Expandable table */
    .table-controls {
        display: flex;
        justify-content: center;
        margin-top: 16px;
        margin-bottom: -1px;
    }
    
    .expand-button {
        background: #FAFAFA;
        border: 1px solid var(--gray-200);
        border-bottom: none;
        border-radius: 8px 8px 0 0;
        padding: 8px 20px;
        font-size: 13px;
        font-weight: 500;
        color: var(--gray-700);
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: 8px;
    }
    
    .expand-button:hover {
        background: var(--gray-50);
        color: var(--gray-900);
    }
    
    .expand-icon {
        width: 16px;
        height: 16px;
        transition: transform 0.3s ease;
    }
    
    .expand-button.expanded .expand-icon {
        transform: rotate(180deg);
    }
    
    .knowledge-analysis-table tbody tr.hidden-row {
        display: none;
    }
    
    .knowledge-analysis-table tbody tr.hidden-row.show {
        display: table-row;
    }
    
    .table-fade {
        position: relative;
    }
    
    .table-fade::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 60px;
        background: linear-gradient(to bottom, transparent, rgba(255, 255, 255, 0.9));
        pointer-events: none;
        transition: opacity 0.3s ease;
    }
    
    .table-fade.expanded::after {
        opacity: 0;
    }
    
    .stat-value {
        display: inline-block;
        font-weight: 700;
        color: var(--gray-900);
        background: rgba(99, 102, 241, 0.1);
        border-radius: 6px;
        margin: 0 2px;
        padding: 2px 6px;
        font-size: inherit;
    }
    
    .model-highlight {
        display: inline-block;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-weight: 600;
        background: rgba(124, 58, 237, 0.1);
        color: #7c3aed;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: inherit;
    }
    
    .model-lowlight {
        display: inline-block;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-weight: 600;
        background: rgba(220, 53, 69, 0.1);
        color: #dc3545;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: inherit;
    }
    
    /* Remove container styling from knowledge tables */
    .knowledge-analysis-table-wrapper {
        margin-bottom: 48px;
    }
    
    .knowledge-analysis-table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        font-size: 13px;
        background: #FAFAFA;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
    }
    
    .knowledge-analysis-table th {
        background: #FAFAFA;
        padding: 16px 20px;
        text-align: left;
        font-weight: 600;
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: var(--gray-600);
        border-bottom: 1px solid var(--gray-200);
    }
    
    .knowledge-analysis-table td {
        padding: 12px 20px;
        border-bottom: 1px solid var(--gray-100);
        vertical-align: middle;
    }
    
    .knowledge-analysis-table tbody tr:last-child td {
        border-bottom: none;
    }
    
    .knowledge-analysis-table tbody tr:hover {
        background: rgba(99, 102, 241, 0.02);
    }
    
    /* Template header without box */
    .template-section-header {
        margin-bottom: 24px;
        padding-bottom: 16px;
        border-bottom: 2px solid var(--gray-100);
    }
    
    .template-section-title {
        font-size: 20px;
        font-weight: 600;
        color: var(--gray-900);
        margin: 0 0 8px 0;
    }
    
    .template-section-description {
        font-size: 14px;
        color: var(--gray-600);
        font-style: italic;
        margin: 0;
    }
    
    /* Enhanced bar chart styles */
    .bar-chart-container {
        width: 100%;
        height: 24px;
        background: var(--gray-100);
        border-radius: 12px;
        overflow: hidden;
        position: relative;
    }
    
    .bar-chart-segments {
        display: flex;
        height: 100%;
        width: 100%;
    }
    
    .bar-segment {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 11px;
        font-weight: 600;
        position: relative;
        transition: all 0.2s ease;
        cursor: pointer;
    }
    
    .bar-segment:hover {
        filter: brightness(1.1);
        z-index: 10;
    }
    
    .bar-segment.knowledge-limited {
        background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
        color: #856404;
    }
    
    .bar-segment.knowledge-moderate {
        background: linear-gradient(135deg, #d1ecf1 0%, #bee5eb 100%);
        color: #0c5460;
    }
    
    .bar-segment.knowledge-extensive {
        background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
        color: #155724;
    }
    
    .bar-segment.knowledge-na {
        background: linear-gradient(135deg, #e2e3e5 0%, #d6d8db 100%);
        color: #383d41;
    }
    
    .bar-segment.knowledge-no-result,
    .bar-segment.knowledge-failed {
        background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
        color: #721c24;
    }
    
    .bar-number {
        font-size: 12px;
        font-weight: 700;
        text-shadow: 0 1px 2px rgba(255,255,255,0.5);
        opacity: 0;
        transition: opacity 0.2s ease;
    }
    
    .bar-segment:hover .bar-number,
    .bar-segment.show-number .bar-number {
        opacity: 1;
    }
    
    /* Quality score styling */
    .quality-score-cell {
        text-align: center;
        font-weight: 700;
        font-size: 14px;
    }
    
    .quality-score-value {
        display: inline-block;
        padding: 4px 12px;
        border-radius: 20px;
        background: linear-gradient(135deg, 
            rgba(99, 102, 241, 0.1) 0%,
            rgba(168, 85, 247, 0.08) 100%);
        color: var(--primary);
        cursor: help;
        transition: all 0.2s ease;
    }
    
    .quality-score-value:hover {
        background: linear-gradient(135deg, 
            rgba(99, 102, 241, 0.2) 0%,
            rgba(168, 85, 247, 0.15) 100%);
        transform: scale(1.05);
    }
    
    /* Compact Score Example */
    .score-example-compact {
        background: linear-gradient(135deg, 
            rgba(147, 51, 234, 0.05) 0%,
            rgba(99, 102, 241, 0.03) 100%);
        border: 1px solid rgba(147, 51, 234, 0.15);
        border-radius: 12px;
        padding: 20px;
        margin: 32px 0;
        font-size: 13px;
    }
    
    .score-example-header {
        display: flex;
        align-items: center;
        gap: 16px;
        margin-bottom: 16px;
        padding-bottom: 12px;
        border-bottom: 1px solid rgba(147, 51, 234, 0.1);
    }
    
    .score-model-name {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-weight: 600;
        color: var(--gray-900);
        background: rgba(147, 51, 234, 0.1);
        padding: 4px 12px;
        border-radius: 6px;
        font-size: 14px;
    }
    
    .score-template-name {
        font-size: 12px;
        color: var(--gray-600);
        background: var(--gray-100);
        padding: 3px 8px;
        border-radius: 4px;
        font-weight: 500;
    }
    
    .score-breakdown-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 16px;
        margin-bottom: 16px;
    }
    
    .score-type-breakdown {
        background: #FAFAFA;
        border: 1px solid var(--gray-200);
        border-radius: 8px;
        padding: 12px;
    }
    
    .score-type-title {
        font-weight: 600;
        color: var(--gray-900);
        margin-bottom: 8px;
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }
    
    .score-items {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-bottom: 8px;
    }
    
    .score-item {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 11px;
        font-weight: 600;
        padding: 3px 8px;
        border-radius: 4px;
        border: 1px solid transparent;
    }
    
    .score-item.good {
        background: rgba(16, 185, 129, 0.1);
        color: #059669;
        border-color: rgba(16, 185, 129, 0.2);
    }
    
    .score-item.caution {
        background: rgba(245, 158, 11, 0.1);
        color: #d97706;
        border-color: rgba(245, 158, 11, 0.2);
    }
    
    .score-item.bad {
        background: rgba(239, 68, 68, 0.1);
        color: #dc2626;
        border-color: rgba(239, 68, 68, 0.2);
    }
    
    .score-item.worst {
        background: rgba(127, 29, 29, 0.1);
        color: #991b1b;
        border-color: rgba(127, 29, 29, 0.2);
    }
    
    .score-subtotal {
        font-weight: 600;
        color: var(--gray-700);
        font-size: 12px;
        text-align: right;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    }
    
    .score-final {
        background: #FAFAFA;
        border: 2px solid rgba(147, 51, 234, 0.2);
        border-radius: 8px;
        padding: 12px 16px;
        text-align: center;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
    }
    
    .score-calculation {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 14px;
        color: var(--gray-700);
        font-weight: 500;
    }
    
    .score-result {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 18px;
        font-weight: 700;
        color: var(--gray-900);
        background: rgba(147, 51, 234, 0.1);
        padding: 6px 12px;
        border-radius: 6px;
    }
    
    @media (max-width: 768px) {
        .score-breakdown-grid {
            grid-template-columns: 1fr;
            gap: 12px;
        }
        
        .score-example-header {
            flex-direction: column;
            align-items: flex-start;
            gap: 8px;
        }
        
        .score-final {
            flex-direction: column;
            gap: 8px;
        }
    }

    .article-container > .article-main > article > p:last-of-type {
        margin-bottom: 10px !important;
    }

    .performer-score strong {
        font-weight: 700;
        color: var(--gray-900);
    }

    .worst-performer-section {
        margin: 32px 0;
    }
    .performer-card.worst {
        background: linear-gradient(135deg, #fff1f2, #ffe4e6);
        border-color: #fecaca;
    }
    .performer-card.worst .performer-rank {
        background: rgba(239, 68, 68, 0.1);
        color: #dc2626;
    }

    .histogram-chart {
        display: flex;
        align-items: flex-end;
        gap: 2px;
        height: 200px;
        border-bottom: 2px solid var(--gray-300);
        padding-bottom: 4px;
        margin-bottom: 8px;
    }
    .histogram-bin {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-end;
        text-align: center;
    }
    .histogram-bar {
        width: 90%;
        background: linear-gradient(to top, var(--primary), #a78bfa);
        border-radius: 4px 4px 0 0;
        color: white;
        font-size: 12px;
        font-weight: 600;
        line-height: 1.5;
        padding: 4px 2px;
        transition: all 0.2s ease;
        position: relative;
        min-height: 20px;
        display: flex;
        align-items: flex-start;
        justify-content: center;
    }
    .histogram-bar.bad { background: linear-gradient(to top, #ef4444, #f87171); }
    .histogram-bar.moderate { background: linear-gradient(to top, #f59e0b, #fcd34d); }
    .histogram-bar.good { background: linear-gradient(to top, #22c55e, #86efac); }
    .histogram-bar:hover {
        filter: brightness(1.1);
    }
    .histogram-label {
        margin-top: 8px;
        font-size: 12px;
        color: var(--gray-600);
    }
    .histogram-legend {
        display: flex;
        justify-content: center;
        gap: 24px;
        margin-top: 16px;
    }
    .histogram-legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 13px;
        color: var(--gray-600);
    }
    .histogram-legend-color {
        width: 16px;
        height: 16px;
        border-radius: 4px;
    }


    .performers-list {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 24px;
        margin-top: 16px;
    }
    .performer-card {
        background: linear-gradient(135deg, rgba(248, 250, 252, 0.8) 0%, rgba(241, 245, 249, 0.8) 100%);
        border: 1px solid rgba(16, 185, 129, 0.2);
        border-radius: 8px;
        padding: 16px;
        box-shadow: var(--shadow-sm);
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 16px;
    }
    .performer-rank {
        font-size: 14px;
        font-weight: 600;
        color: var(--gray-700);
        background: rgba(16, 185, 129, 0.1);
        border-radius: 4px;
        padding: 4px 8px;
        margin-bottom: 8px;
    }
    .performer-name {
        font-size: 16px;
        font-weight: 600;
        color: var(--gray-900);
        margin-bottom: 4px;
    }
    .performer-score {
        font-size: 14px;
        color: var(--gray-700);
        margin-bottom: 8px;
    }
    .performer-dist-chart {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .performer-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }


    .output-option.hide {
        opacity: 0;
        transform: scale(0.9);
        pointer-events: none;
        transition: all 0.4s ease;
        filter: blur(2px);
    }

    .query-description {
        font-size: 13px;
        color: var(--gray-700);
        font-weight: 500;
        margin-bottom: 8px;
        line-height: 1.5;
        letter-spacing: 0.02em;
    }

    .output-description {
        font-size: 11px;
        color: var(--gray-500);
        font-weight: 400;
        margin-bottom: 8px;
        line-height: 1.4;
        letter-spacing: 0.01em;
    }

    /* Loading and empty states */
    .loading-container {
        text-align: center;
        padding: 40px 20px;
    }
    
    .loading-progress {
        width: 200px;
        height: 4px;
        background: var(--gray-200);
        border-radius: 2px;
        margin: 0 auto 16px;
        overflow: hidden;
    }
    
    .loading-progress-bar {
        width: 30%;
        height: 100%;
        background: var(--primary, #6366f1);
        animation: loading-move 2s infinite;
    }
    
    @keyframes loading-move {
        0% { transform: translateX(-100%); }
        100% { transform: translateX(400%); }
    }
    
    .loading-text {
        color: var(--gray-600);
        font-size: 14px;
    }
    
    .empty-state {
        text-align: center;
        padding: 40px 20px;
        color: var(--gray-600);
    }
    
    .empty-state h3 {
        color: var(--gray-900);
        margin-bottom: 8px;
    }
    
    .knowledge-analysis-table {
        width: 100%;
        border-collapse: collapse;
        margin-bottom: 18px;
        font-size: 14px;
    }
    
    .knowledge-analysis-table th,
    .knowledge-analysis-table td {
        padding: 8px 12px;
        border: 1px solid var(--gray-200);
        text-align: left;
    }
    
    .knowledge-analysis-table th {
        background: #FAFAFA;
        font-weight: 600;
    }
    
    /* Model name cell styling */
    .model-name-cell {
        background-color: var(--gray-50);
        font-weight: 600;
        color: var(--gray-700);
        text-align: left;
        padding-left: 10px;
        font-size: 11px;
        white-space: nowrap;
        max-width: 200px;
        overflow: hidden;
        text-overflow: ellipsis;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    }
    
    .chart-cell {
        padding: 4px 8px;
    }
    
    .no-data {
        text-align: center;
        color: var(--gray-500);
        font-style: italic;
        font-size: 11px;
    }
    
    /* Analysis stats cards */
    .analysis-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
    }
    
    .stat-card {
        background: white;
        border: 2px solid var(--gray-200);
        border-radius: 8px;
        padding: 20px;
        text-align: center;
        box-shadow: var(--shadow-sm);
    }
    
    .stat-card.positive {
        border-color: #28a745;
        background-color: #f8fff9;
    }
    
    .stat-card.negative {
        border-color: #dc3545;
        background-color: #fff8f8;
    }
    
    .stat-card.neutral {
        border-color: var(--gray-400);
        background-color: var(--gray-50);
    }
    
    .stat-number {
        font-size: 28px;
        font-weight: 700;
        color: var(--gray-900);
        margin-bottom: 5px;
    }
    
    .stat-label {
        font-size: 14px;
        color: var(--gray-600);
        font-weight: 500;
    }
    
    .model-name {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 18px;
    }
    
    /* Template header styles */
    .template-header-with-description {
        margin-bottom: 15px;
    }
    
    .template-header-link {
        color: var(--gray-900);
        text-decoration: none;
        transition: color 0.2s;
    }
    
    .template-header-link:hover {
        color: var(--primary);
        text-decoration: underline;
    }
    
    .template-description-text {
        margin: 0;
        color: var(--gray-600);
        font-size: 13px;
        font-style: italic;
        line-height: 1.4;
    }
    
    /* Knowledge Analysis Container */
    .knowledge-analysis-container {
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 20px;
    }
    
    /* Dynamic Stats Text */
    .dynamic-stats {
        background: linear-gradient(135deg, 
            rgba(99, 102, 241, 0.05) 0%,
            rgba(168, 85, 247, 0.03) 50%,
            rgba(59, 130, 246, 0.05) 100%);
        border: 1px solid rgba(99, 102, 241, 0.1);
        border-radius: 12px;
        padding: 20px 28px;
        margin-bottom: 48px;
        font-size: 16px;
        line-height: 1.8;
        color: var(--gray-700);
    }
    
    /* Winner showcase */
    .winner-showcase {
        background: linear-gradient(135deg, 
            rgba(16, 185, 129, 0.05) 0%,
            rgba(34, 197, 94, 0.03) 100%);
        border: 1px solid rgba(16, 185, 129, 0.2);
        border-radius: 12px;
        padding: 24px;
        margin: 32px 0;
    }
    
    .winner-showcase h4 {
        color: var(--gray-900);
        font-size: 16px;
        font-weight: 600;
        margin: 0 0 16px 0;
    }
    
    .winner-example {
        display: flex;
        align-items: center;
        gap: 24px;
        margin-bottom: 16px;
    }
    
    .winner-model-name {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-weight: 600;
        font-size: 14px;
        color: var(--gray-900);
        min-width: 120px;
    }
    
    .winner-category {
        font-size: 13px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: var(--gray-600);
        min-width: 180px;
    }
    
    .winner-bar-chart {
        flex: 1;
        max-width: 400px;
    }
    
    .winner-description {
        font-size: 14px;
        color: var(--gray-600);
        line-height: 1.6;
        margin-top: 12px;
    }
    
    /* Expandable table */
    .table-controls {
        display: flex;
        justify-content: center;
        margin-top: 16px;
        margin-bottom: -1px;
    }
    
    .expand-button {
        background: #FAFAFA;
        border: 1px solid var(--gray-200);
        border-bottom: none;
        border-radius: 8px 8px 0 0;
        padding: 8px 20px;
        font-size: 13px;
        font-weight: 500;
        color: var(--gray-700);
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: 8px;
    }
    
    .expand-button:hover {
        background: var(--gray-50);
        color: var(--gray-900);
    }
    
    .expand-icon {
        width: 16px;
        height: 16px;
        transition: transform 0.3s ease;
    }
    
    .expand-button.expanded .expand-icon {
        transform: rotate(180deg);
    }
    
    .knowledge-analysis-table tbody tr.hidden-row {
        display: none;
    }
    
    .knowledge-analysis-table tbody tr.hidden-row.show {
        display: table-row;
    }
    
    .table-fade {
        position: relative;
    }
    
    .table-fade::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 60px;
        background: linear-gradient(to bottom, transparent, rgba(255, 255, 255, 0.9));
        pointer-events: none;
        transition: opacity 0.3s ease;
    }
    
    .table-fade.expanded::after {
        opacity: 0;
    }
    
    .stat-value {
        display: inline-block;
        font-weight: 700;
        color: var(--gray-900);
        background: rgba(99, 102, 241, 0.1);
        border-radius: 6px;
        margin: 0 2px;
        padding: 2px 6px;
        font-size: inherit;
    }
    
    .model-highlight {
        display: inline-block;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-weight: 600;
        background: rgba(124, 58, 237, 0.1);
        color: #7c3aed;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: inherit;
    }
    
    .model-lowlight {
        display: inline-block;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-weight: 600;
        background: rgba(220, 53, 69, 0.1);
        color: #dc3545;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: inherit;
    }
    
    /* Remove container styling from knowledge tables */
    .knowledge-analysis-table-wrapper {
        margin-bottom: 48px;
    }
    
    .knowledge-analysis-table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        font-size: 13px;
        background: #FAFAFA;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
    }
    
    .knowledge-analysis-table th {
        background: #FAFAFA;
        padding: 16px 20px;
        text-align: left;
        font-weight: 600;
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: var(--gray-600);
        border-bottom: 1px solid var(--gray-200);
    }
    
    .knowledge-analysis-table td {
        padding: 12px 20px;
        border-bottom: 1px solid var(--gray-100);
        vertical-align: middle;
    }
    
    .knowledge-analysis-table tbody tr:last-child td {
        border-bottom: none;
    }
    
    .knowledge-analysis-table tbody tr:hover {
        background: rgba(99, 102, 241, 0.02);
    }
    
    /* Template header without box */
    .template-section-header {
        margin-bottom: 24px;
        padding-bottom: 16px;
        border-bottom: 2px solid var(--gray-100);
    }
    
    .template-section-title {
        font-size: 20px;
        font-weight: 600;
        color: var(--gray-900);
        margin: 0 0 8px 0;
    }
    
    .template-section-description {
        font-size: 14px;
        color: var(--gray-600);
        font-style: italic;
        margin: 0;
    }
    
    /* Enhanced bar chart styles */
    .bar-chart-container {
        width: 100%;
        height: 24px;
        background: var(--gray-100);
        border-radius: 12px;
        overflow: hidden;
        position: relative;
    }
    
    .bar-chart-segments {
        display: flex;
        height: 100%;
        width: 100%;
    }
    
    .bar-segment {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 11px;
        font-weight: 600;
        position: relative;
        transition: all 0.2s ease;
        cursor: pointer;
    }
    
    .bar-segment:hover {
        filter: brightness(1.1);
        z-index: 10;
    }
    
    .bar-segment.knowledge-limited {
        background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
        color: #856404;
    }
    
    .bar-segment.knowledge-moderate {
        background: linear-gradient(135deg, #d1ecf1 0%, #bee5eb 100%);
        color: #0c5460;
    }
    
    .bar-segment.knowledge-extensive {
        background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
        color: #155724;
    }
    
    .bar-segment.knowledge-na {
        background: linear-gradient(135deg, #e2e3e5 0%, #d6d8db 100%);
        color: #383d41;
    }
    
    .bar-segment.knowledge-no-result,
    .bar-segment.knowledge-failed {
        background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
        color: #721c24;
    }
    
    .bar-number {
        font-size: 12px;
        font-weight: 700;
        text-shadow: 0 1px 2px rgba(255,255,255,0.5);
        opacity: 0;
        transition: opacity 0.2s ease;
    }
    
    /* Quality score styling */
    .quality-score-cell {
        text-align: center;
        font-weight: 700;
        font-size: 14px;
    }
    
    .quality-score-value {
        display: inline-block;
        padding: 4px 12px;
        border-radius: 20px;
        background: linear-gradient(135deg, 
            rgba(99, 102, 241, 0.1) 0%,
            rgba(168, 85, 247, 0.08) 100%);
        color: var(--primary);
        cursor: help;
        transition: all 0.2s ease;
    }
    
    .quality-score-value:hover {
        background: linear-gradient(135deg, 
            rgba(99, 102, 241, 0.2) 0%,
            rgba(168, 85, 247, 0.15) 100%);
        transform: scale(1.05);
    }
    
    /* Compact Score Example */
    .score-example-compact {
        background: linear-gradient(135deg, 
            rgba(147, 51, 234, 0.05) 0%,
            rgba(99, 102, 241, 0.03) 100%);
        border: 1px solid rgba(147, 51, 234, 0.15);
        border-radius: 12px;
        padding: 20px;
        margin: 32px 0;
        font-size: 13px;
    }
    
    .score-example-header {
        display: flex;
        align-items: center;
        gap: 16px;
        margin-bottom: 16px;
        padding-bottom: 12px;
        border-bottom: 1px solid rgba(147, 51, 234, 0.1);
    }
    
    .score-model-name {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-weight: 600;
        color: var(--gray-900);
        background: rgba(147, 51, 234, 0.1);
        padding: 4px 12px;
        border-radius: 6px;
        font-size: 14px;
    }
    
    .score-template-name {
        font-size: 12px;
        color: var(--gray-600);
        background: var(--gray-100);
        padding: 3px 8px;
        border-radius: 4px;
        font-weight: 500;
    }
    
    .score-breakdown-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 16px;
        margin-bottom: 16px;
    }
    
    .score-type-breakdown {
        background: #FAFAFA;
        border: 1px solid var(--gray-200);
        border-radius: 8px;
        padding: 12px;
    }
    
    .score-type-title {
        font-weight: 600;
        color: var(--gray-900);
        margin-bottom: 8px;
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }
    
    .score-items {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-bottom: 8px;
    }
    
    .score-item {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 11px;
        font-weight: 600;
        padding: 3px 8px;
        border-radius: 4px;
        border: 1px solid transparent;
    }
    
    .score-item.good {
        background: rgba(16, 185, 129, 0.1);
        color: #059669;
        border-color: rgba(16, 185, 129, 0.2);
    }
    
    .score-item.caution {
        background: rgba(245, 158, 11, 0.1);
        color: #d97706;
        border-color: rgba(245, 158, 11, 0.2);
    }
    
    .score-item.bad {
        background: rgba(239, 68, 68, 0.1);
        color: #dc2626;
        border-color: rgba(239, 68, 68, 0.2);
    }
    
    .score-item.worst {
        background: rgba(127, 29, 29, 0.1);
        color: #991b1b;
        border-color: rgba(127, 29, 29, 0.2);
    }
    
    .score-subtotal {
        font-weight: 600;
        color: var(--gray-700);
        font-size: 12px;
        text-align: right;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    }
    
    .score-final {
        background: #FAFAFA;
        border: 2px solid rgba(147, 51, 234, 0.2);
        border-radius: 8px;
        padding: 12px 16px;
        text-align: center;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
    }
    
    .score-calculation {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 14px;
        color: var(--gray-700);
        font-weight: 500;
    }
    
    .score-result {
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 18px;
        font-weight: 700;
        color: var(--gray-900);
        background: rgba(147, 51, 234, 0.1);
        padding: 6px 12px;
        border-radius: 6px;
    }
    
    @media (max-width: 768px) {
        .score-breakdown-grid {
            grid-template-columns: 1fr;
            gap: 12px;
        }
        
        .score-example-header {
            flex-direction: column;
            align-items: flex-start;
            gap: 8px;
        }
        
        .score-final {
            flex-direction: column;
            gap: 8px;
        }
    }

    .article-container > .article-main > article > p:last-of-type {
        margin-bottom: 10px !important;
    }

    .performer-score strong {
        font-weight: 700;
        color: var(--gray-900);
    }

    .worst-performer-section {
        margin: 32px 0;
    }
    .performer-card.worst .performer-rank {
        background: rgba(239, 68, 68, 0.1);
        color: #dc2626;
    }

    .histogram-chart {
        display: flex;
        align-items: flex-end;
        gap: 2px;
        height: 200px;
        border-bottom: 2px solid var(--gray-300);
        padding-bottom: 4px;
        margin-bottom: 8px;
    }
    .histogram-bin {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-end;
        text-align: center;
    }
    .histogram-bar {
        width: 90%;
        background: linear-gradient(to top, var(--primary), #a78bfa);
        border-radius: 4px 4px 0 0;
        color: white;
        font-size: 12px;
        font-weight: 600;
        line-height: 1.5;
        padding: 4px 2px;
        transition: all 0.2s ease;
        position: relative;
        min-height: 20px;
        display: flex;
        align-items: flex-start;
        justify-content: center;
    }
    .histogram-bar.bad { background: linear-gradient(to top, #ef4444, #f87171); }
    .histogram-bar.moderate { background: linear-gradient(to top, #f59e0b, #fcd34d); }
    .histogram-bar.good { background: linear-gradient(to top, #22c55e, #86efac); }
    .histogram-bar:hover {
        filter: brightness(1.1);
    }
    .histogram-label {
        margin-top: 8px;
        font-size: 12px;
        color: var(--gray-600);
    }
    .histogram-legend {
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
        align-items: center;
        margin-bottom: 16px;
    }
    .histogram-legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 13px;
        color: var(--gray-700);
    }
    .histogram-legend-color {
        width: 14px;
        height: 14px;
        border-radius: 4px;
        border: 1px solid rgba(0,0,0,0.1);
    }
    
    /* Correlation bar chart styles from search_correlation */
    .single-bar-chart {
        width: 100%;
        height: 16px;
    }
    
    .single-stacked-bar {
        width: 100%;
        height: 16px;
        display: flex;
        border: 1px solid #dee2e6;
        border-radius: 2px;
        overflow: hidden;
        background: #f8f9fa;
    }
    
    .bar-segment {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        font-weight: 600;
        position: relative;
        min-width: 16px;
    }
    
    .bar-number {
        font-size: 11px;
        font-weight: 700;
        text-shadow: 0 0 2px rgba(255,255,255,0.8);
        z-index: 1;
        pointer-events: none;
    }
    
    .bar-segment.knowledge-limited {
        background-color: #fff3cd;
        color: #856404;
    }
    
    .bar-segment.knowledge-moderate {
        background-color: #d1ecf1;
        color: #0c5460;
    }
    
    .bar-segment.knowledge-extensive {
        background-color: #d4edda;
        color: #155724;
    }
    
    .bar-segment.knowledge-na {
        background-color: #e2e3e5;
        color: #6c757d;
    }
    
    .correlation-value-cell {
        text-align: center;
        font-weight: 700;
        font-size: 11px;
        width: 80px;
        padding: 4px;
    }
    
    .correlation-value.strong-positive {
        color: #28a745;
    }
    
    .correlation-value.moderate-positive {
        color: #17a2b8;
    }
    
    .correlation-value.weak {
        color: #6c757d;
    }
    
    .correlation-value.moderate-negative {
        color: #fd7e14;
    }
    
    .correlation-value.strong-negative {
        color: #dc3545;
    }
    
    /* Fix table backgrounds in section-callout sections */
    .section-callout .knowledge-analysis-table {
        background: #FAFAFA !important;
    }
    
    .section-callout .knowledge-analysis-table th {
        background: #FAFAFA !important;
    }
    
    .section-callout .knowledge-analysis-table tbody tr:hover {
        background: rgba(99, 102, 241, 0.02) !important;
    }

</style>
{% endblock %}

{% block content %}
<!-- Background Animation -->
<canvas id="background-canvas" class="background-canvas"></canvas>

<!-- Main Content with proper spacing -->
<div class="main-content">
<!-- Hero Header - Full Width -->
<header class="hero-header">
    <canvas id="hero-canvas" class="hero-canvas"></canvas>
    <div class="hero-content">
        <h1 class="hero-title">Assessing LLM Knowledge Calibration for Microbial Taxonomy</h1>
            <div class="hero-author hero-author--purple">by Philipp C. Mnch</div>
        <p class="hero-subtitle">
            A dual test set of synthetic species and verified bacteria reveals when the model invents and when it defers.
        </p>
    </div>
</header>

<div class="article-container">
    <!-- Main Content -->
    <div class="article-main">
        <!-- Article Content -->
        <article class="article-content">
        <!-- Purpose Section -->
        <section id="purpose" class="article-section">
            <h1 class="main-section-title">Hallucination Check: Fictional Strain Names</h1>
            
            <div class="article-text">
                <p>
                    <p>Microbial informationlike whether Pseudomonas putida degrades specific chemicalsis dispersed across many databases, research papers, and supplemental documents. There's no single comprehensive source, making it difficult and time-consuming to compile accurate annotations for microbial databases.
                    </p>

                    <p> 
                        In practice, microbiologists gather strain-level details from a fragmented landscape: taxonomic registries (NCBI, LPSN), commercial culture collections (ATCC, DSMZ), hidden genome annotations, and thousands of scientific papers. With no centralized, consistently formatted repository, even routine checkssuch as verifying antibiotic resistance or metabolic traitsrequire extensive manual cross-referencing.
                    </p>


               
                
                    <div class="callout callout-definition">
                        <div class="callout-header">Definition</div>
                        <div class="callout-content">
                            <strong>Binomial names</strong> are the universal "first&nbsp;and&nbsp;last names" of every micro-organism, inherited from Linnaean taxonomy. 
                            The first word (the <em>genus</em>) is always capitalised and groups together species that share a close evolutionary lineage<em>Escherichia</em>, for example, gathers gut-dwelling rods such as <em>E.&nbsp;coli</em> and <em>E.&nbsp;albertii</em>. 
                            The second word (the <em>species epithet</em>) is lowercase and distinguishes one member of the genus from another. 
                            Written in italics and fixed in Latin-style form, the pair becomes a legally recognised label once it is published in the <em>International Journal of Systematic and Evolutionary Microbiology</em> and entered into registries such as NCBI or LPSN. 
                            Because the format is rigid and globally standardised, even a newly coined species should "look right" at a glance; that visual regularity is exactly what makes it possible for an LLMand sometimes a human readerto mistake a well-crafted fiction for an authentic taxon.
                        </div>
                    </div>
    


                    <p>AI language models have absorbed extensive scientific literature and could potentially streamline this consolidation process. However, they often write with convincing authority even when evidence is thin, risking the introduction of incorrect detailsa phenomenon known as hallucination. This frequently occurs after Reinforcement Learning from Human Feedback (RLHF) training, where models are rewarded for sounding helpful and confident, even if "I don't know" would be more accurate. In microbiology, confident fabrications can be more harmful than no answer at all.
                    </p>

                    <div class="callout callout-definition">
                        <div class="callout-header">Definition</div>
                        <div class="callout-content">
                             <b> Hallucination (LLM):</b> A response that looks plausible and is delivered with full confidence, yet is wholly or partly fabricated and unsupported by any real source. This is especially problematic in scientific settings, where downstream decisions rely on accuracy.
                        </div>
                    </div>


                    <p> Understanding how often a model fabricates traits for nonexistent organisms is crucial before relying on its summaries for real-world microbial annotation
                    </p>
    
                 
                    
                </p>
            
                <p>
                    To probe where certainty ends and storytelling begins, we built a library of 200 wholly invented strain names, arranged along a realism gradient. At the playful end sit English mash-ups such as Crimson Horizon or Silver Pinelabels no taxonomist would buy. At the serious end are Latin-looking binomials like Luminaricella splendens that follow every rule of bacterial nomenclature. By asking the same set of questions across this spectrum, we can see exactly when an LLM's confidence tips into hallucination.
                </p>

                <div class="callout callout-definition callout-compact">
                    <div class="callout-content">
                        <div class="callout-content">
                            <b> How we minted our "fake bugs":</b> We programmatically stitched together Latin roots and taxonomic endings to forge binomial names that look legitimate but are absent from NCBI, LPSN, ATCC, and every other recognised database. This synthetic, ground-truth negative set lets us ask: can an LLM tell an authentic species from a skilfully fabricated one?
                        <div class="species-animation-container">
                            
                            <div class="species-animated">
                                <span class="genus-part" id="genus-text">Escherichia</span>
                                <span class="species-part" id="species-text">coli</span>
                            </div>
                            <div class="animation-label" id="animation-label">Real bacterial species</div>
                        </div>
                    </div>
                </div>

            </div>
                <p>
                    We repeated the name-minting process four times, each run following a different recipe and yielding fifty strains. The first batch combines plain English words, producing labels that no one would confuse for Latin. The second stitches together two random Latin roots, giving every name a classical ring even though the genus is fictitious. In the third set we keep a real, well-known genus and attach a fabricated species epithet, creating hybrids that look half legitimate. The fourth flips the trick: an invented genus is paired with a real species epithet, completing a spectrum that spans obviously fake to taxonomist-plausible. The animation below flips through the four collections in sequence, showing how the linguistic realism ratchets up across the 200-name library.
                </p>


  <!-- Animation Summary Callout with Animation -->
  <div class="callout callout-template">
    <div class="callout-content">
      <!-- Animated Species Generation Visualization -->
      <div class="flow-diagram-wrapper">
        <div class="flow-diagram" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 24px; justify-items: center;">
          <!-- Set 1: Two English Words -->
          <div class="flow-box" style="width: 280px; text-align: center;">
            <div class="query-title">Set 1</div>
            <div class="output-description">2 random English words</div>
            <div class="mini-boxes" id="set1-miniboxes" style="display:flex;justify-content:center;gap:2px;margin-bottom:8px;"></div>
            <div class="species-animated" id="set1-species" style="font-size: 18px;">Blue Apple</div>
            <div class="animation-label" id="set1-label">1/50</div>
          </div>
          <!-- Set 2: Two Latin Words -->
          <div class="flow-box" style="width: 280px; text-align: center;">
            <div class="query-title">Set 2</div>
            <div class="output-description">2 random Latin words</div>
            <div class="mini-boxes" id="set2-miniboxes" style="display:flex;justify-content:center;gap:2px;margin-bottom:8px;"></div>
            <div class="species-animated" id="set2-species" style="font-size: 18px;">Corpus magnum</div>
            <div class="animation-label" id="set2-label">1/50</div>
          </div>
          <!-- Set 3: Real genus + artificial species -->
          <div class="flow-box" style="width: 280px; text-align: center;">
            <div class="query-title">Set 3</div>
            <div class="output-description">Real genus + artificial (Latin) species</div>
            <div class="mini-boxes" id="set3-miniboxes" style="display:flex;justify-content:center;gap:2px;margin-bottom:8px;"></div>
            <div class="species-animated" id="set3-species" style="font-size: 18px;">Escherichia phantasmus</div>
            <div class="animation-label" id="set3-label">1/50</div>
          </div>
          <!-- Set 4: Artificial genus + real species -->
          <div class="flow-box" style="width: 280px; text-align: center;">
            <div class="query-title">Set 4</div>
            <div class="output-description">Artificial genus + real (Latin) species</div>
            <div class="mini-boxes" id="set4-miniboxes" style="display:flex;justify-content:center;gap:2px;margin-bottom:8px;"></div>
            <div class="species-animated" id="set4-species" style="font-size: 18px;">Pseudobacterium coli</div>
            <div class="animation-label" id="set4-label">1/50</div>
          </div>
        </div>
      </div>
      
      <div style="margin-top: var(--spacing-element);">
        <strong>200 total transformations</strong>  50 for each set. The animation above demonstrates how we systematically combine real and artificial genus/species names to create a gradient of believability, from completely real bacteria to entirely fictional ones.
      </div>
    </div>
  </div>

  <p>
    To gauge how much an LLM "knows" about each invented microbe, we run the same handful of questions against every name in the library. Because the wording never changesonly the species placeholderthe answers are directly comparable. For each reply we record whether the model offers concrete details, hedges with uncertainty, or immediately admits it has no information. Summarising those outcomes across our realism gradient tells us exactly when the model starts hallucinating and when it sensibly says "I'm not sure."
</p>


    <div class="callout callout-definition callout-compact">
    <div class="callout-content">
      A <strong>query template</strong> is a fixed question format used to test a language model's knowledge, where only the <span style="background:var(--gray-200);border-radius:3px;padding:1px 5px;font-family:monospace;">species name</span> is replaced each time. For example:
      <div class="template-skeleton" style="margin:12px 0 0 0;padding:10px 14px;background:var(--gray-50);border-radius:5px;display:inline-block;min-width:320px;">
        <span style="color:var(--gray-600);">"What do you know about</span>
        <span class="skeleton species-skeleton" style="display:inline-block;width:110px;height:1.1em;background:linear-gradient(90deg,#e0e7ff 30%,#f3f4f6 60%,#e0e7ff 100%);border-radius:3px;vertical-align:middle;animation:skeleton-loading 1.2s infinite linear;">&nbsp;</span>
        <span style="color:var(--gray-600);">?"</span>
      </div>
      <style>
        @keyframes skeleton-loading {
          0% { background-position: -120px 0; }
          100% { background-position: 120px 0; }
        }
        .template-skeleton .species-skeleton {
          background-size: 220px 100%;
        }
      </style>
    </div>
  </div>



<p>
    Rather than grading a free-form essay, we ask the model to pick one of three
    machine-readable labels that capture how much information it claims to have:
    <strong>limited</strong>, <strong>intermediate</strong>, or
    <strong>extensive</strong>.  Using discrete categories keeps the output
    easy to parse and compare across 200 fictional names.
</p>



<p>
    We actually send <em>three</em> variants of the same question to each LLM:
    the first template forces a choice among the three knowledge levels and <em>does not</em>
    offer an "I don't know" escape hatch.  Templates&nbsp;2 and&nbsp;3 do include an
    <code>NA</code> option but differ in how much context they supply: Template&nbsp;2 is a short,
    one-line prompt, while Template&nbsp;3 adds brief definitions of what
    <strong>limited</strong>, <strong>intermediate</strong>, and
    <strong>extensive</strong> should cover.  Comparing answers across the
    trio shows whether the model's willingness to hallucinate drops when we give
    it an explicit path to refuse and when we clarify the scoring criteria.
</p>


<div class="callout callout-definition">
    <div class="callout-header">Knowledge-level keys</div>
    <div class="callout-content">
        <strong>Limited&nbsp;</strong>  "I know only basic facts or context."<br>
        <strong>Intermediate&nbsp;</strong>  "I can give several specific details."<br>
        <strong>Extensive&nbsp;</strong>  "I can provide in-depth, reference-level information."<br>
        <em>NA</em>  "I don't know / no information available." (Allowed only in Templates&nbsp;2&nbsp;and&nbsp;3)
    </div>
</div>

<p>
    Each query template is more than a single line of text: it is a three-part bundle that keeps the evaluation
    machine-readable. The <strong>system prompt</strong> sets the assistant's role,
    the <strong>user prompt</strong> holds the species placeholder, and a compact
    <strong>validation&nbsp;JSON</strong> lists the only labels the model is allowed to return
    (<code>limited</code>, <code>intermediate</code>, <code>extensive</code>,
    and&nbsp;<code>NA</code>).&nbsp;We ship three such bundles. Template&nbsp;1 omits the
    <em>NA</em> escape hatch, forcing a knowledge claim; Templates&nbsp;2 and&nbsp;3 keep the same labels
    but differ in how fully they describe each category to the model.
</p>


<!--  Wide interactive template viewer  -->
<div class="callout callout-template" id="tinyTemplateBrowser">
    <div class="callout-header">
        Browse Knowledge Templates
    </div>

    <!-- Loading state -->
    <div id="templateLoadingState" style="text-align:center;padding:20px;color:var(--gray-600);">
        <div style="margin-bottom:8px;">Loading templates...</div>
        <div style="width:100px;height:4px;background:var(--gray-200);margin:0 auto;border-radius:2px;overflow:hidden;">
            <div style="width:30%;height:100%;background:var(--primary,#6366f1);animation:loadingMove 2s infinite;"></div>
        </div>
    </div>

    <!-- Controls (hidden initially) -->
    <div id="templateControls" class="modern-form-container" style="display:none;">
        <!-- Template selector -->
        <div class="modern-form-control">
            <label class="modern-form-label">
                Template
            </label>
            <select id="templateSelect" class="modern-select">
                <!-- Options will be populated by JavaScript -->
            </select>
        </div>

        <!-- Part selector -->
        <div class="modern-form-control">
            <label class="modern-form-label">
                Template Part
            </label>
            <div id="partButtons" class="modern-button-group">
                <button data-part="system"     class="modern-button active">System</button>
                <button data-part="user"       class="modern-button">User</button>
                <button data-part="validation" class="modern-button">Validation</button>
            </div>
        </div>
    </div>

    <!-- Content pane (hidden initially) -->
    <pre id="templatePane"
         style="display:none;background:#f8f9fa;border:1px solid var(--gray-200);
                padding:16px;max-height:320px;overflow-y:auto;
                font-size:12px;line-height:1.45;
                font-family:'Menlo','Monaco','Ubuntu Mono',monospace;"></pre>

    <!-- Error state (hidden initially) -->
    <div id="templateErrorState" style="display:none;text-align:center;padding:20px;color:var(--gray-600);">
        <div style="margin-bottom:8px;color:#dc3545;">Failed to load templates</div>
        <div style="font-size:13px;">Please check if knowledge templates are configured in your system.</div>
    </div>
</div>

<script>
    /* ------- Real template viewer data loader ------- */
    let knowledgeTemplates = {};
    let templateNames = [];

    // Load real knowledge templates from the API
    async function loadKnowledgeTemplates() {
        try {
            const response = await fetch('/api/available_knowledge_templates');
            const data = await response.json();

            if (!data.success) {
                throw new Error(data.error || 'Failed to load templates');
            }

            knowledgeTemplates = data.templates;
            templateNames = Object.keys(knowledgeTemplates);

            if (templateNames.length === 0) {
                showErrorState('No knowledge templates found');
                return;
            }

            // Populate the template selector
            const sel = document.getElementById('templateSelect');
            sel.innerHTML = '';
            templateNames.forEach((templateName, index) => {
                const option = document.createElement('option');
                option.value = templateName;
                option.textContent = knowledgeTemplates[templateName].display_name;
                sel.appendChild(option);
            });

            // Show the controls and hide loading
            document.getElementById('templateLoadingState').style.display = 'none';
            document.getElementById('templateControls').style.display = 'flex';
            document.getElementById('templatePane').style.display = 'block';

            // Setup event listeners
            setupEventListeners();

            // Render the first template
            render();

        } catch (error) {
            console.error('Error loading knowledge templates:', error);
            showErrorState(error.message);
        }
    }

    function showErrorState(message) {
        document.getElementById('templateLoadingState').style.display = 'none';
        document.getElementById('templateControls').style.display = 'none';
        document.getElementById('templatePane').style.display = 'none';

        const errorDiv = document.getElementById('templateErrorState');
        errorDiv.style.display = 'block';
        errorDiv.querySelector('div').textContent = message;
    }

    function setupEventListeners() {
        const sel = document.getElementById('templateSelect');
        const buttons = document.querySelectorAll('#partButtons .modern-button');

        sel.addEventListener('change', render);

        buttons.forEach(btn => {
            btn.addEventListener('click', () => {
                buttons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                render();
            });
        });
    }

    function render() {
        const sel = document.getElementById('templateSelect');
        const pane = document.getElementById('templatePane');
        const activeButton = document.querySelector('#partButtons .modern-button.active');

        if (!sel.value || !knowledgeTemplates[sel.value] || !activeButton) {
            return;
        }

        const template = knowledgeTemplates[sel.value];
        const activePart = activeButton.dataset.part;

        let content = '';

        switch (activePart) {
            case 'system':
                content = template.system.content;
                break;
            case 'user':
                content = template.user.content;
                break;
            case 'validation':
                if (template.validation && template.validation.content) {
                    content = template.validation.content;
                } else {
                    content = '// No validation configuration found for this template\n// Add a validation config file to enable response validation';
                }
                break;
            default:
                content = 'Unknown template part';
        }

        pane.textContent = content;
    }

    // Load templates when the page loads
    document.addEventListener('DOMContentLoaded', function() {
        // Small delay to ensure other scripts have initialized
        setTimeout(loadKnowledgeTemplates, 100);
    });
</script>

<p>
    With our 200 fabricated names in hand, we run a fully automated loop:  
    each name is inserted into every query template, each template is sent to every
    model exposed through the <strong>OpenRouter&nbsp;API</strong>, and every reply
    is stored with a timestamp and model ID.  A small validation script then checks
    whether the response is one of the allowed labels
    (<code>limited</code>, <code>intermediate</code>, <code>extensive</code>, or&nbsp;<code>NA</code>)
    and scores it against the ground truth (which, for fictional species, should be
    <code>NA</code> or <code>limited</code>).
</p>

<style>
@keyframes loadingMove {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(400%); }
}

/* Top performers section - transparent background */
.top-performers-section {
    padding: 0;
    margin: 0;
    position: relative;
    z-index: 1;
}

/* Correlation performer cards - no background */
.performer-card-simple {
    background: transparent !important;
    border: 1px solid var(--gray-200) !important;
    border-radius: 8px;
    padding: 16px;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 16px;
    box-shadow: none !important;
}

.performer-card-simple:hover {
    background: transparent !important;
    border-color: var(--gray-300) !important;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05) !important;
    transform: none !important;
}

.performer-card-simple .performer-rank {
    font-size: 14px;
    font-weight: 600;
    color: var(--gray-700);
    background: var(--gray-100) !important;
    border-radius: 4px;
    padding: 4px 8px;
    margin-bottom: 8px;
}

.performer-card-simple .performer-name {
    font-size: 16px;
    font-weight: 600;
    color: var(--gray-900);
    margin-bottom: 4px;
}

.performer-card-simple .performer-score {
    font-size: 14px;
    color: var(--gray-700);
    margin-bottom: 8px;
}

.performer-card-simple .performer-dist-chart {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
}
</style>
           
           
        </section>
        </article>
    </div>
    
    <!-- Sidebar for the section above -->
    <aside class="article-sidebar">
        <!-- Paper Info Card -->
        <div class="paper-info-card">
            <h3>Paper Info</h3>
            <ul class="paper-info-list">
                <li><strong>Title:</strong> Comparative Assessment of Large Language Models for Microbial Phenotype Annotation</li>
                <li><strong>Authors:</strong> P. C. Mnch*, N. Safaei, R. Mreches, M. Binder, Y. Han, G. Robertson, E. A. Franzosa, C. Huttenhower, A. C. McHardy*</li>
                <li><strong>DOI:</strong> <a href="https://doi.org/10.1234/llm-bioeval.2024" target="_blank">10.1234/llm-bioeval.2024</a></li>
            </ul>
        </div>
    </aside>
</div>



<!-- Experimental Flow Diagram (Full-width breakout) -->
<section class="section-callout section-callout--purple">
    <div class="section-callout__content">
        <div class="section-callout__header">
            <h3 class="section-callout__title">Hallucination Detection Process</h3>
            <p class="section-callout__text">Our systematic approach to testing whether language models can distinguish between real and fictional bacterial species by analyzing their responses to carefully crafted queries.</p>
        </div>
        <div class="flow-diagram-wrapper">
        <div class="flow-diagram">
            <!-- Input Box -->
            <div class="flow-box flow-input">
                <div class="flow-species">Pseudobacterium imaginarius</div>
                <div class="flow-label">Completely fictional species</div>
            </div>
            
            <!-- Arrow 1 -->
            <div class="flow-arrow">
                <svg width="60" height="40" viewBox="0 0 60 40" fill="none">
                    <path d="M5 20 L45 20 M45 20 L38 13 M45 20 L38 27" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </div>
            
            <!-- Query Box -->
            <div class="flow-box flow-query">
                <div class="query-title">LLM Query</div>
                <div class="output-description">Fictional species embedded in queries<br>asking models to assess their knowledge level</div>
                <div class="query-templates">
                    <div class="query-template" data-query="1">
                        <span class="template-number">Q1</span>
                        <span class="template-type">no NA option</span>
                    </div>
                    <div class="query-template" data-query="2">
                        <span class="template-number">Q2</span>
                        <span class="template-type">with NA option short query</span>
                    </div>
                    <div class="query-template" data-query="3">
                        <span class="template-number">Q3</span>
                        <span class="template-type">with NA verbose query</span>
                    </div>
                </div>
            </div>
            
            <!-- Arrow 2 -->
            <div class="flow-arrow">
                <svg width="60" height="40" viewBox="0 0 60 40" fill="none">
                    <path d="M5 20 L45 20 M45 20 L38 13 M45 20 L38 27" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </div>
            
            <!-- Output Box -->
            <div class="flow-box flow-output">
                <div class="output-title">LLM Response</div>
                <div class="output-description">LLM response of the knowledge level<br>based on the query</div>
                <div class="output-options">
                    <div class="output-option caution" data-level="limited">
                        <span>Limited</span>
                        <div class="expectation-indicator">
                            <span class="expect-q1"></span>
                        </div>
                    </div>
                    <div class="output-option bad" data-level="moderate">
                        <span>Moderate</span>
                        <div class="expectation-indicator">
                            <span class="expect-none"></span>
                        </div>
                    </div>
                    <div class="output-option worst" data-level="extensive">
                        <span>Extensive</span>
                        <div class="expectation-indicator">
                            <span class="expect-none"></span>
                        </div>
                    </div>
                    <div class="output-option good" data-level="na">
                        <span>NA</span>
                        <div class="expectation-indicator">
                            <span class="expect-q2 expect-q3"></span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Legend -->
        <div class="flow-legend">
            <div class="legend-item">
                <span class="legend-symbol">Q1, Q2, Q3</span> = Query types
            </div>
            <div class="legend-item">
                <span class="legend-symbol"></span> = Expected best response
            </div>
            <div class="legend-item">
                <span class="legend-symbol"></span> = Hallucination (bad response)
            </div>
        </div>
    </div>
    </div>
</section>

<!-- Resume article layout -->
<div class="article-container" style="padding-top: 0;">
    <div class="article-main">
        <article class="article-content">
            <div>
                <!-- Score calculation example will be inserted here by JavaScript -->
                <div id="scoreExampleContainer" style="float: right; width: calc(50% + 37px); margin: 0 -75px 24px 24px; clear: right;"></div>

                <div class="article-text">
                    <p style="margin-right: calc(50% + 24px);">To compare models on a single scale we devised a "hallucination-avoidance" score. Each response earns three points if the model refuses or returns <code>NA</code>, two points for a self-declared limited answer, one point for intermediate, and zero when it claims extensive knowledge. We then sum those points for every fictional name and divide by the number of prompts, yielding an average that ranges from 0 (pure fantasy) to 3 (perfect restraint). Thus a model that usually says "I don't know" or "limited" on fake species will hover near the high end of the scale, while one that invents rich detail will drift toward zero.</p>
                </div>
            </div>

            <div id="dynamicStatsText" class="article-text"></div>
            
            <!-- Clear float before section end -->
            <div style="clear: both;"></div>
        </article>
    </div>
</div>

<!-- Top Performing Models Callout Section -->
<section class="section-callout section-callout--purple">
    <div class="section-callout__content">
        <div id="topPerformersContainer"></div>
    </div>
</section>

<!-- Article text between Top Performers and Models Needing Improvement -->
<div class="article-container">
    <div class="article-main">
        <article class="article-content">
            <div class="article-text">
                <p>While the top performers demonstrate a remarkable ability to recognize fictional taxonomy, the models at the opposite end of the spectrum reveal interesting patterns in knowledge assertion behavior. Some models consistently claim intermediate or extensive knowledge about nonexistent species, suggesting they may be generating plausible-sounding information rather than acknowledging uncertainty.</p>
                <p>This disparity in performance highlights the importance of careful model selection for scientific applications. Models that readily fabricate details about fictional organisms may also be prone to hallucinating information about real but lesser-known species, potentially introducing errors into scientific workflows that depend on accurate microbial information.</p>
            </div>
        </article>
    </div>
</div>

<!-- Placeholder for Worst Performer (moved outside article container) -->
<div id="worstPerformerContainer"></div>

<div class="article-container">
    <div class="article-main">
        <article class="article-content">
            <div class="article-text">
                <p>This scoring system allows us to quantify a model's tendency to assert knowledge about non-existent subjects. The visualizations above highlight the top and bottom performers in this test, revealing which models are more likely to falsely claim familiarity with artificial species. These results help identify which models are better calibrated to admit the limits of their knowledge, a crucial characteristic for trustworthy scientific AI.</p>
            </div>
        
        </article>
    </div>
</div>

<!-- Full Results of the Artificial Hallucination Test -->
<div class="article-container">
    <div class="article-main">
        <article class="article-content">
            <h2 class="section-title">Full Results of the Artificial Hallucination Test</h2>
            
            <div class="article-text">
                <p>Below, you can explore the complete results for all evaluated models across each of the three knowledge query templates. These tables allow you to compare every model's performance in detail, see how their responses are distributed, and examine their average quality scores for each template. Use this section to identify trends, outliers, and the overall calibration of each language model when faced with artificial species.</p>
            </div>
        </article>
    </div>
</div>

<!-- Knowledge Analysis Content (moved outside article container) -->
<div id="knowledgeAnalysisContent">
    <div class="loading-container">
        <div class="loading-progress">
            <div class="loading-progress-bar"></div>
        </div>
        <div class="loading-text">Loading knowledge analysis data...</div>
    </div>
</div>

<!-- Knowledge Analysis Results -->
<div class="article-container">
    <div class="article-main">
        <article class="article-content">
            <h1 class="main-section-title">Web-Aligned Knowledge: Real Bacterial Names vs. Google Counts</h1>
            
            <div class="article-text">
                <p>
                    To assess how closely LLMs' self-reported knowledge matches the actual availability of information online, we conducted an analysis using thousands of real bacterial species (such as E. coli and Bacillus subtilis). For each species, we asked LLMs to indicate their knowledge level (Limited, Moderate, or Extensive), then measured how many Google search results exist for that species. By calculating the correlation between the models' confidence and the species' web presence, we can determine how well each model's knowledge claims are calibrated to real-world information. Models that report greater knowledge for well-documented speciesand less for obscure onesdemonstrate better alignment with the information landscape.
                </p>
            </div>
        </article>
    </div>
</div>

<!-- Web-Aligned Knowledge Flow Animation (Full-width Callout) -->
<section class="section-callout section-callout--green">
    <div class="section-callout__content">
        <div class="section-callout__header">
            <h3 class="section-callout__title">Knowledge-Web Alignment Process</h3>
            <p class="section-callout__text">Methodology for measuring how well language model knowledge claims correlate with actual information availability on the web for real bacterial species.</p>
        </div>
        <div class="flow-diagram-wrapper">
            <!-- Grid correlation diagram -->
            <div class="flow-grid">
                <!-- Species input spanning rows -->
                <div class="flow-box flow-input grid-species">
                    <div class="flow-species">Bacillus subtilis</div>
                    <div class="flow-label">Real species</div>
                </div>

                <!-- Row 1: LLM Query path -->
                <div class="flow-arrow" style="grid-row:1; grid-column:2;">
                    <svg width="60" height="40" viewBox="0 0 60 40" fill="none"><path d="M5 30 L35 10 M35 10 L25 10 M35 10 L35 20" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </div>
                <div class="flow-box flow-query" style="grid-row:1; grid-column:3;">
                    <div class="query-title">LLM Query</div>
                    <div class="output-description">Ask model for knowledge level</div>
                </div>
                <div class="flow-arrow" style="grid-row:1; grid-column:4;">
                    <svg width="60" height="40" viewBox="0 0 60 40" fill="none"><path d="M5 20 L45 20 M45 20 L38 13 M45 20 L38 27" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </div>
                <div class="flow-result-box" id="corr-llm-box" style="grid-row:1; grid-column:5;">
                    <div style="font-size: 10px; color: var(--gray-600); margin-bottom: 2px;">knowledge group</div>
                    <span class="output-option caution">Limited</span>
                </div>
                <div class="flow-arrow" style="grid-row:1; grid-column:6;">
                    <svg width="60" height="40" viewBox="0 0 60 40" fill="none"><path d="M5 10 L35 30 M35 30 L25 30 M35 30 L35 20" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </div>

                <!-- Row 2: Web Search path -->
                <div class="flow-arrow" style="grid-row:2; grid-column:2;">
                    <svg width="60" height="40" viewBox="0 0 60 40" fill="none"><path d="M5 10 L35 30 M35 30 L25 30 M35 30 L35 20" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </div>
                <div class="flow-box flow-query" style="grid-row:2; grid-column:3;">
                    <div class="query-title">Web Search</div>
                    <div class="output-description">Count Google search results</div>
                </div>
                <div class="flow-arrow" style="grid-row:2; grid-column:4;">
                    <svg width="60" height="40" viewBox="0 0 60 40" fill="none"><path d="M5 20 L45 20 M45 20 L38 13 M45 20 L38 27" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </div>
                <div class="flow-result-box" id="corr-web-box" style="grid-row:2; grid-column:5;">1.5&nbsp;M</div>
                <div class="flow-arrow" style="grid-row:2; grid-column:6;">
                    <svg width="60" height="40" viewBox="0 0 60 40" fill="none"><path d="M5 30 L35 10 M35 10 L25 10 M35 10 L35 20" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </div>

                <!-- Shared Correlation box -->
                <div class="flow-box flow-output grid-correlation">
                    <div class="output-title">Correlation Analysis</div>
                </div>
            </div>
            
            <!-- Legend -->
            <div class="flow-legend">
                <div class="legend-item">
                    <span class="legend-symbol success">Extensive</span> + <span class="legend-symbol">High count</span> = Good calibration
                </div>
                <div class="legend-item">
                    <span class="legend-symbol caution">Limited</span> + <span class="legend-symbol">Low count</span> = Good calibration
                </div>
                <div class="legend-item">
                    <span class="legend-symbol">Pearson correlation</span> = Measures alignment
                </div>
            </div>
        </div>
    </div>
</section>

<div class="article-container">
    <div class="article-main">
        <article class="article-content">
            <div id="correlationDynamicStats" class="article-text" style="margin-bottom: 48px;">
                <!-- Dynamic text for correlation analysis will be injected here -->
            </div>
        </article>
    </div>
</div>

<!-- Correlation Score Distribution - Full Width -->
<section class="section-wide">
    <div class="section-wide__content">
        <div id="qualityScoreHistogramContainer"></div>
    </div>
</section>

<!-- Standard Article Section after Correlation Score Distribution -->
<div class="article-container">
    <div class="article-main">
        <article class="article-content">
            <div class="article-text">
                <p>
                    The correlation analysis reveals significant differences in how well different language models align their knowledge claims with the actual web presence of bacterial species. Models with higher positive correlations demonstrate better calibration, meaning they appropriately claim more knowledge about well-documented species and less about obscure ones. This alignment indicates a more reliable understanding of their own knowledge boundaries.
                </p>
                <p>
                    The following section highlights the top-performing models in terms of knowledge-web alignment, showing which models best understand the scope and limitations of their microbiological knowledge.
                </p>
            </div>
        </article>
    </div>
</div>

<!-- Real Species Correlation Section -->
<section id="knowledge-web-alignment" class="section-wide">
    <div class="section-wide__content">
        <div class="explanation-section">
            <div class="explanation-grid">
                
            </div>
        </div>
    </div>
</section>

<!-- Top Models Web-Alignment Callout Section -->
<section class="section-callout section-callout--green">
    <div class="section-callout__content">
        <div class="section-callout__header">
            <h3 class="section-callout__title">Top Models - Web-Alignment</h3>
            <p class="section-callout__text">Language models that demonstrate the best alignment between their knowledge claims and actual web presence of bacterial species, showing superior calibration abilities.</p>
        </div>
        <div id="correlationContent">
            <div class="loading-container">
                <div class="loading-progress">
                    <div class="loading-progress-bar"></div>
                </div>
                <div class="loading-text">Loading knowledge-web alignment data...</div>
            </div>
        </div>
    </div>
</section>

<!-- Article text between Top Models and Correlation Visualization -->
<div class="article-container">
    <div class="article-main">
        <article class="article-content">
            <div class="article-text">
                <p>The alignment between model confidence and real-world information availability provides a crucial metric for understanding how well LLMs calibrate their knowledge claims. Models showing strong positive correlations demonstrate an ability to appropriately gauge when they have access to substantial information versus when they should express uncertainty.</p>
                <p>This calibration is particularly important in scientific contexts where the distinction between well-studied organisms like <em>E. coli</em> and obscure or recently discovered species can significantly impact the reliability of model-generated information. The following visualization explores these relationships in greater detail.</p>
            </div>
        </article>
    </div>
</div>



<!-- TOC Active State and Animations Script -->
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Template skeleton loading effect
    const templateShowcases = document.querySelectorAll('.template-showcase');
    templateShowcases.forEach((showcase, index) => {
        showcase.classList.add('loading');
        
        setTimeout(() => {
            showcase.classList.remove('loading');
        }, 1000 + (index * 500));
    });
    
    // Species name animation
    const genusElement = document.getElementById('genus-text');
    const speciesElement = document.getElementById('species-text');
    const labelElement = document.getElementById('animation-label');
    
    if (genusElement && speciesElement && labelElement) {
        const animationSteps = [
            { genus: 'Escherichia', species: 'coli', label: 'Real bacterial species', genusClass: '', speciesClass: '' },
            { genus: 'Escherichia', species: '<div class="skeleton-word" style="width: 80px;"></div>', label: 'Transforming species...', genusClass: '', speciesClass: '' },
            { genus: 'Escherichia', species: 'phantasmus', label: 'Real genus + fictional species', genusClass: '', speciesClass: 'fictional' },
            { genus: '<div class="skeleton-word" style="width: 120px;"></div>', species: 'phantasmus', label: 'Transforming genus...', genusClass: '', speciesClass: 'fictional' },
            { genus: 'Pseudobacterium', species: 'imaginarius', label: 'Completely fictional species', genusClass: 'fictional', speciesClass: 'fictional' }
        ];
        
        let currentStep = 0;
        
        function animateSpecies() {
            const step = animationSteps[currentStep];
            
            genusElement.innerHTML = step.genus;
            speciesElement.innerHTML = step.species;
            labelElement.textContent = step.label;
            
            genusElement.className = 'genus-part ' + step.genusClass;
            speciesElement.className = 'species-part ' + step.speciesClass;
            
            currentStep = (currentStep + 1) % animationSteps.length;
        }
        
        // Start animation after a delay
        setTimeout(() => {
            animateSpecies();
            setInterval(animateSpecies, 3000);
        }, 1500);
    }
    
    // Hero Header Animation
    const heroCanvas = document.getElementById('hero-canvas');
    if (heroCanvas) {
        const ctx = heroCanvas.getContext('2d');
        let width, height;
        let columns = [];
        
        const colors = [
            { r: 99, g: 102, b: 241 },
            { r: 168, g: 85, b: 247 },
            { r: 59, g: 130, b: 246 },
        ];
        
        function resizeHeroCanvas() {
            width = heroCanvas.width = heroCanvas.offsetWidth;
            height = heroCanvas.height = heroCanvas.offsetHeight;
            initHeroColumns();
        }
        
        function initHeroColumns() {
            columns = [];
            const columnWidth = 8;
            const gap = 2;
            const totalWidth = columnWidth + gap;
            const numColumns = Math.ceil(width / totalWidth);
            
            for (let i = 0; i < numColumns; i++) {
                const segments = [];
                const numSegments = 30;
                
                for (let j = 0; j < numSegments; j++) {
                    segments.push({
                        height: 3 + Math.random() * 12,
                        color: colors[Math.floor(Math.random() * colors.length)],
                        offset: Math.random() * height
                    });
                }
                
                columns.push({
                    x: i * totalWidth,
                    segments: segments,
                    speed: 0.5 + Math.random() * 0.5
                });
            }
        }
        
        let heroFrame = 0;
        function animateHero() {
            if (heroFrame % 4 === 0) {  // Update every 4th frame for smoother animation
                ctx.clearRect(0, 0, width, height);
                
                columns.forEach(column => {
                    column.segments.forEach((segment, index) => {
                        const y = (segment.offset + heroFrame * column.speed * 0.08) % height;
                        
                        ctx.fillStyle = `rgba(${segment.color.r}, ${segment.color.g}, ${segment.color.b}, 0.4)`;
                        ctx.fillRect(column.x, y, 8, segment.height);
                    });
                });
            }
            
            heroFrame++;
            requestAnimationFrame(animateHero);
        }
        
        resizeHeroCanvas();
        animateHero();
        
        window.addEventListener('resize', () => {
            setTimeout(resizeHeroCanvas, 250);
        });
    }

    // DNA Background Animation
    const canvas = document.getElementById('background-canvas');
    if (canvas) {
        const ctx = canvas.getContext('2d');
        let width, height;
        let columns = [];
        
        const colors = [
            { r: 99, g: 102, b: 241 },
            { r: 168, g: 85, b: 247 },
            { r: 59, g: 130, b: 246 },
        ];
        
        function resizeCanvas() {
            width = canvas.width = 300;
            height = canvas.height = window.innerHeight;
            initColumns();
        }
        
        function initColumns() {
            columns = [];
            const columnWidth = 6;
            const gap = 3;
            const totalWidth = columnWidth + gap;
            const numColumns = Math.ceil(width / totalWidth);
            
            for (let i = 0; i < numColumns; i++) {
                const segments = [];
                const numSegments = 20;
                
                for (let j = 0; j < numSegments; j++) {
                    segments.push({
                        height: 3 + Math.random() * 8,
                        color: colors[Math.floor(Math.random() * colors.length)],
                        offset: Math.random() * height,
                        alpha: 0.2 + Math.random() * 0.3
                    });
                }
                
                columns.push({
                    x: i * totalWidth,
                    segments: segments,
                    speed: 0.3 + Math.random() * 0.3
                });
            }
        }
        
        let frameCount = 0;
        function animate() {
            if (frameCount % 2 === 0) {  // Update ~30fps for smoother animation
                ctx.clearRect(0, 0, width, height);
                
                columns.forEach(column => {
                    column.segments.forEach((segment) => {
                        const y = (segment.offset + frameCount * column.speed * 0.1) % (height + 50);
                        
                        ctx.fillStyle = `rgba(${segment.color.r}, ${segment.color.g}, ${segment.color.b}, ${segment.alpha})`;
                        ctx.fillRect(column.x, y, 6, segment.height);
                    });
                });
            }
            
            frameCount++;
            requestAnimationFrame(animate);
        }
        
        resizeCanvas();
        animate();
        
        window.addEventListener('resize', () => {
            setTimeout(resizeCanvas, 250);
        });
    }
    
    // --- Species Generation Animation for 3 Sets ---
    // Set 1: Two random English words combined to form non-scientific names
    const set1Examples = [
        'Crimson Horizon', 'Velvet Thunder', 'Quantum Leap', 'Mystic River', 'Echo Valley',
        'Silent Peak', 'Azure Sky', 'Golden Dawn', 'Iron Gate', 'Silver Stream',
        'Winter Flame', 'Ember Wind', 'Crystal Shore', 'Shadow Frost', 'Ocean Mist',
        'Twilight Spark', 'Lunar Glow', 'Starlight Trail', 'Amber Field', 'Frost Wave',
        'Sunlit Path', 'Ember Grove', 'Misty Cove', 'Thunder Cloud', 'Sapphire Lake',
        'Obsidian Night', 'Whispering Sands', 'Radiant Forest', 'Diamond Ridge', 'Opal Waters',
        'Frozen Summit', 'Stormy Vista', 'Fiery Depths', 'Celestial Path', 'Verdant Cliffs',
        'Azure Depths', 'Twilight Meadow', 'Whisper Wind', 'Emerald Valley', 'Cobalt Plains',
        'Silver Pine', 'Jade Harbor', 'Ruby Sands', 'Ironwood Forest', 'Sapphire Peak',
        'Coral Reef', 'Ivory Coast', 'Onyx Hall', 'Goldenrod Hill', 'Midnight Sun'
    ];
    // Set 2: Completely fictional Latin-sounding binomial names with made-up genus and species
    const set2LatinExamples = [
        'Luminaricella splendens', 'Veloxigenium rapidus', 'Frigusoma glaciei', 'Ignicellula ardor', 'Solispira lumina',
        'Aurorabacillus albus', 'Aquavibrio unda', 'Ventiella zephyri', 'Arboricola silvae', 'Petraflexus saxi',
        'Luxbacillus fulgor', 'Nixicoccus nivalis', 'Calidibacter caloris', 'Sidereum ferrum', 'Gelubacillus frigidus',
        'Umbralevi umbrarum', 'Caelibacter caeli', 'Aquilonifer borealis', 'Luminoflora lux', 'Stellibacter astrum',
        'Crescobacter cresco', 'Flammabacter ignis', 'Monticola montis', 'Silvarumcella foresta', 'Ventusospira venti',
        'Arboribacter ligni', 'Siderosoma ferri', 'Fluminibacter fluvii', 'Glaeciabacter glacies', 'Ferrivibrio ferrum',
        'Temporibacter tempus', 'Radiobacillus radio', 'Ignispirillum igneus', 'Niveococcus niveus', 'Heliosoma solis',
        'Aquaspira aquae', 'Glaciigenium glacialis', 'Caelumcoccus aether', 'Lunabacter lunae', 'Terrafermentum terra',
        'Phosphoribacter phosphorus', 'Oralevi oralis', 'Aestusbacter aestus', 'Nubibacter nubes', 'Calorella calidus',
        'Tenebrisoma tenebrae', 'Polarisfermentum polus', 'Salumispira salum', 'Nocticella noctis', 'Firmamentibacter firmamentum'
    ];
    // Set 3: Real bacterial genus paired with fictional Latin species epithet
    const set2Examples = [
        'Bacillus splendens', 'Staphylococcus rapidus', 'Pseudomonas glaciei', 'Lactobacillus ardor', 'Rhodobacter lumina',
        'Escherichia albus', 'Streptococcus unda', 'Enterococcus zephyri', 'Klebsiella silvae', 'Serratia saxi',
        'Acinetobacter fulgor', 'Corynebacterium nivalis', 'Legionella caloris', 'Mycobacterium ferrum', 'Clostridium frigidus',
        'Vibrio umbrarum', 'Aeromonas caeli', 'Campylobacter borealis', 'Helicobacter lux', 'Neisseria astrum',
        'Salmonella cresco', 'Proteus ignis', 'Shigella montis', 'Haemophilus foresta', 'Yersinia venti',
        'Pasteurella ligni', 'Micrococcus ferri', 'Leuconostoc fluvii', 'Bacteroides glacies', 'Veillonella ferrum',
        'Fusobacterium tempus', 'Actinomyces radio', 'Bordetella igneus', 'Brucella niveus', 'Chlamydia solis',
        'Treponema aquae', 'Burkholderia glacialis', 'Francisella aether', 'Rickettsia lunae', 'Streptomyces terra',
        'Listeria phosphorus', 'Nocardia oralis', 'Spirochaeta aestus', 'Mycoplasma nubes', 'Anaplasma calidus',
        'Bartonella tenebrae', 'Chlamydophila polus', 'Eikenella salum', 'Gallionella noctis', 'Xanthomonas firmamentum'
    ];
    // Set 4: Fictional Latin genus paired with real bacterial species epithet
    const set3Examples = [
        'Luminaricella coli', 'Veloxigenium aeruginosa', 'Frigusoma putida', 'Ignicellula acidilactici', 'Solispira typhimurium',
        'Aurorabacillus subtilis', 'Aquavibrio cholerae', 'Ventiella faecalis', 'Arboricola pneumoniae', 'Petraflexus fragilis',
        'Luxbacillus cereus', 'Nixicoccus aureus', 'Calidibacter thermophilus', 'Sidereum metallidurans', 'Gelubacillus licheniformis',
        'Umbralevi influenzae', 'Caelibacter perfringens', 'Aquilonifer dysenteriae', 'Luminoflora rhamnosus', 'Stellibacter agalactiae',
        'Crescobacter plantarum', 'Flammabacter pyogenes', 'Monticola anthracis', 'Silvarumcella tularensis', 'Ventusospira typhi',
        'Arboribacter melitensis', 'Siderosoma enteritidis', 'Fluminibacter meningitidis', 'Glaeciabacter megaterium', 'Ferrivibrio vulnificus',
        'Temporibacter coli', 'Radiobacillus difficile', 'Ignispirillum jirovecii', 'Niveococcus pneumoniae', 'Heliosoma epidermidis',
        'Aquaspira mirabilis', 'Glaciigenium thermoglucosidasius', 'Caelumcoccus sporogenes', 'Lunabacter monocytogenes', 'Terrafermentum diphtheriae',
        'Phosphoribacter salmonis', 'Oralevi oralis', 'Aestusbacter haemolyticus', 'Nubibacter suis', 'Calorella botulinum',
        'Tenebrisoma palustris', 'Polarisfermentum maltophilia', 'Salumispira marcescens', 'Nocticella legionellae', 'Firmamentibacter cloacae'
    ];
    function createMiniBoxes(miniBoxId, totalBoxes) {
        const container = document.getElementById(miniBoxId);
        if (!container) return;
        container.innerHTML = '';
        for (let i = 0; i < totalBoxes; i++) {
            const box = document.createElement('div');
            box.className = 'mini-box';
            box.style.width = '12px';
            box.style.height = '12px';
            box.style.borderRadius = '3px';
            box.style.background = '#FAFAFA';
            box.style.transition = 'background 0.2s';
            container.appendChild(box);
        }
    }
    function animateSet(speciesList, speciesId, labelId, miniBoxId, artificialMode) {
        let idx = 0;
        const total = speciesList.length;
        const speciesElem = document.getElementById(speciesId);
        const labelElem = document.getElementById(labelId);
        const miniBoxCount = 15;
        createMiniBoxes(miniBoxId, miniBoxCount);
        const miniBoxes = document.getElementById(miniBoxId)?.children;
        function formatSpecies(name) {
            const parts = name.split(' ');
            if (artificialMode === 'both') {
                // Set 1: both words artificial
                return `<span class="artificial-part">${parts[0]}</span> <span class="artificial-part">${parts[1] || ''}</span>`;
            } else if (artificialMode === 'species') {
                // Set 2: species (second word) artificial
                return `${parts[0]} <span class="artificial-part">${parts[1] || ''}</span>`;
            } else if (artificialMode === 'genus') {
                // Set 3: genus (first word) artificial
                return `<span class="artificial-part">${parts[0]}</span> ${parts[1] || ''}`;
            }
            return name;
        }
        function next() {
            if (speciesElem) speciesElem.innerHTML = formatSpecies(speciesList[idx]);
            if (labelElem) labelElem.textContent = `${idx+1}/50`;
            // Highlight mini-box
            if (miniBoxes) {
                for (let i = 0; i < miniBoxCount; i++) {
                    miniBoxes[i].style.background = '#FAFAFA';
                }
                // Each mini-box represents ~3.33 steps
                const boxIdx = Math.floor(idx / (total / miniBoxCount));
                if (miniBoxes[boxIdx]) {
                    miniBoxes[boxIdx].style.background = 'var(--primary, #6366f1)';
                }
            }
            idx = (idx + 1) % total;
        }
        next();
        setInterval(next, 1200);
    }
    animateSet(set1Examples, 'set1-species', 'set1-label', 'set1-miniboxes', 'both');
    animateSet(set2LatinExamples, 'set2-species', 'set2-label', 'set2-miniboxes', 'both');
    animateSet(set2Examples, 'set3-species', 'set3-label', 'set3-miniboxes', 'species');
    animateSet(set3Examples, 'set4-species', 'set4-label', 'set4-miniboxes', 'genus');
    // --- End Species Generation Animation ---
    
    function createBarChartLegend() {
        return `
            <div class="legend">
                <div style="display: flex; align-items: center; gap: 8px; font-size: 13px; color: var(--gray-700);" title="Model can provide in-depth, reference-level information.">
                    <div style="width: 14px; height: 14px; border-radius: 4px; border: 1px solid rgba(0,0,0,0.1); background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);"></div>
                    <span>Extensive</span>
                </div>
                <div style="display: flex; align-items: center; gap: 8px; font-size: 13px; color: var(--gray-700);" title="Model can give several specific details.">
                    <div style="width: 14px; height: 14px; border-radius: 4px; border: 1px solid rgba(0,0,0,0.1); background: linear-gradient(135deg, #d1ecf1 0%, #bee5eb 100%);"></div>
                    <span>Moderate</span>
                </div>
                <div style="display: flex; align-items: center; gap: 8px; font-size: 13px; color: var(--gray-700);" title="Model knows only basic facts or context.">
                    <div style="width: 14px; height: 14px; border-radius: 4px; border: 1px solid rgba(0,0,0,0.1); background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);"></div>
                    <span>Limited</span>
                </div>
                <div style="display: flex; align-items: center; gap: 8px; font-size: 13px; color: var(--gray-700);" title="Model doesn't know or no information available.">
                    <div style="width: 14px; height: 14px; border-radius: 4px; border: 1px solid rgba(0,0,0,0.1); background: linear-gradient(135deg, #e2e3e5 0%, #d6d8db 100%);"></div>
                    <span>NA</span>
                </div>
                <div style="display: flex; align-items: center; gap: 8px; font-size: 13px; color: var(--gray-700);" title="Model failed to generate a response or the response was not valid.">
                    <div style="width: 14px; height: 14px; border-radius: 4px; border: 1px solid rgba(0,0,0,0.1); background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);"></div>
                    <span>Failed</span>
                </div>
            </div>
        `;
    }
    
    // --- Knowledge Analysis Data Fetch and Render (Using Working Version Logic) ---
    function formatTypeName(typeName) {
        // Format type names for display
        const typeDescriptions = {
            'random_words': 'Random Words',
            'latin_random_words': 'Fictional Latin',
            'real_genus_latin_strain': 'Real Genus + Fake Species',
            'latin_genus_real_strain': 'Fake Genus + Real Species'
        };
        return typeDescriptions[typeName] || typeName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
    }
    
    function loadKnowledgeAnalysisData() {
        const container = document.getElementById('knowledgeAnalysisContent');
        
        console.log('Starting to load knowledge analysis data...');
        
        // Add timeout for loading
        const loadingTimeout = setTimeout(() => {
            container.innerHTML = `<div class="empty-state"><h3>Loading is taking longer than expected</h3><p>Please check your connection and try refreshing the page.</p></div>`;
        }, 10000); // 10 second timeout
        
        // Fetch knowledge analysis data
        fetch('/api/knowledge_analysis_data')
            .then(response => {
                clearTimeout(loadingTimeout);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                console.log('Knowledge analysis data received:', data);
                
                if (data.error) {
                    container.innerHTML = `<div class="empty-state"><h3>Error loading knowledge analysis</h3><p>${data.error}</p></div>`;
                    return;
                }
                
                const knowledgeData = data.knowledge_analysis;
                
                if (!knowledgeData || Object.keys(knowledgeData).length === 0) {
                    container.innerHTML = '<div class="empty-state"><h3>No knowledge level data available</h3><p>Process some species with knowledge templates to see the analysis.</p></div>';
                    return;
                }
                
                // Store data globally for dataset switching
                window.knowledgeAnalysisData = data;
                
                // Render the analysis interface
                renderKnowledgeAnalysisInterface(data);
            })
            .catch(error => {
                clearTimeout(loadingTimeout);
                console.error('Error loading knowledge analysis:', error);
                container.innerHTML = `<div class="empty-state"><h3>Error loading knowledge analysis</h3><p>${error.message}</p></div>`;
            });
    }
    
    function renderKnowledgeAnalysisInterface(data) {
        const container = document.getElementById('knowledgeAnalysisContent');
        const knowledgeData = data.knowledge_analysis;
        const fileList = data.file_list || Object.keys(knowledgeData);
        
        console.log('Rendering knowledge analysis interface with files:', fileList);
        
        // Clear the container first
        container.innerHTML = '';
        
        let html = '';
        
        // Content for analysis by species type
        html += '<div id="artificalAnalysisContent">';
        html += '</div>';
        
        container.innerHTML = html;
        
        // Find and render only files that have type columns
        const filesWithTypes = fileList.filter(file => {
            const fileData = knowledgeData[file];
            return fileData && fileData.has_type_column;
        });
        
        if (filesWithTypes.length > 0) {
            // For simplicity, show the first file with type data
            const selectedFile = filesWithTypes[0];
            renderDatasetAnalysis(selectedFile, knowledgeData);
        } else {
            // Show message if no files have type data
            document.getElementById('artificalAnalysisContent').innerHTML = 
                '<div class="empty-state"><h3>No data with species types found</h3><p>Upload data files with type columns to see analysis by species type.</p></div>';
        }
    }
    
    function renderDatasetAnalysis(selectedFile, knowledgeData) {
        const contentContainer = document.getElementById('artificalAnalysisContent');
        const fileData = knowledgeData[selectedFile];
        
        if (!fileData || !fileData.types || !fileData.has_type_column) {
            contentContainer.innerHTML = '<div class="empty-state"><h3>No type data available for selected dataset</h3></div>';
            return;
        }
        
        const displayName = selectedFile.replace(/\.(txt|csv)$/i, '');
        let html = '';
        
        // Reorganize data by model and input type
        const modelData = {};
        const inputTypeSet = new Set();
        const templates = new Set();
        
        Object.entries(fileData.types).forEach(([inputType, templateData]) => {
            inputTypeSet.add(inputType);
            Object.entries(templateData).forEach(([templateName, models]) => {
                templates.add(templateName);
                Object.entries(models).forEach(([modelName, stats]) => {
                    if (!modelData[modelName]) {
                        modelData[modelName] = {};
                    }
                    if (!modelData[modelName][templateName]) {
                        modelData[modelName][templateName] = {};
                    }
                    modelData[modelName][templateName][inputType] = stats;
                });
            });
        });
        
        const inputTypeArray = Array.from(inputTypeSet).sort();
        const templateArray = Array.from(templates).sort();
        
        // Calculate statistics for the stats cards
        let totalModels = Object.keys(modelData).length;
        let totalTemplates = templateArray.length;
        let bestModel = null;
        let worstModel = null;
        let bestScore = -1;
        let worstScore = 4; // Start with max possible score
        
        // Find best and worst models for the dynamic text
        Object.entries(modelData).forEach(([modelName, templates]) => {
            let totalScore = 0;
            let totalSamples = 0;
            
            templateArray.forEach(templateName => {
                if (templates[templateName]) {
                    inputTypeArray.forEach(inputType => {
                        const data = templates[templateName][inputType];
                        if (data) {
                            const naFailedCount = (data.NA || 0) + (data.no_result || 0) + (data.inference_failed || 0);
                            const limitedCount = data.limited || 0;
                            const moderateCount = data.moderate || 0;
                            const extensiveCount = data.extensive || 0;
                            
                            totalScore += (naFailedCount * 3) + (limitedCount * 2) + (moderateCount * 1) + (extensiveCount * 0);
                            totalSamples += data.total || 0;
                        }
                    });
                }
            });
            
            if (totalSamples > 0) {
                const averageScore = totalScore / totalSamples;
                if (averageScore > bestScore) {
                    bestScore = averageScore;
                    bestModel = modelName.split('/').pop();
                }
                if (averageScore < worstScore) {
                    worstScore = averageScore;
                    worstModel = modelName.split('/').pop();
                }
            }
        });
        
        // Add dynamic statistics text
        const dynamicStatsText =
            `In total, we analyzed <span class="stat-value">${totalModels}</span> language models across ` +
            `<span class="stat-value">${totalTemplates}</span> different query templates and calculated for each model this score. ` +
            (bestModel ? `The top performers are those that consistently identified fictional species as unknown, achieving the highest scores. Under all evaluated models, the best one was <span class="model-highlight">${bestModel}</span> ` +
                `with an average quality score of <span class="stat-value">${bestScore.toFixed(2)}</span>, ` +
                `correctly identifying most artificial species as non-existent. ` : '') +
            (worstModel && worstModel !== bestModel ? `In contrast, <span class="model-lowlight">${worstModel}</span> ` +
                `performed poorly with a score of <span class="stat-value">${worstScore.toFixed(2)}</span>, ` +
                `frequently hallucinating information about fake bacteria.` : '');
        const statsTarget = document.getElementById('dynamicStatsText');
        if (statsTarget) statsTarget.innerHTML = dynamicStatsText;
        
        // Add tables without header since dataset is shown in dynamic stats
        html += renderTemplateAnalysisTables(templateArray, inputTypeArray, modelData);
        
        contentContainer.innerHTML = html;

        // --- Calculate overall model scores for rankings and histogram ---
        const overallModelScores = {};
        Object.entries(modelData).forEach(([modelName, templates]) => {
            let totalScore = 0;
            let totalSamples = 0;
            let dist = { NA: 0, limited: 0, moderate: 0, extensive: 0, no_result: 0, inference_failed: 0, total: 0 };

            // Only use templates that are in templateArray
            templateArray.forEach(templateName => {
                if (templates[templateName]) {
                    const templateData = templates[templateName];
                    Object.values(templateData).forEach(stats => {
                        const naFailedCount = (stats.NA || 0) + (stats.no_result || 0) + (stats.inference_failed || 0);
                        const limitedCount = stats.limited || 0;
                        const moderateCount = stats.moderate || 0;
                        const extensiveCount = stats.extensive || 0;
                        totalScore += (naFailedCount * 3) + (limitedCount * 2) + (moderateCount * 1) + (extensiveCount * 0);
                        totalSamples += stats.total || 0;

                        dist.NA += stats.NA || 0;
                        dist.limited += stats.limited || 0;
                        dist.moderate += stats.moderate || 0;
                        dist.extensive += stats.extensive || 0;
                        dist.no_result += stats.no_result || 0;
                        dist.inference_failed += stats.inference_failed || 0;
                        dist.total += stats.total || 0;
                    });
                }
            });
            if (totalSamples > 0) {
                overallModelScores[modelName] = {
                    averageQualityScore: totalScore / totalSamples,
                    totalSamples: totalSamples,
                    distribution: dist
                };
            }
        });

        const sortedModels = Object.entries(overallModelScores)
            .map(([modelName, scores]) => ({ modelName, ...scores }))
            .sort((a, b) => b.averageQualityScore - a.averageQualityScore);

        // --- Render Top 4 Performers ---
        const top4Models = sortedModels.slice(0, 4);
        if (top4Models.length > 0) {
            let topPerformersHtml = `
<div class="top-performers-section">
    <h3 class="section-title" style="text-align: left; font-size: 24px; margin-bottom: 8px;">Top Performing Models</h3>
    <p class="article-text" style="margin-bottom: 24px;">To create an overall ranking, we average each model's quality score across all query templates. The top performers are those that consistently identified fictional species as unknown, achieving the highest scores.</p>
    ${createBarChartLegend()}
    <div class="performers-list">
            `;
            top4Models.forEach((model, index) => {
                const displayName = model.modelName.split('/').pop();
                topPerformersHtml += `
        <div class="performer-card">
            <div class="performer-rank">${index + 1}</div>
            <div style="flex: 1;">
                <div class="performer-name">${displayName}</div>
                <div class="performer-score">Avg. Quality Score: <strong>${model.averageQualityScore.toFixed(2)}</strong></div>
                <div class="performer-dist-chart" style="margin-top: 12px;">
                    ${createKnowledgeBarChart(model.distribution)}
                </div>
            </div>
        </div>
                `;
            });
            topPerformersHtml += `
    </div>
</div>
            `;
            
            const container = document.getElementById('topPerformersContainer');
            if (container) {
                container.innerHTML = topPerformersHtml;
            }
        }

        // --- Render Worst 2 Performers ---
        const worst2Models = sortedModels.length > 5 ? sortedModels.slice(-2) : [];
        if (worst2Models.length > 0) {
            let worstPerformersHtml = `
                <section class="section-callout section-callout--purple">
                    <div class="section-callout__content">
                        <div class="section-callout__header">
                            <h3 class="section-callout__title">Models Needing Improvement</h3>
                            <p class="section-callout__text">However, there is a significant difference in how models perform. The models with the most room for improvement are:</p>
                        </div>
                        <div class="performers-list">
            `;
            worst2Models.reverse().forEach((model, index) => {
                const rank = sortedModels.length - index;
                const displayName = model.modelName.split('/').pop();
                worstPerformersHtml += `
                    <div class="performer-card worst">
                        <div class="performer-rank">${rank}</div>
                        <div style="flex: 1;">
                            <div class="performer-name">${displayName}</div>
                            <div class="performer-score">Avg. Quality Score: <strong>${model.averageQualityScore.toFixed(2)}</strong></div>
                            <div class="performer-dist-chart" style="margin-top: 12px;">
                                ${createKnowledgeBarChart(model.distribution)}
                            </div>
                        </div>
                    </div>
                `;
            });
            worstPerformersHtml += `
                        </div>
                    </div>
                </section>
            `;
            const worstContainer = document.getElementById('worstPerformerContainer');
            if (worstContainer) {
                worstContainer.innerHTML = worstPerformersHtml;
            }
        }

        // Add quality score bar chart after performers sections
        const qualityChartContainer = document.createElement('div');
        qualityChartContainer.innerHTML = createQualityScoreBarChart(sortedModels, modelData, templateArray);
        const knowledgeContent = document.getElementById('knowledgeAnalysisContent');
        if (knowledgeContent) {
            knowledgeContent.appendChild(qualityChartContainer);
        }

        // Generate Correlation Score Distribution
        generateQualityScoreHistogram(overallModelScores);
        
        // Finally, render the score example box
        renderScoreExample(modelData, templateArray, inputTypeArray);
    }

    function generateScoreExampleHTML(modelData, templateArray, inputTypeArray) {
        const modelNames = Object.keys(modelData);
        let scoreExampleHtml = '';
        if (modelNames.length > 0 && templateArray.length > 0) {
            // Pick a random model for the example
            const randomModelName = modelNames[Math.floor(Math.random() * modelNames.length)];
            const randomModel = modelData[randomModelName];
            const firstTemplate = templateArray[0];
            
                             if (randomModel && randomModel[firstTemplate]) {
                scoreExampleHtml += '<div class="callout callout-template">';
                
                // Header with reload button
                scoreExampleHtml += `
                    <div class="callout-header" style="display: flex; justify-content: space-between; align-items: center; font-size:15px;font-weight:600;margin-bottom:8px;">
                        <span>Quality Score Calculation Example</span>
                        <button id="reloadScoreExampleBtn" title="Show another random model" style="background: none; border: 1px solid var(--gray-300); border-radius: 6px; padding: 2px 6px; cursor: pointer; line-height: 1; transition: all 0.2s ease;" onmouseover="this.style.borderColor='var(--gray-400)'; this.style.backgroundColor='var(--gray-100)';" onmouseout="this.style.borderColor='var(--gray-300)'; this.style.backgroundColor='transparent';">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M23 4v6h-6"></path><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>
                        </button>
                    </div>`;

                scoreExampleHtml += '<div class="callout-content" style="padding:0;">';
                
                const displayModelName = randomModelName.split('/').pop();
                scoreExampleHtml += `<div style="font-size:13px;margin-bottom:8px;"><strong>Model:</strong> <span style="font-family:monospace;">${displayModelName}</span> &nbsp; <strong>Template:</strong> <span style="font-family:monospace;">${firstTemplate}</span></div>`;
                
                let totalScore = 0;
                let totalSamples = 0;
                
                scoreExampleHtml += '<div class="table-responsive"><table class="table">';
                scoreExampleHtml += '<thead><tr>';
                scoreExampleHtml += '<th>Type</th>';
                scoreExampleHtml += '<th style="text-align:right;">Score</th>';
                scoreExampleHtml += '<th style="text-align:right;">Subtotal</th>';
                scoreExampleHtml += '</tr></thead>';
                scoreExampleHtml += '<tbody>';
                
                inputTypeArray.forEach(inputType => {
                    const data = randomModel[firstTemplate][inputType];
                    if (data) {
                        const naFailedCount = (data.NA || 0) + (data.no_result || 0) + (data.inference_failed || 0);
                        const limitedCount = data.limited || 0;
                        const moderateCount = data.moderate || 0;
                        const extensiveCount = data.extensive || 0;
                        
                        const typeScore = (naFailedCount * 3) + (limitedCount * 2) + (moderateCount * 1) + (extensiveCount * 0);
                        totalScore += typeScore;
                        totalSamples += data.total || 0;
                        
                        const typeName = formatTypeName(inputType);
                        scoreExampleHtml += `<tr>`;
                        scoreExampleHtml += `<td>${typeName}</td>`;
                        scoreExampleHtml += `<td style="text-align:right;">`;
                        if (naFailedCount > 0) scoreExampleHtml += `<span style="color:#059669;font-weight:600;">3${naFailedCount}</span> `;
                        if (limitedCount > 0) scoreExampleHtml += `<span style="color:#d97706;font-weight:600;">2${limitedCount}</span> `;
                        if (moderateCount > 0) scoreExampleHtml += `<span style="color:#dc2626;font-weight:600;">1${moderateCount}</span> `;
                        if (extensiveCount > 0) scoreExampleHtml += `<span style="color:#991b1b;font-weight:600;">0${extensiveCount}</span>`;
                        scoreExampleHtml += `</td>`;
                        scoreExampleHtml += `<td style="text-align:right;font-family:monospace;">${typeScore}</td>`;
                        scoreExampleHtml += `</tr>`;
                    }
                });
                scoreExampleHtml += '</tbody></table></div>';
                
                const averageScore = totalSamples > 0 ? totalScore / totalSamples : 0;
                scoreExampleHtml += `<div style="text-align:right;font-size:13px;margin-bottom:2px;"><strong>Final:</strong> <span style="font-family:monospace;">${totalScore}  ${totalSamples} = <span style='color:#7c3aed;font-weight:700;font-size:15px;'>${averageScore.toFixed(2)}</span></span></div>`;
                scoreExampleHtml += '<div style="font-size:12px;color:var(--gray-600);margin-top:4px;">Higher scores = better at refusing to hallucinate about fake species.</div>';
                scoreExampleHtml += '</div>';
                scoreExampleHtml += '</div>';
            }
        }
        return scoreExampleHtml;
    }

    function renderScoreExample(modelData, templateArray, inputTypeArray) {
        const scoreExampleTarget = document.getElementById('scoreExampleContainer');
        if (!scoreExampleTarget) return;

        scoreExampleTarget.innerHTML = generateScoreExampleHTML(modelData, templateArray, inputTypeArray);
        
        const reloadButton = document.getElementById('reloadScoreExampleBtn');
        if (reloadButton) {
            reloadButton.onclick = () => renderScoreExample(modelData, templateArray, inputTypeArray);
        }
    }
    
    function generateQualityScoreHistogram(overallModelScores) {
        const container = document.getElementById('qualityScoreHistogramContainer');
        if (!container) return;
        
        // Generate horizontal bar chart for correlation scores
        generateCorrelationScoreBarChart(container, overallModelScores);
    }
    
    // Create horizontal bar chart for correlation scores
    function generateCorrelationScoreBarChart(container, overallModelScores) {
        // Load correlation data
        fetch('/api/search_count_correlation')
            .then(response => response.json())
            .then(data => {
                if (data.error || !data.files_with_search_counts || data.files_with_search_counts.length === 0) {
                    container.innerHTML = '';
                    return;
                }
                
                // Get the first dataset with search counts
                const dataset = data.files_with_search_counts[0];
                const correlationData = data.correlation_data[dataset];
                
                if (!correlationData) {
                    container.innerHTML = '';
                    return;
                }
                
                // Collect all model correlations
                const modelCorrelations = [];
                
                Object.entries(correlationData).forEach(([templateName, models]) => {
                    Object.entries(models).forEach(([modelName, modelData]) => {
                        if (modelData.species_count >= 2) {
                            // Find existing model or create new entry
                            let modelEntry = modelCorrelations.find(m => m.modelName === modelName);
                            if (!modelEntry) {
                                modelEntry = {
                                    modelName: modelName,
                                    templateData: {},
                                    avgCorrelation: 0,
                                    validTemplates: 0
                                };
                                modelCorrelations.push(modelEntry);
                            }
                            modelEntry.templateData[templateName] = {
                                correlation: modelData.correlation_coefficient,
                                knowledgeDist: modelData.knowledge_distribution,
                                speciesCount: modelData.species_count,
                                dataPoints: modelData.data_points
                            };
                        }
                    });
                });
                
                // Calculate average correlations
                modelCorrelations.forEach(model => {
                    const correlations = Object.values(model.templateData).map(t => t.correlation);
                    model.validTemplates = correlations.length;
                    model.avgCorrelation = correlations.reduce((a, b) => a + b, 0) / correlations.length;
                });
                
                // Sort by average correlation
                modelCorrelations.sort((a, b) => b.avgCorrelation - a.avgCorrelation);
                
                // Create horizontal bar chart visualization following style guide
                let html = `
                <section class="section-callout section-callout--green">
                    <div class="section-callout__content section-callout__content--full-width">
                        <div class="section-callout__header">
                            <h3 class="section-callout__title">Correlation Score Distribution</h3>
                            <p class="section-callout__text">
                                This chart shows the distribution of knowledge-web alignment correlations across all models. 
                                Models that claim more knowledge about well-documented species (and less about obscure ones) have higher positive correlations.
                            </p>
                        </div>
                    <table class="knowledge-analysis-table">
                        <thead>
                            <tr>
                                <th style="text-align: left;">Model</th>
                                <th style="text-align: center; width: 300px;">Knowledge Distribution (Real Species)</th>
                                <th style="text-align: center; width: 80px;">Total Species</th>
                                <th style="text-align: center; width: 300px;">Avg. Google Searches by Knowledge Level</th>
                                <th style="text-align: center; width: 80px;">NA Rate</th>
                                <th style="text-align: center; width: 150px;">Pearson Correlation</th>
                            </tr>
                        </thead>
                        <tbody>
                `;
                
                // Show top models with correlations
                modelCorrelations.slice(0, 15).forEach(model => {
                    const displayName = formatModelName(model.modelName);
                    
                    // Calculate aggregated knowledge distribution
                    let totalDist = { limited: 0, moderate: 0, extensive: 0, NA: 0, total: 0 };
                    Object.values(model.templateData).forEach(data => {
                        if (data.knowledgeDist) {
                            totalDist.limited += data.knowledgeDist.limited || 0;
                            totalDist.moderate += data.knowledgeDist.moderate || 0;
                            totalDist.extensive += data.knowledgeDist.extensive || 0;
                            totalDist.NA += data.knowledgeDist.NA || 0;
                            totalDist.total += data.speciesCount || 0;
                        }
                    });
                    
                    const correlationClass = getCorrelationClass(model.avgCorrelation);
                    const interpretation = getCorrelationInterpretation(model.avgCorrelation);
                    
                    // Calculate additional statistics
                    let searchByKnowledge = {
                        limited: { sum: 0, count: 0 },
                        moderate: { sum: 0, count: 0 },
                        extensive: { sum: 0, count: 0 }
                    };
                    let totalDataPoints = 0;
                    
                    Object.values(model.templateData).forEach(data => {
                        if (data.dataPoints) {
                            data.dataPoints.forEach(point => {
                                totalDataPoints++;
                                if (point.search_count > 0 && point.knowledge_group && point.knowledge_group !== 'NA') {
                                    const group = point.knowledge_group.toLowerCase();
                                    if (searchByKnowledge[group]) {
                                        searchByKnowledge[group].sum += point.search_count;
                                        searchByKnowledge[group].count++;
                                    }
                                }
                            });
                        }
                    });
                    
                    // Calculate averages for each knowledge level
                    const avgSearchLimited = searchByKnowledge.limited.count > 0 ? 
                        Math.round(searchByKnowledge.limited.sum / searchByKnowledge.limited.count).toLocaleString() : '-';
                    const avgSearchModerate = searchByKnowledge.moderate.count > 0 ? 
                        Math.round(searchByKnowledge.moderate.sum / searchByKnowledge.moderate.count).toLocaleString() : '-';
                    const avgSearchExtensive = searchByKnowledge.extensive.count > 0 ? 
                        Math.round(searchByKnowledge.extensive.sum / searchByKnowledge.extensive.count).toLocaleString() : '-';
                    
                    const naRate = totalDist.total > 0 ? 
                        ((totalDist.NA / totalDist.total) * 100).toFixed(1) + '%' : 'N/A';
                    
                    html += `
                        <tr>
                            <td class="model-name-cell">${displayName}</td>
                            <td class="chart-cell">
                                ${renderKnowledgeDistributionBar(totalDist, totalDist.total)}
                            </td>
                            <td style="text-align: center; font-size: 13px; color: var(--gray-700);">
                                ${totalDist.total.toLocaleString()}
                            </td>
                            <td style="text-align: center; font-size: 12px;">
                                <div style="display: flex; justify-content: space-around; align-items: center; gap: 8px;">
                                    <div style="text-align: center;">
                                        <div style="font-weight: 700; color: #d97706;">L</div>
                                        <div style="color: var(--gray-600);">${avgSearchLimited}</div>
                                    </div>
                                    <div style="text-align: center;">
                                        <div style="font-weight: 700; color: #0c5460;">M</div>
                                        <div style="color: var(--gray-600);">${avgSearchModerate}</div>
                                    </div>
                                    <div style="text-align: center;">
                                        <div style="font-weight: 700; color: #155724;">E</div>
                                        <div style="color: var(--gray-600);">${avgSearchExtensive}</div>
                                    </div>
                                </div>
                            </td>
                            <td style="text-align: center; font-size: 13px; font-weight: 600; color: ${totalDist.NA / totalDist.total > 0.5 ? '#dc3545' : 'var(--gray-700)'};">
                                ${naRate}
                            </td>
                            <td class="correlation-value-cell" style="text-align: center;">
                                <span class="${correlationClass}" style="font-weight: 600;">
                                    ${model.avgCorrelation.toFixed(3)}
                                </span><br>
                                <span style="font-size: 9px; color: #6c757d;">(${interpretation})</span>
                            </td>
                        </tr>
                    `;
                });
                
                html += `
                            </tbody>
                        </table>
                        
                        <!-- Legend below table -->
                        <div class="legend">
                            <div class="legend-item">
                                <div class="legend-color" style="background: #d4edda; border-color: #c3e6cb;"></div>
                                <span>Extensive Knowledge</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #d1ecf1; border-color: #bee5eb;"></div>
                                <span>Moderate Knowledge</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #fff3cd; border-color: #ffeaa7;"></div>
                                <span>Limited Knowledge</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #e2e3e5; border-color: #d6d8db;"></div>
                                <span>No Information (NA)</span>
                            </div>
                        </div>
                        
                        <!-- Explanatory note -->
                        <div style="margin-top: 24px; padding: 16px; background: rgba(99, 102, 241, 0.05); border: 1px solid rgba(99, 102, 241, 0.1); border-radius: 8px;">
                            <p style="margin: 0; font-size: 13px; color: var(--gray-700); line-height: 1.6;">
                                <strong>Note:</strong> The <strong>Pearson Correlation</strong> measures the linear relationship between log(Google search counts) and the model's knowledge level claims (1=Limited, 2=Moderate, 3=Extensive). 
                                A positive correlation indicates that the model appropriately reports more knowledge for well-documented species and less for obscure ones.
                                The <strong>Google Searches by Knowledge Level</strong> shows the average search count for species that the model classified into each knowledge category (L=Limited, M=Moderate, E=Extensive).
                            </p>
                        </div>
                    </div>
                </section>
                `;
                
                container.innerHTML = html;
            })
            .catch(error => {
                console.error('Error loading correlation data:', error);
                container.innerHTML = '';
            });
    }
    
    function formatModelName(modelName) {
        if (!modelName.includes('/')) {
            return modelName;
        }
        
        const [provider, model] = modelName.split('/');
        const providerMap = {
            'anthropic': 'Anthropic',
            'openai': 'OpenAI',
            'google': 'Google',
            'meta-llama': 'Meta',
            'mistralai': 'Mistral',
            'cohere': 'Cohere',
            'x-ai': 'xAI'
        };
        
        const displayProvider = providerMap[provider] || provider.charAt(0).toUpperCase() + provider.slice(1);
        return `${displayProvider} ${model}`;
    }
    
    function getCorrelationClass(correlation) {
        if (correlation >= 0.7) return 'strong-positive';
        if (correlation >= 0.3) return 'moderate-positive';
        if (correlation <= -0.7) return 'strong-negative';
        if (correlation <= -0.3) return 'moderate-negative';
        return 'weak';
    }
    
    function getCorrelationInterpretation(correlation) {
        if (correlation >= 0.7) return 'Excellent';
        if (correlation >= 0.5) return 'Good';
        if (correlation >= 0.3) return 'Moderate';
        if (correlation >= 0.1) return 'Weak +';
        if (correlation >= -0.1) return 'None';
        if (correlation >= -0.3) return 'Weak -';
        if (correlation >= -0.5) return 'Inverse';
        return 'Strong -';
    }
    
    function renderKnowledgeDistributionBar(dist, total) {
        if (total === 0) {
            return '<div class="no-data">No data</div>';
        }
        
        // Calculate percentages
        const limitedPct = ((dist.limited || 0) / total * 100);
        const moderatePct = ((dist.moderate || 0) / total * 100);
        const extensivePct = ((dist.extensive || 0) / total * 100);
        const naPct = ((dist.NA || 0) / total * 100);
        
        // Calculate minimum visible width
        const minVisiblePct = 2;
        const segments = [
            { type: 'limited', count: dist.limited || 0, pct: limitedPct, class: 'knowledge-limited' },
            { type: 'moderate', count: dist.moderate || 0, pct: moderatePct, class: 'knowledge-moderate' },
            { type: 'extensive', count: dist.extensive || 0, pct: extensivePct, class: 'knowledge-extensive' },
            { type: 'na', count: dist.NA || 0, pct: naPct, class: 'knowledge-na' }
        ].filter(seg => seg.count > 0);
        
        // Calculate adjusted widths
        let totalAdjustedPct = 0;
        const adjustedSegments = segments.map(seg => {
            const minWidth = minVisiblePct;
            const adjustedPct = seg.pct < minWidth && seg.count > 0 ? minWidth : seg.pct;
            totalAdjustedPct += adjustedPct;
            return { ...seg, adjustedPct };
        });
        
        // Scale down if total exceeds 100%
        const scaleFactor = totalAdjustedPct > 100 ? 100 / totalAdjustedPct : 1;
        
        let html = '<div class="single-bar-chart">';
        html += '<div class="single-stacked-bar">';
        
        adjustedSegments.forEach((seg, index) => {
            const finalWidth = seg.adjustedPct * scaleFactor;
            
            html += `<div class="bar-segment ${seg.class}" style="width: ${finalWidth}%">`;
            
            // Show number for larger segments
            if (finalWidth > 4 || seg.count >= 10) {
                html += `<span class="bar-number">${seg.count}</span>`;
            }
            
            html += `</div>`;
        });
        
        html += '</div>';
        html += '</div>';
        
        return html;
    }
    
    // Create correlation visualization
    function generateCorrelationVisualization(container) {
        // This function is no longer used but kept for compatibility
        return;
    }
    
    function createCorrelationChart(modelCorrelations) {
        // Filter models that have correlations for all templates
        const completeModels = {};
        const templateNames = ['template1_knowlege', 'template2_knowlege', 'template3_knowlege'];
        
        Object.entries(modelCorrelations).forEach(([modelName, data]) => {
            const hasAllTemplates = templateNames.every(template => 
                data.correlations[template] !== undefined
            );
            
            if (hasAllTemplates) {
                // Calculate average correlation
                const correlations = Object.values(data.correlations);
                const avgCorrelation = correlations.reduce((a, b) => a + b, 0) / correlations.length;
                
                completeModels[modelName] = {
                    ...data,
                    averageCorrelation: avgCorrelation
                };
            }
        });
        
        // Sort by average correlation
        const sortedModels = Object.entries(completeModels)
            .sort((a, b) => b[1].averageCorrelation - a[1].averageCorrelation);
        
        if (sortedModels.length === 0) {
            return '';
        }
        
        // Template colors matching the quality score chart
        const templateColors = {
            0: '#8b5cf6', // Purple
            1: '#06b6d4', // Cyan
            2: '#f59e0b'  // Amber
        };
        
        let html = `
        <div class="correlation-chart-container" style="margin-top: 48px; margin-bottom: 48px;">
            <h3 class="section-title" style="font-size: 24px; margin-bottom: 16px;">Knowledge-Web Alignment Correlation by Template</h3>
            <p class="article-text" style="margin-bottom: 24px;">This chart shows how well each model's knowledge claims align with web presence of species. Higher correlations indicate better calibration. Hover over bars to see the correlation scatter plot.</p>
            
            <!-- Legend -->
            <div class="legend legend--centered legend--boxed">
        `;
        
        templateNames.forEach((template, idx) => {
            html += `
                <div style="display: flex; align-items: center; gap: 8px;">
                    <div style="width: 14px; height: 14px; background: ${templateColors[idx]}; border-radius: 3px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);"></div>
                    <span style="font-size: 13px; color: var(--gray-700); font-weight: 500;">${template}</span>
                </div>
            `;
        });
        
        html += `
            </div>
            <div style="display: flex; gap: 24px;">
                <div class="correlation-score-chart" style="flex: 1; background: #FAFAFA; border: 1px solid var(--gray-200); border-radius: 12px; padding: 20px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);">
        `;
        
        // Find max absolute correlation for scaling
        let maxAbsCorrelation = 0;
        sortedModels.forEach(([modelName, data]) => {
            templateNames.forEach(template => {
                const absCorr = Math.abs(data.correlations[template] || 0);
                if (absCorr > maxAbsCorrelation) {
                    maxAbsCorrelation = absCorr;
                }
            });
        });
        
        sortedModels.forEach(([modelName, data], modelIndex) => {
            const displayName = modelName.split('/').pop();
            
            html += `
                <div class="correlation-bar-row" style="display: flex; align-items: center; margin-bottom: ${modelIndex === sortedModels.length - 1 ? '0' : '16px'}; padding: 8px 0;">
                    <div class="model-label" style="width: 180px; font-size: 12px; color: var(--gray-700); text-align: right; padding-right: 20px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;" title="${modelName}">
                        ${displayName}
                    </div>
                    <div class="correlation-bar-container" style="flex: 1; position: relative; display: grid; grid-template-columns: repeat(3, 1fr); gap: 16px; align-items: center;">
            `;
            
            templateNames.forEach((template, idx) => {
                const correlation = data.correlations[template] || 0;
                const percentage = maxAbsCorrelation > 0 ? (Math.abs(correlation) / maxAbsCorrelation) * 100 : 0;
                const isNegative = correlation < 0;
                const dataPoints = data.dataPoints[template] || [];
                
                html += `
                    <div class="template-correlation-wrapper" style="position: relative; background: var(--gray-100); border-radius: 4px; overflow: visible;">
                        <div class="template-correlation-bar" style="
                            width: ${percentage}%;
                            height: 24px;
                            background: ${isNegative ? '#dc3545' : templateColors[idx]};
                            position: relative;
                            transition: all 0.3s ease;
                            min-width: ${correlation !== 0 ? '45px' : '0'};
                            display: flex;
                            align-items: center;
                            justify-content: flex-end;
                            padding-right: 6px;
                            box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
                            cursor: pointer;
                        " 
                        title="${template}: ${correlation.toFixed(3)}"
                        data-model="${modelName}"
                        data-template="${template}"
                        data-correlation="${correlation}"
                        data-points='${JSON.stringify(dataPoints)}'
                        onmouseover="showCorrelationPlot(event, this)"
                        onmouseout="hideCorrelationPlot()">
                            <span style="
                                color: white;
                                font-size: 11px;
                                font-weight: 600;
                                white-space: nowrap;
                                text-shadow: 0 1px 2px rgba(0,0,0,0.2);
                            ">${correlation !== 0 ? correlation.toFixed(3) : ''}</span>
                        </div>
                    </div>
                `;
            });
            
            html += `
                    </div>
                </div>
            `;
        });
        
        html += `
                </div>
                <!-- Placeholder for correlation plot -->
                <div id="correlationPlotContainer" style="width: 300px; display: none;">
                    <div style="background: #FAFAFA; border: 1px solid var(--gray-200); border-radius: 12px; padding: 16px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);">
                        <h4 id="correlationPlotTitle" style="font-size: 14px; margin-bottom: 12px; color: var(--gray-800);"></h4>
                        <canvas id="correlationPlotCanvas" width="268" height="200"></canvas>
                        <div id="correlationPlotStats" style="margin-top: 12px; font-size: 12px; color: var(--gray-600);"></div>
                    </div>
                </div>
            </div>
        </div>
        `;
        
        return html;
    }
    
    // Correlation plot functions
    let correlationPlotTimeout = null;
    
    function showCorrelationPlot(event, element) {
        // Clear any existing timeout
        if (correlationPlotTimeout) {
            clearTimeout(correlationPlotTimeout);
        }
        
        const model = element.getAttribute('data-model');
        const template = element.getAttribute('data-template');
        const correlation = parseFloat(element.getAttribute('data-correlation'));
        const dataPoints = JSON.parse(element.getAttribute('data-points'));
        
        // Show the plot container
        const container = document.getElementById('correlationPlotContainer');
        if (container) {
            container.style.display = 'block';
            
            // Update title
            const title = document.getElementById('correlationPlotTitle');
            if (title) {
                const displayName = model.split('/').pop();
                title.textContent = `${displayName} - ${template}`;
            }
            
            // Update stats
            const stats = document.getElementById('correlationPlotStats');
            if (stats) {
                stats.innerHTML = `
                    <div style="display: flex; justify-content: space-between;">
                        <span>Correlation: <strong>${correlation.toFixed(3)}</strong></span>
                        <span>n = ${dataPoints.length}</span>
                    </div>
                `;
            }
            
            // Draw the plot
            drawCorrelationScatterPlot(dataPoints, correlation);
        }
    }
    
    function hideCorrelationPlot() {
        // Add a small delay to prevent flicker when moving between bars
        correlationPlotTimeout = setTimeout(() => {
            const container = document.getElementById('correlationPlotContainer');
            if (container) {
                container.style.display = 'none';
            }
        }, 100);
    }
    
    function drawCorrelationScatterPlot(dataPoints, correlation) {
        const canvas = document.getElementById('correlationPlotCanvas');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        const width = 268;
        const height = 200;
        
        // Clear canvas
        ctx.clearRect(0, 0, width, height);
        
        // Fill background with off-white
        ctx.fillStyle = '#FAFAFA';
        ctx.fillRect(0, 0, width, height);
        
        if (!dataPoints || dataPoints.length === 0) return;
        
        // Calculate bounds
        const xValues = dataPoints.map(p => Math.log10(p.search_count || 1));
        const yValues = dataPoints.map(p => p.knowledge_score);
        
        const xMin = Math.min(...xValues);
        const xMax = Math.max(...xValues);
        const yMin = 0.5;
        const yMax = 3.5;
        
        const padding = 30;
        const plotWidth = width - 2 * padding;
        const plotHeight = height - 2 * padding;
        
        // Draw axes
        ctx.strokeStyle = '#dee2e6';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(padding, padding);
        ctx.lineTo(padding, height - padding);
        ctx.lineTo(width - padding, height - padding);
        ctx.stroke();
        
        // Draw grid lines
        ctx.strokeStyle = '#f0f0f0';
        ctx.lineWidth = 0.5;
        
        // Y grid lines (knowledge levels)
        [1, 2, 3].forEach(level => {
            const y = height - padding - ((level - yMin) / (yMax - yMin)) * plotHeight;
            ctx.beginPath();
            ctx.moveTo(padding, y);
            ctx.lineTo(width - padding, y);
            ctx.stroke();
        });
        
        // Plot points
        dataPoints.forEach(point => {
            const x = padding + ((Math.log10(point.search_count || 1) - xMin) / (xMax - xMin)) * plotWidth;
            const y = height - padding - ((point.knowledge_score - yMin) / (yMax - yMin)) * plotHeight;
            
            // Color based on knowledge level
            switch(point.knowledge_score) {
                case 1: ctx.fillStyle = '#fff3cd'; break;
                case 2: ctx.fillStyle = '#d1ecf1'; break;
                case 3: ctx.fillStyle = '#d4edda'; break;
                default: ctx.fillStyle = '#e2e3e5';
            }
            
            ctx.beginPath();
            ctx.arc(x, y, 3, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = '#6c757d';
            ctx.lineWidth = 0.5;
            ctx.stroke();
        });
        
        // Draw trend line if significant correlation
        if (Math.abs(correlation) > 0.1) {
            // Simple linear regression
            const n = xValues.length;
            const sumX = xValues.reduce((a, b) => a + b, 0);
            const sumY = yValues.reduce((a, b) => a + b, 0);
            const sumXY = xValues.reduce((sum, x, i) => sum + x * yValues[i], 0);
            const sumX2 = xValues.reduce((sum, x) => sum + x * x, 0);
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            ctx.strokeStyle = correlation > 0 ? '#28a745' : '#dc3545';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            
            const x1 = padding;
            const y1 = height - padding - ((slope * xMin + intercept - yMin) / (yMax - yMin)) * plotHeight;
            const x2 = width - padding;
            const y2 = height - padding - ((slope * xMax + intercept - yMin) / (yMax - yMin)) * plotHeight;
            
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        // Add axis labels
        ctx.fillStyle = '#6c757d';
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Log(Search Count)', width / 2, height - 5);
        
        ctx.save();
        ctx.translate(10, height / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText('Knowledge', 0, 0);
        ctx.restore();
    }
    
    function setupCorrelationHoverEffects() {
        // Keep plot visible when hovering over it
        const plotContainer = document.getElementById('correlationPlotContainer');
        if (plotContainer) {
            plotContainer.addEventListener('mouseenter', () => {
                if (correlationPlotTimeout) {
                    clearTimeout(correlationPlotTimeout);
                }
            });
            
            plotContainer.addEventListener('mouseleave', () => {
                hideCorrelationPlot();
            });
        }
    }
    
    function renderTemplateAnalysisTables(templateArray, inputTypeArray, modelData) {
        let html = '';
        
        // Template descriptions
        const templateDescriptions = {
            'template1_knowlege': 'Basic knowledge level assessment template (limited, moderate, extensive)',
            'template2_knowlege': 'Knowledge level assessment template with NA support', 
            'template3_knowlege': 'Alternative knowledge level assessment template with NA support'
        };
        
        // Create compact table layout for each template
        templateArray.forEach((templateName, templateIndex) => {
            html += `<section class="section-callout section-callout--purple">`;
            html += `<div class="section-callout__content section-callout__content--full-width">`;
            
            // Section header with title and description
            html += `<div class="section-callout__header">`;
            html += `<h3 class="section-callout__title">`;
            html += `<a href="/templates" class="template-header-link" onclick="scrollToTemplate('${templateName}')" style="color: inherit; text-decoration: none;">${templateName}</a>`;
            html += `</h3>`;
            html += `<p class="section-callout__text">${templateDescriptions[templateName] || 'Template for model evaluation'}. The bar charts below show response distributions for each model across the artificial species categories.</p>`;
            html += `</div>`;
            
            html += createBarChartLegend();
            
            html += `<div class="table-fade" id="table-fade-${templateIndex}">`;
            html += `<table class="knowledge-analysis-table">`;
            
            // Header row
            html += `<thead><tr>`;
            html += `<th>Model</th>`;
            inputTypeArray.forEach(inputType => {
                const displayType = formatTypeName(inputType);
                html += `<th>${displayType}</th>`;
            });
            html += `<th style="text-align: center; width: 120px;">Quality Score</th>`;
            html += `</tr></thead>`;
            
            // Data rows
            html += `<tbody>`;
            
            // Calculate metrics for sorting
            const modelScores = Object.entries(modelData)
                .filter(([modelName, templates]) => templates[templateName])
                .map(([modelName, templates]) => {
                    let totalQualityScore = 0;
                    let totalSamples = 0;
                    
                    inputTypeArray.forEach(inputType => {
                        const data = templates[templateName][inputType];
                        if (data) {
                            const naFailedCount = (data.NA || 0) + (data.no_result || 0) + (data.inference_failed || 0);
                            const limitedCount = data.limited || 0;
                            const moderateCount = data.moderate || 0;
                            const extensiveCount = data.extensive || 0;
                            
                            totalQualityScore += (naFailedCount * 3) + (limitedCount * 2) + (moderateCount * 1) + (extensiveCount * 0);
                            totalSamples += data.total || 0;
                        }
                    });
                    
                    return {
                        modelName,
                        templates: templates[templateName],
                        qualityScore: totalQualityScore,
                        totalSamples,
                        averageQualityScore: totalSamples > 0 ? totalQualityScore / totalSamples : 0
                    };
                })
                .sort((a, b) => {
                    // Sort by quality score (higher is better)
                    if (b.averageQualityScore !== a.averageQualityScore) {
                        return b.averageQualityScore - a.averageQualityScore;
                    }
                    // Secondary: by total quality score
                    if (b.qualityScore !== a.qualityScore) {
                        return b.qualityScore - a.qualityScore;
                    }
                    // Final fallback: alphabetical by model name
                    return a.modelName.localeCompare(b.modelName);
                });
            
            modelScores.forEach(({modelName, templates, averageQualityScore, qualityScore, totalSamples}, index) => {
                const isHidden = index >= 3;
                html += `<tr class="${isHidden ? 'hidden-row' : ''}">`;
                html += `<td class="model-name-cell">${modelName.split('/').pop()}</td>`;
                
                inputTypeArray.forEach(inputType => {
                    html += `<td class="chart-cell">`;
                    if (templates[inputType]) {
                        html += createKnowledgeBarChart(templates[inputType]);
                    } else {
                        html += '<div class="no-data">No data</div>';
                    }
                    html += `</td>`;
                });
                
                // Add quality score column
                html += `<td class="quality-score-cell">`;
                if (totalSamples > 0) {
                    html += `<span class="quality-score-value">${averageQualityScore.toFixed(2)}</span>`;
                } else {
                    html += '<span style="color: #6c757d; font-style: italic; font-size: 11px;">No data</span>';
                }
                html += `</td>`;
                
                html += `</tr>`;
            });
            html += `</tbody></table>`;
            
            // Add expand/collapse button if there are more than 3 models
            if (modelScores.length > 3) {
                html += `<div class="table-controls">`;
                html += `<button class="expand-button" onclick="toggleTableExpansion(this, ${templateIndex})">`;
                html += `<span>Show ${modelScores.length - 3} more models</span>`;
                html += `<svg class="expand-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">`;
                html += `<path d="M6 9l6 6 6-6"/>`;
                html += `</svg>`;
                html += `</button>`;
                html += `</div>`;
            }
            
            html += `</div>`;
            html += `</div>`;
            html += `</section>`;
        });
        
        return html;
    }
    
    // Create quality score bar chart
    function createQualityScoreBarChart(modelScores, modelData, templateArray) {
        // Calculate scores per template for each model
        const modelScoresPerTemplate = {};
        
        Object.entries(modelData).forEach(([modelName, templates]) => {
            modelScoresPerTemplate[modelName] = {};
            let totalScore = 0;
            let totalSamples = 0;
            let hasAllTemplates = true;
            
            templateArray.forEach(templateName => {
                if (templates[templateName]) {
                    let templateScore = 0;
                    let templateSamples = 0;
                    
                    Object.values(templates[templateName]).forEach(stats => {
                        const naFailedCount = (stats.NA || 0) + (stats.no_result || 0) + (stats.inference_failed || 0);
                        const limitedCount = stats.limited || 0;
                        const moderateCount = stats.moderate || 0;
                        const extensiveCount = stats.extensive || 0;
                        templateScore += (naFailedCount * 3) + (limitedCount * 2) + (moderateCount * 1) + (extensiveCount * 0);
                        templateSamples += stats.total || 0;
                    });
                    
                    if (templateSamples > 0) {
                        modelScoresPerTemplate[modelName][templateName] = templateScore / templateSamples;
                        totalScore += templateScore;
                        totalSamples += templateSamples;
                    } else {
                        hasAllTemplates = false;
                    }
                } else {
                    hasAllTemplates = false;
                }
            });
            
            if (totalSamples > 0 && hasAllTemplates) {
                modelScoresPerTemplate[modelName].average = totalScore / totalSamples;
                modelScoresPerTemplate[modelName].hasAllTemplates = true;
            } else {
                // Remove models that don't have all templates
                delete modelScoresPerTemplate[modelName];
            }
        });
        
        // Sort models by average score, only including those with all templates
        const sortedModels = Object.entries(modelScoresPerTemplate)
            .filter(([_, scores]) => scores.average !== undefined && scores.hasAllTemplates)
            .sort((a, b) => b[1].average - a[1].average);
        
        // Define colors for each template - matching the page's color scheme
        const templateColors = {
            0: '#8b5cf6', // Purple (matching the gradient colors)
            1: '#06b6d4', // Cyan
            2: '#f59e0b'  // Amber
        };
        
        let html = `
        <div class="quality-score-chart-container" style="margin-top: 48px; margin-bottom: 48px;">
            <div style="max-width: 850px; margin: 0 auto;">
                <h3 class="section-title" style="font-size: 24px; margin-bottom: 16px;">Model Quality Score Distribution by Template</h3>
                <p class="article-text" style="margin-bottom: 24px;">This chart shows quality scores for each model stratified by template. Higher scores indicate better performance at recognizing fictional species. Only models with results for all templates are shown.</p>
            </div>
            
            <!-- Legend -->
            <div class="legend">
        `;
        
        templateArray.forEach((template, idx) => {
            html += `
                <div style="display: flex; align-items: center; gap: 8px;">
                    <div style="width: 14px; height: 14px; background: ${templateColors[idx]}; border-radius: 3px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);"></div>
                    <span style="font-size: 13px; color: var(--gray-700); font-weight: 500;">${template}</span>
                </div>
            `;
        });
        
        html += `
            </div>
            <div class="quality-score-chart" style="position: relative; background: #FAFAFA; border-radius: 12px; padding: 20px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);">
        `;
        
        // Find max score for scaling
        let maxScore = 0;
        sortedModels.forEach(([modelName, scores]) => {
            templateArray.forEach(template => {
                if (scores[template] && scores[template] > maxScore) {
                    maxScore = scores[template];
                }
            });
        });
        
        sortedModels.forEach(([modelName, scores], modelIndex) => {
            const displayName = modelName.split('/').pop();
            
            html += `
                <div class="score-bar-row" style="display: flex; align-items: center; margin-bottom: ${modelIndex === sortedModels.length - 1 ? '0' : '4px'}; padding: 4px 0;">
                    <div class="model-label" style="width: 180px; font-size: 12px; color: var(--gray-700); text-align: right; padding-right: 20px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;" title="${modelName}">
                        ${displayName}
                    </div>
                    <div class="score-bar-container" style="flex: 1; position: relative; display: grid; grid-template-columns: repeat(3, 1fr); gap: 2px; align-items: center;">
            `;
            
            templateArray.forEach((template, idx) => {
                const score = scores[template] || 0;
                const percentage = maxScore > 0 ? (score / maxScore) * 100 : 0;
                
                html += `
                    <div class="template-bar-wrapper" style="position: relative; background: var(--gray-100); border-radius: 4px; overflow: hidden;">
                        <div class="template-bar" style="
                            width: ${percentage}%;
                            height: 24px;
                            background: ${templateColors[idx]};
                            position: relative;
                            transition: all 0.3s ease;
                            min-width: ${score > 0 ? '45px' : '0'};
                            display: flex;
                            align-items: center;
                            justify-content: flex-end;
                            padding-right: 6px;
                            box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
                        " title="${template}: ${score.toFixed(2)}">
                            <span style="
                                color: white;
                                font-size: 11px;
                                font-weight: 600;
                                white-space: nowrap;
                                text-shadow: 0 1px 2px rgba(0,0,0,0.2);
                            ">${score > 0 ? score.toFixed(2) : ''}</span>
                        </div>
                    </div>
                `;
            });
            
            html += `
                    </div>
                </div>
            `;
        });
        
        html += `
            </div>
        </div>
        `;
        
        return html;
    }
    
    // Create bar chart for knowledge distribution
    function createKnowledgeBarChart(data) {
        const total = data.total || 0;
        if (total === 0) {
            return '<div class="no-data">No data</div>';
        }
        
        // Calculate percentages
        const segments = [
            { type: 'na', count: data.NA || 0, class: 'knowledge-na' },
            { type: 'limited', count: data.limited || 0, class: 'knowledge-limited' },
            { type: 'moderate', count: data.moderate || 0, class: 'knowledge-moderate' },
            { type: 'extensive', count: data.extensive || 0, class: 'knowledge-extensive' },
            { type: 'failed', count: (data.no_result || 0) + (data.inference_failed || 0), class: 'knowledge-failed' }
        ].filter(seg => seg.count > 0);
        
        let html = '<div class="bar-chart-container">';
        html += '<div class="bar-chart-segments">';
        
        segments.forEach(seg => {
            const percentage = (seg.count / total * 100).toFixed(1);
            const showNumber = seg.count >= 5 || percentage >= 10;
            
            html += `<div class="bar-segment ${seg.class} ${showNumber ? 'show-number' : ''}" 
                        style="width: ${percentage}%"
                        data-count="${seg.count}"
                        data-type="${seg.type}"
                        data-total="${total}"
                        onmouseover="showBarTooltip(event, this)"
                        onmouseout="hideBarTooltip()">`;
            html += `<span class="bar-number">${seg.count}</span>`;
            html += '</div>';
        });
        
        html += '</div>';
        html += '</div>';
        
        return html;
    }
    
    // Bar tooltip functions
    let barTooltip = null;
    
    function showBarTooltip(event, element) {
        const count = element.getAttribute('data-count');
        const type = element.getAttribute('data-type');
        const total = element.getAttribute('data-total');
        const percentage = ((parseFloat(count) / parseFloat(total)) * 100).toFixed(1);
        
        // Hide any existing tooltip
        hideBarTooltip();
        
        // Create tooltip
        barTooltip = document.createElement('div');
        barTooltip.className = 'bar-tooltip';
        barTooltip.style.cssText = `
            position: fixed;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            white-space: nowrap;
        `;
        
        const typeLabels = {
            'na': 'NA/Unknown',
            'limited': 'Limited',
            'moderate': 'Moderate',
            'extensive': 'Extensive',
            'failed': 'Failed/No Result'
        };
        
        barTooltip.textContent = `${typeLabels[type] || type}: ${count} (${percentage}%)`;
        document.body.appendChild(barTooltip);
        
        // Position tooltip
        const rect = element.getBoundingClientRect();
        const tooltipRect = barTooltip.getBoundingClientRect();
        
        let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);
        let top = rect.top - tooltipRect.height - 8;
        
        // Ensure tooltip stays on screen
        if (left < 10) left = 10;
        if (left + tooltipRect.width > window.innerWidth - 10) {
            left = window.innerWidth - tooltipRect.width - 10;
        }
        if (top < 10) {
            top = rect.bottom + 8;
        }
        
        barTooltip.style.left = left + 'px';
        barTooltip.style.top = top + 'px';
    }
    
    function hideBarTooltip() {
        if (barTooltip) {
            barTooltip.remove();
            barTooltip = null;
        }
    }
    
    // --- End Knowledge Analysis Data Fetch and Render ---
    
    // Initialize all animations
    // Comment out undefined functions that were causing errors
    // initPhenotypeAnimation();
    // initKnowledgeAnimation();
    // initGrowthAnimation();
    
    // Load knowledge analysis data after DOM is ready
    loadKnowledgeAnalysisData();
    
    // Load correlation data for real species
    loadCorrelationData();
    
    function animateFlowDiagram(diagram) {
        const queryTemplates = diagram.querySelectorAll('.query-template');
        const outputOptions = diagram.querySelectorAll('.output-option');
        
        if (queryTemplates.length === 0 || outputOptions.length === 0) {
            console.error('Flow diagram animation: Could not find query or output elements for a diagram.');
            return;
        }
        
        function resetHighlights() {
            queryTemplates.forEach(q => q.classList.remove('active'));
            outputOptions.forEach(o => o.classList.remove('highlight'));
            diagram.querySelectorAll('.expectation-indicator span').forEach(span => {
                span.style.display = 'none';
            });
        }
        
        const animations = [
            { query: '1', output: 'limited', duration: 3000 },
            { query: '2', output: 'na', duration: 3000 },
            { query: '3', output: 'na', duration: 3000 }
        ];
        
        let currentIndex = 0;
        
        function showNext() {
            resetHighlights();
            
            const current = animations[currentIndex];
            const queryElement = diagram.querySelector(`.query-template[data-query="${current.query}"]`);
            const outputElement = diagram.querySelector(`.output-option[data-level="${current.output}"]`);
            const naOption = diagram.querySelector('.output-option[data-level="na"]');

            // Show/hide NA option based on query with smooth transition
            if (current.query === '1') {
                if (naOption) {
                    naOption.classList.add('hide');
                }
            } else {
                if (naOption) {
                    naOption.classList.remove('hide');
                }
            }

            if (queryElement && outputElement) {
                queryElement.classList.add('active');
                
                setTimeout(() => {
                    outputElement.classList.add('highlight');
                    const expectIndicator = outputElement.querySelector(`.expect-q${current.query}`);
                    if (expectIndicator) {
                        expectIndicator.style.display = 'inline-block';
                    }
                }, 500);
            }
            
            currentIndex = (currentIndex + 1) % animations.length;
            setTimeout(showNext, current.duration);
        }
        
        // Start with a delay to let other things settle
        setTimeout(showNext, 1500 + Math.random() * 500);
    }

    // Flow Diagram Animation - Run after a delay to ensure DOM is ready
    setTimeout(function() {
        const diagrams = document.querySelectorAll('.section-callout--purple .flow-diagram, .callout-definition .flow-diagram');
        console.log(`Found ${diagrams.length} flow diagrams to animate.`);
        diagrams.forEach((diagram, index) => {
            console.log(`Initializing animation for diagram ${index + 1}.`);
            animateFlowDiagram(diagram);
        });
    }, 1000);
    
    // Correlation Flow Animation
    function animateCorrelationFlow() {
        const flowGrid = document.querySelector('.flow-grid');
        if (!flowGrid) return;
        
        const speciesBox = flowGrid.querySelector('.flow-species');
        const llmBox = flowGrid.querySelector('#corr-llm-box');
        const webBox = flowGrid.querySelector('#corr-web-box');
        const arrows = flowGrid.querySelectorAll('.flow-arrow');
        const correlationBox = flowGrid.querySelector('.grid-correlation');
        
        const species = [
            { name: 'Bacillus subtilis', knowledge: 'Limited', webCount: '1.5 M' },
            { name: 'Escherichia coli', knowledge: 'Extensive', webCount: '45.2 M' },
            { name: 'Streptococcus pyogenes', knowledge: 'Moderate', webCount: '8.7 M' },
            { name: 'Mycobacterium tuberculosis', knowledge: 'Extensive', webCount: '23.1 M' }
        ];
        
        let currentIndex = 0;
        
        function resetHighlights() {
            arrows.forEach(arrow => arrow.classList.remove('active'));
            llmBox.classList.remove('highlight');
            webBox.classList.remove('highlight');
            correlationBox.classList.remove('highlight');
        }
        
        function animateStep() {
            resetHighlights();
            const current = species[currentIndex];
            
            // Update species name
            speciesBox.textContent = current.name;
            
            // Step 1: Highlight species to LLM path
            setTimeout(() => {
                arrows[0].classList.add('active'); // Top left arrow
                arrows[1].classList.add('active'); // Top middle arrow
                llmBox.classList.add('highlight');
                
                // Update LLM result
                const knowledgeSpan = llmBox.querySelector('.output-option');
                if (knowledgeSpan) {
                    knowledgeSpan.textContent = current.knowledge;
                    knowledgeSpan.className = 'output-option';
                    
                    // Add the appropriate background styling based on knowledge level
                    if (current.knowledge === 'Limited') {
                        knowledgeSpan.style.background = 'linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%)';
                        knowledgeSpan.style.color = '#856404';
                        knowledgeSpan.style.borderColor = 'rgba(255, 193, 7, 0.3)';
                    } else if (current.knowledge === 'Moderate') {
                        knowledgeSpan.style.background = 'linear-gradient(135deg, #d1ecf1 0%, #bee5eb 100%)';
                        knowledgeSpan.style.color = '#0c5460';
                        knowledgeSpan.style.borderColor = 'rgba(23, 162, 184, 0.3)';
                    } else if (current.knowledge === 'Extensive') {
                        knowledgeSpan.style.background = 'linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%)';
                        knowledgeSpan.style.color = '#155724';
                        knowledgeSpan.style.borderColor = 'rgba(40, 167, 69, 0.3)';
                    }
                }
            }, 300);
            
            // Step 2: Highlight species to web search path
            setTimeout(() => {
                arrows[3].classList.add('active'); // Bottom left arrow
                arrows[4].classList.add('active'); // Bottom middle arrow
                webBox.classList.add('highlight');
                webBox.textContent = current.webCount;
            }, 800);
            
            // Step 3: Highlight correlation
            setTimeout(() => {
                arrows[2].classList.add('active'); // Top right arrow
                arrows[5].classList.add('active'); // Bottom right arrow
                correlationBox.classList.add('highlight');
            }, 1300);
            
            currentIndex = (currentIndex + 1) % species.length;
            setTimeout(animateStep, 4000);
        }
        
        // Start animation
        setTimeout(animateStep, 1500);
    }
    
    // Initialize correlation animation
    setTimeout(animateCorrelationFlow, 1200);
});

// Function to scroll to template on templates page
function scrollToTemplate(templateName) {
    // Store the template name to scroll to after page loads
    sessionStorage.setItem('scrollToTemplate', templateName);
}

// Make bar tooltip functions globally available
window.showBarTooltip = showBarTooltip;
window.hideBarTooltip = hideBarTooltip;

// Toggle table expansion
function toggleTableExpansion(button, templateIndex) {
    const tableWrapper = button.closest('.knowledge-analysis-table-wrapper');
    const hiddenRows = tableWrapper.querySelectorAll('.hidden-row');
    const fadeContainer = tableWrapper.querySelector(`#table-fade-${templateIndex}`);
    const isExpanded = button.classList.contains('expanded');
    
    if (isExpanded) {
        // Collapse
        hiddenRows.forEach(row => row.classList.remove('show'));
        button.classList.remove('expanded');
        button.querySelector('span').textContent = `Show ${hiddenRows.length} more models`;
        if (fadeContainer) fadeContainer.classList.remove('expanded');
    } else {
        // Expand
        hiddenRows.forEach(row => row.classList.add('show'));
        button.classList.add('expanded');
        button.querySelector('span').textContent = 'Show less';
        if (fadeContainer) fadeContainer.classList.add('expanded');
    }
}

// Make toggleTableExpansion globally available
window.toggleTableExpansion = toggleTableExpansion;

// --- Real Species Correlation Data Fetch and Render ---
// Call this function after the main DOMContentLoaded handler
window.loadCorrelationData = loadCorrelationData;

function loadCorrelationData() {
    const container = document.getElementById('correlationContent');
    if (!container) return;
    console.log('Starting to load correlation data...');
    container.innerHTML = `<div class="loading-container"><div class="loading-progress"><div class="loading-progress-bar"></div></div><div class="loading-text">Loading knowledge-web alignment data...</div></div>`;
    
    fetch('/api/search_count_correlation')
        .then(response => {
            console.log('Response status:', response.status);
            console.log('Response ok:', response.ok);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            console.log('Correlation data received:', data);
            if (data.error) {
                container.innerHTML = `<div class='empty-state'><h3>Error loading correlation data</h3><p>${data.error}</p></div>`;
                return;
            }
            if (!data.files_with_search_counts || data.files_with_search_counts.length === 0) {
                container.innerHTML = `<div class='empty-state'><h3>No datasets with search counts found</h3><p>Upload a CSV file with a "Search Count" column to see correlation analysis.</p></div>`;
                return;
            }
            // Store data globally for scatter plot
            window.correlationData = data;
            renderCorrelationSummary(data);
            renderCorrelationStatsAndTable(data, container);
            
            // Add scatter plot section after data is loaded
            setTimeout(() => {
                addCorrelationScatterPlotSection();
                renderCorrelationScatterPlot(data);
            }, 100);
        })
        .catch(error => {
            console.error('Error loading correlation data:', error);
            container.innerHTML = `<div class='empty-state'><h3>Error loading data</h3><p>${error.message}</p></div>`;
        });
}

function renderCorrelationSummary(data) {
    const selectedDataset = data.files_with_search_counts[0];
    const fileData = data.correlation_data[selectedDataset];
    let modelResults = [];
    Object.entries(fileData).forEach(([templateName, models]) => {
        Object.entries(models).forEach(([modelName, d]) => {
            if (d.species_count < 2) return;
            modelResults.push({
                modelName,
                templateName,
                correlation: d.correlation_coefficient,
                speciesCount: d.species_count,
                knowledgeDist: d.knowledge_distribution,
                dataPoints: d.data_points
            });
        });
    });
    // Sort by correlation descending
    modelResults.sort((a, b) => b.correlation - a.correlation);
    
    const totalModels = new Set(modelResults.map(r => r.modelName)).size;
    const totalTemplates = Object.keys(fileData).length;
    const maxCorrelation = modelResults.length ? Math.max(...modelResults.map(m => m.correlation)) : 0;
    const minCorrelation = modelResults.length ? Math.min(...modelResults.map(m => m.correlation)) : 0;
    const bestModelResult = modelResults.length ? modelResults.find(m => m.correlation === maxCorrelation) : null;
    const worstModelResult = modelResults.length ? modelResults.find(m => m.correlation === minCorrelation) : null;
    
    const bestModel = bestModelResult ? bestModelResult.modelName.split('/').pop() : 'N/A';
    const worstModel = worstModelResult ? worstModelResult.modelName.split('/').pop() : 'N/A';
    
    const dynamicStatsText =
        `Our analysis of web-aligned knowledge across <span class="stat-value">${totalModels}</span> models and <span class="stat-value">${totalTemplates}</span> templates reveals how well each model's confidence aligns with real-world information availability. ` +
        `Models with higher correlation scores demonstrate better calibrationthey claim extensive knowledge for well-documented bacteria and limited knowledge for obscure species. ` +
        (bestModelResult ? `The best alignment was achieved by <span class="model-highlight">${bestModel}</span> with a correlation coefficient of <span class="stat-value">${maxCorrelation.toFixed(3)}</span>, ` +
        `indicating its knowledge claims closely match the actual web presence of bacterial species. ` : '') +
        (worstModel && bestModel !== worstModel ? `In contrast, <span class="model-lowlight">${worstModel}</span> showed the weakest alignment with a correlation of <span class="stat-value">${minCorrelation.toFixed(3)}</span>, ` +
        `suggesting its confidence assessments are less reflective of real-world information availability.` : '');

    const correlationStatsDiv = document.getElementById('correlationDynamicStats');
    if (correlationStatsDiv) {
        correlationStatsDiv.innerHTML = `<p>${dynamicStatsText}</p>`;
    }
}


function renderCorrelationStatsAndTable(data, container) {
    // Use the first dataset with search counts
    const selectedDataset = data.files_with_search_counts[0];
    const fileData = data.correlation_data[selectedDataset];
    let modelResults = [];
    Object.entries(fileData).forEach(([templateName, models]) => {
        Object.entries(models).forEach(([modelName, d]) => {
            if (d.species_count < 2) return;
            modelResults.push({
                modelName,
                templateName,
                correlation: d.correlation_coefficient,
                speciesCount: d.species_count,
                knowledgeDist: d.knowledge_distribution,
                dataPoints: d.data_points
            });
        });
    });
    // Sort by correlation descending
    modelResults.sort((a, b) => b.correlation - a.correlation);
    
    // ========================
    // NEW: Top performers call-out (Correlation)
    // ========================
    const top4CorrModels = modelResults.slice(0, 4);
    let corrTopPerformersHtml = "";
    if (top4CorrModels.length > 0) {
        corrTopPerformersHtml += `\n<div class="top-performers-section">\n    <h3 class="section-title" style="text-align: left; font-size: 24px; margin-bottom: 8px;">Top Models  Web-Alignment</h3>\n    <p class="article-text" style="margin-bottom: 24px;">Based on the Pearson correlation between claimed knowledge and Google search counts, these models show the strongest calibration to real-world information availability.</p>\n    ${createBarChartLegend()}\n    <div class="performers-list">`;

        top4CorrModels.forEach((m, idx) => {
            const displayName = m.modelName.split('/').pop();
            corrTopPerformersHtml += `\n        <div class="performer-card">\n            <div class="performer-rank">${idx + 1}</div>\n            <div style="flex: 1;">\n                <div class="performer-name">${displayName}</div>\n                <div class="performer-score">Correlation: <strong>${m.correlation.toFixed(3)}</strong></div>\n                <div class="performer-dist-chart" style="margin-top: 12px;">\n                    ${renderKnowledgeDistBar(m.knowledgeDist, m.speciesCount)}\n                </div>\n            </div>\n        </div>`;
        });

        corrTopPerformersHtml += `\n    </div>\n</div>`;
    }

    // Only display the top performers section
    container.innerHTML = corrTopPerformersHtml;
}

function renderKnowledgeDistBar(dist, total) {
    if (!total || total === 0) return '<div class="no-data">No data</div>';
    const segments = [
        { type: 'limited', count: dist.limited || 0, class: 'knowledge-limited' },
        { type: 'moderate', count: dist.moderate || 0, class: 'knowledge-moderate' },
        { type: 'extensive', count: dist.extensive || 0, class: 'knowledge-extensive' },
        { type: 'NA', count: dist.NA || 0, class: 'knowledge-na' }
    ].filter(seg => seg.count > 0);
    let html = '<div class="bar-chart-container"><div class="bar-chart-segments">';
    segments.forEach(seg => {
        const pct = (seg.count / total * 100).toFixed(1);
        html += `<div class="bar-segment ${seg.class}" style="width:${pct}%">${pct > 10 ? seg.count : ''}</div>`;
    });
    html += '</div></div>';
    return html;
}

function createBarChartLegend() {
    return `
        <div class="legend">
            <div style="display: flex; align-items: center; gap: 8px; font-size: 13px; color: var(--gray-700);" title="Model can provide in-depth, reference-level information.">
                <div style="width: 14px; height: 14px; border-radius: 4px; border: 1px solid rgba(0,0,0,0.1); background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);"></div>
                <span>Extensive</span>
            </div>
            <div style="display: flex; align-items: center; gap: 8px; font-size: 13px; color: var(--gray-700);" title="Model can give several specific details.">
                <div style="width: 14px; height: 14px; border-radius: 4px; border: 1px solid rgba(0,0,0,0.1); background: linear-gradient(135deg, #d1ecf1 0%, #bee5eb 100%);"></div>
                <span>Moderate</span>
            </div>
            <div style="display: flex; align-items: center; gap: 8px; font-size: 13px; color: var(--gray-700);" title="Model knows only basic facts or context.">
                <div style="width: 14px; height: 14px; border-radius: 4px; border: 1px solid rgba(0,0,0,0.1); background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);"></div>
                <span>Limited</span>
            </div>
            <div style="display: flex; align-items: center; gap: 8px; font-size: 13px; color: var(--gray-700);" title="Model doesn't know or no information available.">
                <div style="width: 14px; height: 14px; border-radius: 4px; border: 1px solid rgba(0,0,0,0.1); background: linear-gradient(135deg, #e2e3e5 0%, #d6d8db 100%);"></div>
                <span>NA</span>
            </div>
            <div style="display: flex; align-items: center; gap: 8px; font-size: 13px; color: var(--gray-700);" title="Model failed to generate a response or the response was not valid.">
                <div style="width: 14px; height: 14px; border-radius: 4px; border: 1px solid rgba(0,0,0,0.1); background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);"></div>
                <span>Failed</span>
            </div>
        </div>
    `;
}
// Add scatter plot visualization section
function addCorrelationScatterPlotSection() {
    // Find the last section and add after it
    const mainContent = document.querySelector('.main-content');
    if (!mainContent) return;
    
    // Create new section for scatter plot
    const scatterSection = document.createElement('section');
    scatterSection.className = 'section-callout section-callout--green';
    scatterSection.id = 'correlation-scatter-plot';
    scatterSection.style.marginTop = '60px';
    
    scatterSection.innerHTML = `
        <div class="section-callout__content">
            <div class="section-callout__header">
                <h3 class="section-callout__title">Correlation Visualization: Google Search vs. Knowledge Level</h3>
                <p class="section-callout__text">
                    This scatter plot visualizes how model-reported knowledge levels correlate with Google search counts 
                    for bacterial species. Each point represents a species, with the x-axis showing log10 of Google search 
                    results and the y-axis showing the knowledge level (1=Limited, 2=Moderate, 3=Extensive).
                </p>
            </div>
            <div id="scatter-plot-container" style="margin-top: 40px;">
                <!-- Scatter plot will be rendered here -->
            </div>
        </div>
    `;
    
    mainContent.appendChild(scatterSection);
}

// Function to render the scatter plot grid
function renderCorrelationScatterPlot(data) {
    const container = document.getElementById('scatter-plot-container');
    if (!container) return;
    
    // Get the first dataset with search counts
    const selectedDataset = data.files_with_search_counts[0];
    const fileData = data.correlation_data[selectedDataset];
    
    // Collect and aggregate data by model and knowledge level
    let aggregatedData = {};
    
    Object.entries(fileData).forEach(([templateName, models]) => {
        Object.entries(models).forEach(([modelName, modelInfo]) => {
            if (modelInfo.data_points && modelInfo.data_points.length > 0) {
                const shortName = modelName.split('/').pop();
                
                if (!aggregatedData[shortName]) {
                    aggregatedData[shortName] = {
                        correlation: modelInfo.correlation_coefficient,
                        byLevel: { 1: [], 2: [], 3: [] },
                        rawPoints: modelInfo.data_points
                    };
                }
                
                // Group by knowledge level
                modelInfo.data_points.forEach(point => {
                    const level = point.knowledge_score;
                    if (level >= 1 && level <= 3) {
                        aggregatedData[shortName].byLevel[level].push(Math.log10(point.search_count || 1));
                    }
                });
            }
        });
    });
    
    // Calculate statistics for each model and level
    const modelStats = Object.entries(aggregatedData).map(([modelName, data]) => {
        const stats = {};
        [1, 2, 3].forEach(level => {
            const values = data.byLevel[level];
            if (values.length > 0) {
                const mean = values.reduce((a, b) => a + b, 0) / values.length;
                const variance = values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / values.length;
                const sd = Math.sqrt(variance);
                stats[level] = { mean, sd, count: values.length, values };
            }
        });
        return { 
            modelName, 
            correlation: data.correlation, 
            stats,
            rawPoints: data.rawPoints 
        };
    }).filter(m => Object.keys(m.stats).length > 0);
    
    if (modelStats.length === 0) {
        container.innerHTML = '<p class="no-data">No data available for visualization</p>';
        return;
    }
    
    // Sort models by correlation for consistent ordering
    modelStats.sort((a, b) => b.correlation - a.correlation);
    
    // Calculate average statistics for all models (for background reference)
    const avgStats = {};
    [1, 2, 3].forEach(level => {
        const allMeans = [];
        const allSDs = [];
        modelStats.forEach(model => {
            if (model.stats[level]) {
                allMeans.push(model.stats[level].mean);
                allSDs.push(model.stats[level].sd);
            }
        });
        if (allMeans.length > 0) {
            avgStats[level] = {
                mean: allMeans.reduce((a, b) => a + b, 0) / allMeans.length,
                sd: allSDs.reduce((a, b) => a + b, 0) / allSDs.length
            };
        }
    });
    
    // Create grid layout
    const plotsPerRow = 4;
    const plotWidth = 280;
    const plotHeight = 220;
    const margin = { top: 35, right: 20, bottom: 45, left: 50 };
    const innerWidth = plotWidth - margin.left - margin.right;
    const innerHeight = plotHeight - margin.top - margin.bottom;
    
    // Calculate global bounds for consistent scaling across all plots
    let allXValues = [];
    modelStats.forEach(model => {
        Object.values(model.stats).forEach(stat => {
            allXValues.push(...stat.values);
        });
    });
    const globalXMin = Math.min(...allXValues) - 0.3;
    const globalXMax = Math.max(...allXValues) + 0.3;
    
    // Create grid container with legend
    let html = `
        <div style="background: transparent; padding: 32px;">
            <!-- Legend -->
            <div class="flow-legend">
                <div class="legend-item">
                    <svg width="40" height="20" style="vertical-align: middle;">
                        <circle cx="20" cy="10" r="6" fill="#6366f1" stroke="#6366f1" stroke-width="2"/>
                    </svg>
                    <span class="legend-symbol">Current Model</span>
                </div>
                <div class="legend-item">
                    <svg width="40" height="20" style="vertical-align: middle;">
                        <line x1="20" y1="0" x2="20" y2="20" stroke="#9ca3af" stroke-width="2" stroke-dasharray="4,2"/>
                    </svg>
                    <span class="legend-symbol">All Models (avg)</span>
                </div>
                <div class="legend-item">
                    <span class="legend-symbol">E</span> = Extensive knowledge
                </div>
                <div class="legend-item">
                    <span class="legend-symbol">M</span> = Moderate knowledge
                </div>
                <div class="legend-item">
                    <span class="legend-symbol">L</span> = Limited knowledge
                </div>
            </div>
            <div style="display: grid; grid-template-columns: repeat(${plotsPerRow}, 1fr); gap: 24px; max-width: 100%; margin: 0 auto;">`;
    
    // Create individual plot for each model
    modelStats.slice(0, 16).forEach((model, modelIdx) => {
        const color = '#6366f1'; // Consistent color for each model's plot
        
        html += `
            <div style="background: transparent; padding: 16px;">
                <h4 style="font-size: 14px; font-weight: 600; margin: 0 0 8px 0; color: var(--gray-900); text-align: center;">
                    ${model.modelName}
                </h4>
                <p style="font-size: 12px; color: var(--gray-600); margin: 0 0 12px 0; text-align: center;">
                    r = ${model.correlation.toFixed(3)}
                </p>
                <svg width="${plotWidth}" height="${plotHeight}" style="display: block;">
                    <!-- Background -->
                    <rect x="${margin.left}" y="${margin.top}" width="${innerWidth}" height="${innerHeight}" 
                          fill="#FAFAFA" stroke="transparent" stroke-width="0"/>
                    
                    <!-- Grid lines -->
                    <g class="grid-lines">`;
    
        // Y-axis grid lines for knowledge levels
        [1, 2, 3].forEach(level => {
            const y = margin.top + innerHeight - ((level - 0.5) / 3) * innerHeight;
            html += `<line x1="${margin.left}" y1="${y}" x2="${margin.left + innerWidth}" y2="${y}" 
                         stroke="var(--gray-200)" stroke-width="1" stroke-dasharray="2,2"/>`;
        });
        
        // X-axis grid lines
        for (let x = Math.ceil(globalXMin); x <= Math.floor(globalXMax); x++) {
            const xPos = margin.left + ((x - globalXMin) / (globalXMax - globalXMin)) * innerWidth;
            html += `<line x1="${xPos}" y1="${margin.top}" x2="${xPos}" y2="${margin.top + innerHeight}" 
                         stroke="var(--gray-200)" stroke-width="1" stroke-dasharray="2,2"/>`;
        }
        
        html += `</g>`;
        
        // Plot average of all other models as background reference
        html += `<g class="other-models-reference">`;
        
        [1, 2, 3].forEach(level => {
            if (avgStats[level]) {
                const x = margin.left + ((avgStats[level].mean - globalXMin) / (globalXMax - globalXMin)) * innerWidth;
                const y = margin.top + innerHeight - ((level - 0.5) / 3) * innerHeight;
                
                // Vertical dashed line for average position
                html += `<line x1="${x}" y1="${y - 15}" x2="${x}" y2="${y + 15}" 
                             stroke="#9ca3af" stroke-width="2" stroke-dasharray="4,2" opacity="0.8"/>`;
                
                // Horizontal line showing SD range
                const sdWidth = (avgStats[level].sd / (globalXMax - globalXMin)) * innerWidth;
                html += `<line x1="${x - sdWidth}" y1="${y}" x2="${x + sdWidth}" y2="${y}" 
                             stroke="#d1d5db" stroke-width="1" opacity="0.5"/>`;
            }
        });
        
        html += `</g>`;
        
        // Plot data for this model
        html += `<g class="model-data">`;
        
        // Plot each knowledge level
        [1, 2, 3].forEach(level => {
            if (model.stats[level]) {
                const stat = model.stats[level];
                const x = margin.left + ((stat.mean - globalXMin) / (globalXMax - globalXMin)) * innerWidth;
                const y = margin.top + innerHeight - ((level - 0.5) / 3) * innerHeight;
                
                // Error bars (horizontal for x-axis SD)
                const sdWidth = (stat.sd / (globalXMax - globalXMin)) * innerWidth;
                html += `<line x1="${x - sdWidth}" y1="${y}" x2="${x + sdWidth}" y2="${y}" 
                             stroke="${color}" stroke-width="2" opacity="0.7"/>`;
                
                // End caps for error bars
                html += `<line x1="${x - sdWidth}" y1="${y - 3}" x2="${x - sdWidth}" y2="${y + 3}" 
                             stroke="${color}" stroke-width="2" opacity="0.7"/>`;
                html += `<line x1="${x + sdWidth}" y1="${y - 3}" x2="${x + sdWidth}" y2="${y + 3}" 
                             stroke="${color}" stroke-width="2" opacity="0.7"/>`;
                
                // Mean point
                html += `<circle cx="${x}" cy="${y}" r="6" 
                             fill="${color}" fill-opacity="0.9" 
                             stroke="${color}" stroke-width="2"/>`;
            }
        });
        
        html += `</g>`;
        
        // Add axes labels
        html += `
            <!-- Y-axis labels -->
            <text x="${margin.left - 5}" y="${margin.top + innerHeight - (0.5 / 3) * innerHeight + 3}" 
                  text-anchor="end" font-size="11" fill="var(--gray-600)">L</text>
            <text x="${margin.left - 5}" y="${margin.top + innerHeight - (1.5 / 3) * innerHeight + 3}" 
                  text-anchor="end" font-size="11" fill="var(--gray-600)">M</text>
            <text x="${margin.left - 5}" y="${margin.top + innerHeight - (2.5 / 3) * innerHeight + 3}" 
                  text-anchor="end" font-size="11" fill="var(--gray-600)">E</text>
            
            <!-- X-axis labels -->`;
        
        // X-axis labels (simplified for small plots)
        for (let x = Math.ceil(globalXMin); x <= Math.floor(globalXMax); x++) {
            if (x % 2 === 0) { // Only show even numbers to avoid crowding
                const xPos = margin.left + ((x - globalXMin) / (globalXMax - globalXMin)) * innerWidth;
                html += `<text x="${xPos}" y="${margin.top + innerHeight + 15}" 
                             text-anchor="middle" font-size="10" fill="var(--gray-600)">${x}</text>`;
            }
        }
        
        // Simplified axis titles
        html += `
            <text x="${margin.left + innerWidth / 2}" y="${plotHeight - 5}" 
                  text-anchor="middle" font-size="11" fill="var(--gray-700)">
                  log Search Count
            </text>
        `;
        
        html += `
                </svg>
            </div>`;
    });
    
    // Close grid container
    html += `
            </div>
            <p class="article-text" style="margin-top: 32px; text-align: center; font-size: 14px; color: var(--gray-600);">
                Each plot shows the mean log Google search count (with  1 SD error bars) for species at each knowledge level (L=Limited, M=Moderate, E=Extensive).
                Models with positive correlation (r) show higher search counts for species they claim extensive knowledge about.
            </p>
        </div>`;
    
    container.innerHTML = html;
}

</script>

</div> <!-- Close main-content -->
{% endblock %} 