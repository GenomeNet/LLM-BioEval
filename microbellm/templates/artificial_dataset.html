{% extends "base.html" %}

{% block title %}LLM Hallucination Test - MicrobeBench{% endblock %}

{% block content %}
<h1>LLM Hallucination Test</h1>

<div class="explanation-section">
    <div class="explanation-grid">
        <div class="left-column">
            <div class="explanation-box purpose-box">
                <h3><i class="fas fa-bullseye"></i> Purpose</h3>
                <p>Large Language Models often "hallucinate" - they confidently provide information about things that don't exist. To test this behavior, we created a dataset of <strong>completely made-up bacterial strain names</strong> with varying difficulty levels.</p>
                <p>We then asked LLMs about the phenotypes of these fictional strains. Since these strains don't exist, any confident answer reveals the model is making up information rather than admitting uncertainty.</p>
            </div>
            
            <div class="explanation-box templates-box">
                <h3><i class="fas fa-file-alt"></i> Templates</h3>
                <p>We use <strong>3 different query templates</strong> to test the models:</p>
                <ul class="template-list">
                    <li><strong><a href="/templates" class="template-inline-link" onclick="scrollToTemplate('template1_knowlege')">Template 1</a>:</strong> Does NOT offer an "NA" option - forces the model to guess</li>
                    <li><strong><a href="/templates" class="template-inline-link" onclick="scrollToTemplate('template2_knowlege')">Template 2</a>:</strong> Explicitly offers "NA" as a valid response option</li>
                    <li><strong><a href="/templates" class="template-inline-link" onclick="scrollToTemplate('template3_knowlege')">Template 3</a>:</strong> Also offers "NA" option with different wording</li>
                </ul>
                <p class="template-note">Templates 2 & 3 give models the correct option to refuse answering about fake data.</p>
                <p><a href="/templates" class="template-link"><i class="fas fa-external-link-alt"></i> View full template details</a></p>
            </div>
        </div>
        
        <div class="right-column">
            <div class="explanation-box interpretation-box">
                <h3><i class="fas fa-chart-bar"></i> How to Interpret Results</h3>
                <div class="legend-with-annotation">
                    <div class="legend-row good">
                        <div class="legend-item-annotated">
                            <div class="legend-color knowledge-na"></div>
                            <span class="legend-label">NA Response</span>
                        </div>
                        <div class="annotation">✓ GOOD - Model correctly refuses to answer</div>
                    </div>
                    
                    <div class="legend-row good">
                        <div class="legend-item-annotated">
                            <div class="legend-color knowledge-no-result"></div>
                            <span class="legend-label">Failed/No Result</span>
                        </div>
                        <div class="annotation">✓ GOOD - Model fails to provide output</div>
                    </div>
                    
                    <div class="legend-row caution">
                        <div class="legend-item-annotated">
                            <div class="legend-color knowledge-limited"></div>
                            <span class="legend-label">Limited Confidence</span>
                        </div>
                        <div class="annotation">⚠ CAUTION - Some uncertainty shown</div>
                    </div>
                    
                    <div class="legend-row bad">
                        <div class="legend-item-annotated">
                            <div class="legend-color knowledge-moderate"></div>
                            <span class="legend-label">Moderate Confidence</span>
                        </div>
                        <div class="annotation">✗ BAD - Confidently making up information</div>
                    </div>
                    
                    <div class="legend-row bad">
                        <div class="legend-item-annotated">
                            <div class="legend-color knowledge-extensive"></div>
                            <span class="legend-label">Extensive Confidence</span>
                        </div>
                        <div class="annotation">✗ WORST - Very confident about fake data</div>
                    </div>
                </div>
                
                <div class="quality-score-explanation">
                    <strong>Quality Score:</strong> Higher scores = Better performance<br>
                    NA/Failed = 3 points (best) • Limited = 2 points • Moderate = 1 point • Extensive = 0 points (worst)
                </div>
            </div>
        </div>
    </div>
</div>

<div id="knowledgeAnalysisContent">
    <div class="loading-container">
        <div class="loading-progress">
            <div class="loading-progress-bar"></div>
        </div>
        <div class="loading-text">Loading knowledge analysis data...</div>
    </div>
</div>

<style>
    /* Explanation Section Styles */
    .explanation-section {
        margin-bottom: 30px;
    }
    
    .explanation-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-bottom: 20px;
    }
    
    .left-column {
        display: flex;
        flex-direction: column;
        gap: 20px;
    }
    
    .right-column {
        display: flex;
    }
    
    @media (max-width: 1024px) {
        .explanation-grid {
            grid-template-columns: 1fr;
        }
        
        .left-column {
            order: 1;
        }
        
        .right-column {
            order: 2;
        }
    }
    
    .explanation-box {
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    
    .explanation-box h3 {
        margin: 0 0 15px 0;
        color: #2c3e50;
        font-size: 18px;
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    .explanation-box h3 i {
        font-size: 20px;
        opacity: 0.7;
    }
    
    .purpose-box {
        background: #f0f7ff;
        border-color: #b3d9ff;
    }
    
    .purpose-box h3 {
        color: #0056b3;
    }
    
    .templates-box {
        background: #f5f0ff;
        border-color: #d4b3ff;
    }
    
    .templates-box h3 {
        color: #6f42c1;
    }
    
    .interpretation-box {
        background: #f8f9fa;
        flex: 1;
        display: flex;
        flex-direction: column;
    }
    
    .explanation-box p {
        margin: 0 0 10px 0;
        line-height: 1.6;
        color: #495057;
        font-size: 14px;
    }
    
    .explanation-box p:last-child {
        margin-bottom: 0;
    }
    
    .template-list {
        margin: 10px 0;
        padding-left: 20px;
    }
    
    .template-list li {
        margin-bottom: 8px;
        color: #495057;
        font-size: 14px;
        line-height: 1.5;
    }
    
    .template-note {
        font-style: italic;
        color: #6c757d;
        font-size: 13px;
        margin-top: 10px;
    }
    
    .template-link {
        display: inline-flex;
        align-items: center;
        gap: 5px;
        color: #6f42c1;
        text-decoration: none;
        font-weight: 500;
        font-size: 14px;
        transition: color 0.2s;
    }
    
    .template-link:hover {
        color: #5a32a3;
        text-decoration: underline;
    }
    
    .template-link i {
        font-size: 12px;
    }
    
    .template-inline-link {
        color: #6f42c1;
        text-decoration: none;
        transition: color 0.2s;
    }
    
    .template-inline-link:hover {
        color: #5a32a3;
        text-decoration: underline;
    }
    
    .legend-with-annotation {
        margin: 15px 0;
        flex: 1;
    }
    
    .legend-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 8px 12px;
        margin-bottom: 8px;
        border-radius: 6px;
        transition: background-color 0.2s;
    }
    
    .legend-row.good {
        background: #d4edda;
        border: 1px solid #c3e6cb;
    }
    
    .legend-row.caution {
        background: #fff3cd;
        border: 1px solid #ffeaa7;
    }
    
    .legend-row.bad {
        background: #f8d7da;
        border: 1px solid #f5c6cb;
    }
    
    .legend-item-annotated {
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    .legend-color {
        width: 20px;
        height: 20px;
        border-radius: 4px;
        border: 1px solid #dee2e6;
    }
    
    .legend-label {
        font-weight: 600;
        font-size: 13px;
        color: #2c3e50;
        min-width: 140px;
    }
    
    .annotation {
        font-size: 13px;
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 5px;
    }
    
    .legend-row.good .annotation {
        color: #155724;
    }
    
    .legend-row.caution .annotation {
        color: #856404;
    }
    
    .legend-row.bad .annotation {
        color: #721c24;
    }
    
    .quality-score-explanation {
        margin-top: 20px;
        padding: 15px;
        background: #e3f2fd;
        border: 1px solid #bbdefb;
        border-radius: 6px;
        font-size: 13px;
        line-height: 1.6;
        color: #0c5460;
    }
    
    /* Knowledge Analysis Chart Styles - Compact Layout */
    .knowledge-analysis-container {
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 20px;
    }
    
    .knowledge-analysis-table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        font-size: 12px;
    }
    
    .knowledge-analysis-table th {
        background-color: #f8f9fa;
        padding: 8px 12px;
        text-align: center;
        font-weight: 600;
        color: #495057;
        border: 1px solid #dee2e6;
        border-bottom: 2px solid #007bff;
        font-size: 11px;
        white-space: normal;
        vertical-align: top;
        line-height: 1.3;
    }
    
    .knowledge-analysis-table td {
        padding: 4px 8px;
        border: 1px solid #e9ecef;
        vertical-align: middle;
        text-align: center;
    }
    
    .model-name-cell {
        background-color: #f8f9fa;
        font-weight: 600;
        color: #495057;
        text-align: left;
        padding-left: 10px;
        font-size: 11px;
        white-space: nowrap;
        min-width: 80px;
        max-width: 100px;
        overflow: hidden;
        text-overflow: ellipsis;
        cursor: default;
        border-left: 3px solid #007bff;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    }
    
    .model-name {
        background: linear-gradient(135deg, #f8f9fa, #e9ecef);
        color: #495057;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-weight: 600;
        font-size: 13px;
        padding: 2px 6px;
        border-radius: 4px;
        border: 1px solid #dee2e6;
    }
    
    .chart-cell {
        width: 200px;
        padding: 2px;
    }
    
    .knowledge-template-section {
        background: #f8f9fa;
        border: 1px solid #e9ecef;
        border-radius: 6px;
        padding: 15px;
        margin-bottom: 15px;
    }
    
    .knowledge-template-header {
        margin-top: 0;
        margin-bottom: 15px;
        color: #495057;
        font-size: 16px;
        font-weight: 600;
        display: flex;
        align-items: center;
    }
    
    .knowledge-bar-chart {
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        padding: 15px;
    }
    
    .chart-header {
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 1px solid #e9ecef;
    }
    
    .chart-legend {
        display: flex;
        gap: 20px;
        flex-wrap: wrap;
    }
    
    .legend-item {
        display: flex;
        align-items: center;
        font-size: 12px;
        color: #495057;
    }
    
    .legend-color.knowledge-limited {
        background-color: #fff3cd;
        border: 1px solid #ffeaa7;
    }
    
    .legend-color.knowledge-moderate {
        background-color: #d1ecf1;
        border: 1px solid #bee5eb;
    }
    
    .legend-color.knowledge-extensive {
        background-color: #d4edda;
        border: 1px solid #c3e6cb;
    }
    
    .legend-color.knowledge-na {
        background-color: #e2e3e5;
        border: 1px solid #d6d8db;
    }
    
    .legend-color.knowledge-no-result {
        background-color: #f8d7da;
        border: 1px solid #f5c6cb;
    }
    
    .legend-color.knowledge-inference-failed {
        background-color: #495057;
        border: 1px solid #343a40;
    }
    
    .single-bar-chart {
        width: 100%;
        height: 16px;
    }
    
    .single-stacked-bar {
        width: 100%;
        height: 16px;
        display: flex;
        border: 1px solid #dee2e6;
        border-radius: 2px;
        overflow: hidden;
        background: #f8f9fa;
    }
    
    .bar-segment {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        font-weight: 600;
        position: relative;
        min-width: 16px; /* Minimum width to show at least the number */
        cursor: pointer;
        transition: opacity 0.2s, transform 0.1s;
    }
    
    .bar-segment:hover {
        opacity: 0.8;
        transform: scale(1.05);
        z-index: 10;
    }
    
    /* Species Tooltip Styles */
    .species-tooltip {
        position: fixed;
        z-index: 1000;
        pointer-events: none;
        filter: drop-shadow(0 2px 8px rgba(0,0,0,0.15));
    }
    
    .species-tooltip-content {
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        padding: 8px 12px;
        font-size: 11px;
        max-width: 250px;
    }
    
    .species-tooltip-header {
        font-weight: 600;
        margin-bottom: 6px;
        padding-bottom: 4px;
        border-bottom: 1px solid #e9ecef;
    }
    
    .species-tooltip-list {
        max-height: 200px;
        overflow-y: auto;
    }
    
    .species-tooltip-item {
        padding: 2px 0;
        color: #495057;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 10px;
    }
    
    .species-tooltip-more {
        margin-top: 4px;
        padding-top: 4px;
        border-top: 1px solid #e9ecef;
        font-style: italic;
        color: #6c757d;
    }
    
    /* Tooltip color themes */
    .tooltip-limited .species-tooltip-header {
        color: #856404;
        background: #fff3cd;
        padding: 4px 8px;
        margin: -8px -12px 6px;
        border-radius: 5px 5px 0 0;
    }
    
    .tooltip-moderate .species-tooltip-header {
        color: #0c5460;
        background: #d1ecf1;
        padding: 4px 8px;
        margin: -8px -12px 6px;
        border-radius: 5px 5px 0 0;
    }
    
    .tooltip-extensive .species-tooltip-header {
        color: #155724;
        background: #d4edda;
        padding: 4px 8px;
        margin: -8px -12px 6px;
        border-radius: 5px 5px 0 0;
    }
    
    .tooltip-na .species-tooltip-header {
        color: #383d41;
        background: #e2e3e5;
        padding: 4px 8px;
        margin: -8px -12px 6px;
        border-radius: 5px 5px 0 0;
    }
    
    .tooltip-failed .species-tooltip-header {
        color: #721c24;
        background: #f8d7da;
        padding: 4px 8px;
        margin: -8px -12px 6px;
        border-radius: 5px 5px 0 0;
    }
    
    /* Quality Score Tooltip */
    .quality-score-value {
        cursor: help;
        position: relative;
        display: inline-block;
        padding: 2px 6px;
        border-radius: 3px;
        background: #e3f2fd;
        transition: background-color 0.2s;
    }
    
    .quality-score-value:hover {
        background: #bbdefb;
    }
    
    /* Score Calculation Tooltip */
    .score-tooltip {
        position: fixed;
        z-index: 1000;
        pointer-events: none;
        filter: drop-shadow(0 2px 12px rgba(0,0,0,0.15));
    }
    
    .score-tooltip-content {
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 12px;
        font-size: 11px;
        min-width: 220px;
    }
    
    .score-tooltip-header {
        font-weight: 700;
        margin-bottom: 10px;
        padding-bottom: 8px;
        border-bottom: 2px solid #e9ecef;
        color: #2c3e50;
        font-size: 12px;
    }
    
    .score-tooltip-breakdown {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }
    
    .score-type-section {
        padding: 4px 0;
    }
    
    .score-type-name {
        font-weight: 600;
        color: #495057;
        margin-bottom: 4px;
        text-transform: capitalize;
    }
    
    .score-item {
        padding: 2px 6px;
        margin: 2px 0;
        border-radius: 3px;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 10px;
        display: inline-block;
    }
    
    .score-label {
        font-size: 9px;
        opacity: 0.8;
    }
    
    .score-item.score-na {
        background: #e2e3e5;
        color: #383d41;
    }
    
    .score-item.score-limited {
        background: #fff3cd;
        color: #856404;
    }
    
    .score-item.score-moderate {
        background: #d1ecf1;
        color: #0c5460;
    }
    
    .score-item.score-extensive {
        background: #d4edda;
        color: #155724;
    }
    
    .score-total {
        margin-top: 8px;
        padding-top: 8px;
        border-top: 1px solid #e9ecef;
        font-weight: 700;
        color: #2c3e50;
        font-size: 12px;
    }
    
    .bar-number {
        font-size: 11px;
        font-weight: 700;
        text-shadow: 0 0 2px rgba(255,255,255,0.8);
        z-index: 1;
        pointer-events: none;
    }
    
    .bar-segment.knowledge-inference-failed .bar-number {
        text-shadow: none;
        font-weight: 600;
    }
    
    .bar-segment.knowledge-limited {
        background-color: #fff3cd;
        color: #856404;
    }
    
    .bar-segment.knowledge-moderate {
        background-color: #d1ecf1;
        color: #0c5460;
    }
    
    .bar-segment.knowledge-extensive {
        background-color: #d4edda;
        color: #155724;
    }
    
    .bar-segment.knowledge-na {
        background-color: #e2e3e5;
        color: #6c757d;
    }
    
    .bar-segment.knowledge-no-result {
        background-color: #f8d7da;
        color: #721c24;
    }
    
    .bar-segment.knowledge-inference-failed {
        background-color: #495057;
        color: #f8f9fa;
    }
    
    .no-data {
        text-align: center;
        color: #6c757d;
        font-style: italic;
        font-size: 11px;
        padding: 8px;
    }
    
    .loading-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        padding: 60px 40px;
    }
    
    .loading-spinner {
        width: 40px;
        height: 40px;
        border: 4px solid #e9ecef;
        border-top: 4px solid #007bff;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }
    
    .loading-progress {
        width: 300px;
        height: 6px;
        background-color: #e9ecef;
        border-radius: 3px;
        overflow: hidden;
        position: relative;
    }
    
    .loading-progress-bar {
        height: 100%;
        background: linear-gradient(90deg, #007bff, #0056b3);
        border-radius: 3px;
        animation: progress-slide 2s ease-in-out infinite;
        width: 30%;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    @keyframes progress-slide {
        0% { transform: translateX(-100%); }
        50% { transform: translateX(250%); }
        100% { transform: translateX(-100%); }
    }
    
    .loading-text {
        font-size: 16px;
        color: #495057;
        font-weight: 500;
    }
    
    .empty-state {
        text-align: center;
        padding: 60px;
        color: #6c757d;
    }
    
    .empty-state h3 {
        color: #495057;
        margin-bottom: 10px;
    }
    
    /* Knowledge Modal Styles */
    .knowledge-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        z-index: 10001;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .knowledge-modal-content {
        background: white;
        border-radius: 12px;
        max-width: 90%;
        max-height: 85%;
        width: 800px;
        box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        display: flex;
        flex-direction: column;
    }
    
    .knowledge-modal-header {
        padding: 20px 24px;
        border-bottom: 1px solid #e9ecef;
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: #f8f9fa;
        border-radius: 12px 12px 0 0;
    }
    
    .knowledge-modal-header h3 {
        margin: 0;
        color: #2c3e50;
        font-size: 18px;
    }
    
    .knowledge-modal-close {
        background: none;
        border: none;
        font-size: 24px;
        cursor: pointer;
        color: #6c757d;
        padding: 0;
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: all 0.2s ease;
    }
    
    .knowledge-modal-body {
        padding: 20px 24px;
        overflow-y: auto;
        flex: 1;
    }
    
    .samples-list {
        display: flex;
        flex-direction: column;
        gap: 16px;
    }
    
    .sample-item {
        border: 1px solid #e9ecef;
        border-radius: 8px;
        overflow: hidden;
    }
    
    .sample-header {
        background: #f8f9fa;
        padding: 12px 16px;
        display: flex;
        align-items: center;
        gap: 12px;
        border-bottom: 1px solid #e9ecef;
    }
    
    .sample-number {
        background: #007bff;
        color: white;
        padding: 4px 8px;
        border-radius: 12px;
        font-size: 11px;
        font-weight: 600;
        min-width: 24px;
        text-align: center;
    }
    
    .sample-species {
        font-weight: 600;
        color: #2c3e50;
        flex: 1;
    }
    
    .sample-parsed-badge {
        background: #28a745;
        color: white;
        padding: 4px 10px;
        border-radius: 12px;
        font-size: 11px;
        font-weight: 500;
        text-transform: uppercase;
    }
    
    .sample-response {
        padding: 16px;
    }
    
    .sample-response strong {
        display: block;
        margin-bottom: 8px;
        color: #495057;
        font-size: 13px;
    }
    
    .sample-raw-full {
        background: #f8f9fa;
        border: 1px solid #e9ecef;
        border-radius: 6px;
        padding: 12px;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 12px;
        line-height: 1.4;
        color: #2c3e50;
        white-space: pre-wrap;
        word-wrap: break-word;
        margin: 0;
        max-height: 200px;
        overflow-y: auto;
    }
    
    /* Statistics cards styles */
    .analysis-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
    }
    
    .stat-card {
        background: white;
        border: 2px solid #e9ecef;
        border-radius: 8px;
        padding: 20px;
        text-align: center;
    }
    
    .stat-card.positive {
        border-color: #28a745;
        background-color: #f8fff9;
    }
    
    .stat-card.negative {
        border-color: #dc3545;
        background-color: #fff8f8;
    }
    
    .stat-card.neutral {
        border-color: #6c757d;
        background-color: #f8f9fa;
    }
    
    .stat-number {
        font-size: 28px;
        font-weight: 700;
        color: #2c3e50;
        margin-bottom: 5px;
    }
    
    .stat-label {
        font-size: 14px;
        color: #6c757d;
        font-weight: 500;
    }
    
    /* Template header styles */
    .template-header-with-description {
        margin-bottom: 15px;
    }
    
    .template-header-link {
        color: #2c3e50;
        text-decoration: none;
        transition: color 0.2s;
    }
    
    .template-header-link:hover {
        color: #6f42c1;
        text-decoration: underline;
    }
    
    .template-description-text {
        margin: 0;
        color: #6c757d;
        font-size: 13px;
        font-style: italic;
        line-height: 1.4;
    }
</style>
{% endblock %}

{% block scripts %}
<script>
    // Pass annotation data from backend to JavaScript
    const annotationData = {{ annotations|tojson }};
    
    // Format model name without hover effects
    function formatModelName(modelName) {
        if (!modelName.includes('/')) {
            return modelName;
        }
        
        const [provider, model] = modelName.split('/');
        const providerMap = {
            'anthropic': 'Anthropic',
            'openai': 'OpenAI',
            'google': 'Google',
            'meta-llama': 'Meta',
            'mistralai': 'Mistral',
            'cohere': 'Cohere',
            'x-ai': 'xAI'
        };
        
        const displayProvider = providerMap[provider] || provider.charAt(0).toUpperCase() + provider.slice(1);
        return `${displayProvider} ${model}`;
    }

    // Load knowledge analysis data on page load
    loadKnowledgeAnalysisData();
    
    function loadKnowledgeAnalysisData() {
        const container = document.getElementById('knowledgeAnalysisContent');
        
        console.log('Starting to load knowledge analysis data...');
        
        // Add timeout for loading
        const loadingTimeout = setTimeout(() => {
            container.innerHTML = `<div class="empty-state"><h3>Loading is taking longer than expected</h3><p>Please check your connection and try refreshing the page.</p></div>`;
        }, 10000); // 10 second timeout
        
        // Fetch knowledge analysis data
        fetch('/api/knowledge_analysis_data')
            .then(response => {
                clearTimeout(loadingTimeout);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                console.log('Knowledge analysis data received:', data);
                
                if (data.error) {
                    container.innerHTML = `<div class="empty-state"><h3>Error loading knowledge analysis</h3><p>${data.error}</p></div>`;
                    return;
                }
                
                const knowledgeData = data.knowledge_analysis;
                
                if (!knowledgeData || Object.keys(knowledgeData).length === 0) {
                    container.innerHTML = '<div class="empty-state"><h3>No knowledge level data available</h3><p>Process some species with knowledge templates to see the analysis.</p></div>';
                    return;
                }
                
                // Store data globally for dataset switching
                window.knowledgeAnalysisData = data;
                
                // Render the analysis interface
                renderKnowledgeAnalysisInterface(data);
            })
            .catch(error => {
                clearTimeout(loadingTimeout);
                console.error('Error loading knowledge analysis:', error);
                container.innerHTML = `<div class="empty-state"><h3>Error loading knowledge analysis</h3><p>${error.message}</p></div>`;
            });
    }
    
    function renderKnowledgeAnalysisInterface(data) {
        const container = document.getElementById('knowledgeAnalysisContent');
        const knowledgeData = data.knowledge_analysis;
        const fileList = data.file_list || Object.keys(knowledgeData);
        
        console.log('Rendering knowledge analysis interface with files:', fileList);
        
        // Clear the container first
        container.innerHTML = '';
        
        let html = '';
        
        // Content for analysis by species type
        html += '<div id="artificalAnalysisContent">';
        html += '</div>';
        
        container.innerHTML = html;
        
        // Find and render only files that have type columns
        const filesWithTypes = fileList.filter(file => {
            const fileData = knowledgeData[file];
            return fileData && fileData.has_type_column;
        });
        
        if (filesWithTypes.length > 0) {
            // For simplicity, show the first file with type data
            const selectedFile = filesWithTypes[0];
            renderDatasetAnalysis(selectedFile, knowledgeData);
        } else {
            // Show message if no files have type data
            document.getElementById('artificalAnalysisContent').innerHTML = 
                '<div class="empty-state"><h3>No data with species types found</h3><p>Upload data files with type columns to see analysis by species type.</p></div>';
        }
    }
    
    function renderDatasetAnalysis(selectedFile, knowledgeData) {
        const contentContainer = document.getElementById('artificalAnalysisContent');
        const fileData = knowledgeData[selectedFile];
        
        if (!fileData || !fileData.types || !fileData.has_type_column) {
            contentContainer.innerHTML = '<div class="empty-state"><h3>No type data available for selected dataset</h3></div>';
            return;
        }
        
        const displayName = selectedFile.replace(/\.(txt|csv)$/i, '');
        let html = '';
        
        // Reorganize data by model and input type
        const modelData = {};
        const inputTypeSet = new Set();
        const templates = new Set();
        
        Object.entries(fileData.types).forEach(([inputType, templateData]) => {
            inputTypeSet.add(inputType);
            Object.entries(templateData).forEach(([templateName, models]) => {
                templates.add(templateName);
                Object.entries(models).forEach(([modelName, stats]) => {
                    if (!modelData[modelName]) {
                        modelData[modelName] = {};
                    }
                    if (!modelData[modelName][templateName]) {
                        modelData[modelName][templateName] = {};
                    }
                    modelData[modelName][templateName][inputType] = stats;
                });
            });
        });
        
        const inputTypeArray = Array.from(inputTypeSet).sort();
        const templateArray = Array.from(templates).sort();
        
        // Calculate statistics for the stats cards
        let totalModels = 0;
        let totalTemplates = templateArray.length;
        let bestModel = null;
        let worstModel = null;
        let bestScore = -1;
        let worstScore = 4; // Start with max possible score
        let avgScore = 0;
        let scoreCount = 0;
        
        // Calculate model statistics
        Object.entries(modelData).forEach(([modelName, templates]) => {
            totalModels++;
            templateArray.forEach(templateName => {
                if (templates[templateName]) {
                    let totalQualityScore = 0;
                    let totalSamples = 0;
                    
                    inputTypeArray.forEach(inputType => {
                        const data = templates[templateName][inputType];
                        if (data) {
                            const naFailedCount = (data.NA || 0) + (data.no_result || 0) + (data.inference_failed || 0);
                            const limitedCount = data.limited || 0;
                            const moderateCount = data.moderate || 0;
                            const extensiveCount = data.extensive || 0;
                            
                            totalQualityScore += (naFailedCount * 3) + (limitedCount * 2) + (moderateCount * 1) + (extensiveCount * 0);
                            totalSamples += data.total || 0;
                        }
                    });
                    
                    if (totalSamples > 0) {
                        const averageScore = totalQualityScore / totalSamples;
                        avgScore += averageScore;
                        scoreCount++;
                        
                        if (averageScore > bestScore) {
                            bestScore = averageScore;
                            bestModel = modelName.split('/').pop();
                        }
                        
                        if (averageScore < worstScore) {
                            worstScore = averageScore;
                            worstModel = modelName.split('/').pop();
                        }
                    }
                }
            });
        });
        
        avgScore = scoreCount > 0 ? avgScore / scoreCount : 0;
        
        // Add statistics section
        html += '<div class="analysis-stats">';
        html += `<div class="stat-card neutral">`;
        html += `<div class="stat-number">${totalModels}</div>`;
        html += `<div class="stat-label">Models Analyzed</div>`;
        html += `</div>`;
        
        html += `<div class="stat-card neutral">`;
        html += `<div class="stat-number"><a href="/templates" style="color: inherit; text-decoration: none;">${totalTemplates}</a></div>`;
        html += `<div class="stat-label"><a href="/templates" style="color: inherit; text-decoration: none;">Query templates compared</a></div>`;
        html += `</div>`;
        
        html += `<div class="stat-card positive">`;
        html += `<div class="stat-number model-name">${bestModel || 'N/A'}</div>`;
        html += `<div class="stat-label">Best Performing Model</div>`;
        html += `</div>`;
        
        html += `<div class="stat-card negative">`;
        html += `<div class="stat-number model-name">${worstModel || 'N/A'}</div>`;
        html += `<div class="stat-label">Worst Performing Model</div>`;
        html += `</div>`;
        html += '</div>';
        
        html += renderTemplateAnalysisTables(templateArray, inputTypeArray, modelData);
        
        contentContainer.innerHTML = html;
    }
    
    function renderTemplateAnalysisTables(templateArray, inputTypeArray, modelData) {
        let html = '';
        
        // Template descriptions for context
        const templateDescriptions = {
            'template1_knowlege': 'Basic knowledge level assessment template (limited, moderate, extensive)',
            'template2_knowlege': 'Knowledge level assessment template with NA support', 
            'template3_knowlege': 'Alternative knowledge level assessment template with NA support'
        };
        
        // Create compact table layout for each template
        templateArray.forEach(templateName => {
            html += `<div class="knowledge-analysis-container">`;
            html += `<div class="template-header-with-description">`;
            html += `<h4 style="margin: 0 0 5px 0; color: #2c3e50; font-size: 16px;">`;
            html += `<a href="/templates" class="template-header-link" onclick="scrollToTemplate('${templateName}')">${templateName}</a>`;
            html += `</h4>`;
            html += `<p class="template-description-text">${templateDescriptions[templateName] || 'Template for model evaluation'}</p>`;
            html += `</div>`;
            
            html += `<table class="knowledge-analysis-table">`;
            
            // Header row
            html += `<thead><tr>`;
            html += `<th style="text-align: left; background-color: #e9ecef;">Model</th>`;
            inputTypeArray.forEach(inputType => {
                const displayType = inputType.replace(/_/g, ' ');
                const annotation = annotationData[inputType];
                
                if (annotation) {
                    html += `<th title="${annotation.description + ' (e.g., ' + annotation.example + ')'}" style="cursor: help;">`;
                    html += `${displayType}<br>`;
                    html += `<span style="font-weight: normal; font-size: 10px; color: #6c757d; font-style: italic;">${annotation.description}</span><br>`;
                    html += `<span style="font-weight: normal; font-size: 9px; color: #868e96;">(e.g., ${annotation.example})</span>`;
                    html += `</th>`;
                } else {
                    html += `<th>${displayType}</th>`;
                }
            });
            html += `<th style="text-align: center; background-color: #e9ecef; width: 100px; min-width: 100px;">Quality Score</th>`;
            html += `</tr></thead>`;
            
            // Data rows
            html += `<tbody>`;
            
            // Calculate metrics for sorting (quality score - higher is better)
            const modelScores = Object.entries(modelData)
                .filter(([modelName, templates]) => templates[templateName])
                .map(([modelName, templates]) => {
                    let totalQualityScore = 0;
                    let totalSamples = 0;
                    
                    inputTypeArray.forEach(inputType => {
                        const data = templates[templateName][inputType];
                        if (data) {
                            const naFailedCount = (data.NA || 0) + (data.no_result || 0) + (data.inference_failed || 0);
                            const limitedCount = data.limited || 0;
                            const moderateCount = data.moderate || 0;
                            const extensiveCount = data.extensive || 0;
                            
                            totalQualityScore += (naFailedCount * 3) + (limitedCount * 2) + (moderateCount * 1) + (extensiveCount * 0);
                            totalSamples += data.total || 0;
                        }
                    });
                    
                    return {
                        modelName,
                        templates: templates[templateName],
                        qualityScore: totalQualityScore,
                        totalSamples,
                        averageQualityScore: totalSamples > 0 ? totalQualityScore / totalSamples : 0
                    };
                })
                .sort((a, b) => {
                    // Sort by quality score (higher is better)
                    if (b.averageQualityScore !== a.averageQualityScore) {
                        return b.averageQualityScore - a.averageQualityScore;
                    }
                    // Secondary: by total quality score
                    if (b.qualityScore !== a.qualityScore) {
                        return b.qualityScore - a.qualityScore;
                    }
                    // Final fallback: alphabetical by model name
                    return a.modelName.localeCompare(b.modelName);
                });
            
            modelScores.forEach(({modelName, templates, averageQualityScore, qualityScore, totalSamples}) => {
                html += `<tr>`;
                html += `<td class="model-name-cell">${formatModelName(modelName)}</td>`;
                
                inputTypeArray.forEach(inputType => {
                    html += `<td class="chart-cell">`;
                    if (templates[inputType]) {
                        html += createKnowledgeBarChartSingle(templates[inputType], inputType);
                    } else {
                        html += '<div class="no-data">No data</div>';
                    }
                    html += `</td>`;
                });
                
                // Add quality score column with calculation breakdown
                html += `<td style="text-align: center; font-size: 11px; color: #495057; font-weight: 600; width: 100px; padding: 4px;">`;
                if (totalSamples > 0) {
                    // Calculate breakdown for hover tooltip
                    let scoreBreakdown = '';
                    let totalBreakdown = 0;
                    
                    inputTypeArray.forEach(inputType => {
                        const data = templates[inputType];
                        if (data) {
                            const naFailedCount = (data.NA || 0) + (data.no_result || 0) + (data.inference_failed || 0);
                            const limitedCount = data.limited || 0;
                            const moderateCount = data.moderate || 0;
                            const extensiveCount = data.extensive || 0;
                            
                            if (scoreBreakdown) scoreBreakdown += '\n';
                            scoreBreakdown += `${inputType.replace(/_/g, ' ')}:\n`;
                            if (naFailedCount > 0) {
                                scoreBreakdown += `  3 × ${naFailedCount} (NA/Failed) = ${3 * naFailedCount}\n`;
                                totalBreakdown += 3 * naFailedCount;
                            }
                            if (limitedCount > 0) {
                                scoreBreakdown += `  2 × ${limitedCount} (Limited) = ${2 * limitedCount}\n`;
                                totalBreakdown += 2 * limitedCount;
                            }
                            if (moderateCount > 0) {
                                scoreBreakdown += `  1 × ${moderateCount} (Moderate) = ${1 * moderateCount}\n`;
                                totalBreakdown += 1 * moderateCount;
                            }
                            if (extensiveCount > 0) {
                                scoreBreakdown += `  0 × ${extensiveCount} (Extensive) = 0\n`;
                            }
                        }
                    });
                    
                    scoreBreakdown += `\nTotal: ${totalBreakdown} / ${totalSamples} = ${averageQualityScore.toFixed(2)}`;
                    
                    // Store data safely without including raw response text
                    const scoreData = {
                        inputTypes: inputTypeArray,
                        templates: {},
                        totalSamples,
                        averageScore: averageQualityScore
                    };
                    
                    // Copy only the counts, not the samples with raw responses
                    inputTypeArray.forEach(inputType => {
                        if (templates[inputType]) {
                            scoreData.templates[inputType] = {
                                NA: templates[inputType].NA || 0,
                                limited: templates[inputType].limited || 0,
                                moderate: templates[inputType].moderate || 0,
                                extensive: templates[inputType].extensive || 0,
                                no_result: templates[inputType].no_result || 0,
                                inference_failed: templates[inputType].inference_failed || 0,
                                total: templates[inputType].total || 0
                            };
                        }
                    });
                    
                    html += `<span class="quality-score-value" 
                                   data-breakdown="${encodeURIComponent(JSON.stringify(scoreData))}"
                                   onmouseover="showScoreTooltip(event, this)"
                                   onmouseout="hideScoreTooltip()">
                                   ${averageQualityScore.toFixed(2)}
                             </span>`;
                } else {
                    html += '<span style="color: #6c757d; font-style: italic; font-size: 9px;">No data</span>';
                }
                html += `</td>`;
                
                html += `</tr>`;
            });
            html += `</tbody></table>`;
            html += `</div>`;
        });
        
        return html;
    }
    
    function createKnowledgeBarChartSingle(modelData, inputType) {
        const total = modelData.total;
        
        if (total === 0) {
            return '<div class="no-data">No data</div>';
        }
        
        // Calculate percentages
        const limitedPct = (modelData.limited / total * 100);
        const moderatePct = (modelData.moderate / total * 100);
        const extensivePct = (modelData.extensive / total * 100);
        const naPct = (modelData.NA / total * 100);
        
        // Combine failed categories
        const failedCount = (modelData.no_result || 0) + (modelData.inference_failed || 0);
        const failedPct = (failedCount / total * 100);
        const failedSamples = [...(modelData.samples?.no_result || []), ...(modelData.samples?.inference_failed || [])];
        
        // Calculate minimum visible width
        const minVisiblePct = 2;
        const segments = [
            { type: 'limited', count: modelData.limited, pct: limitedPct, class: 'knowledge-limited', samples: modelData.samples?.limited || [] },
            { type: 'moderate', count: modelData.moderate, pct: moderatePct, class: 'knowledge-moderate', samples: modelData.samples?.moderate || [] },
            { type: 'extensive', count: modelData.extensive, pct: extensivePct, class: 'knowledge-extensive', samples: modelData.samples?.extensive || [] },
            { type: 'na', count: modelData.NA, pct: naPct, class: 'knowledge-na', samples: modelData.samples?.NA || [] },
            { type: 'failed', count: failedCount, pct: failedPct, class: 'knowledge-no-result', samples: failedSamples }
        ].filter(seg => seg.count > 0);
        
        // Calculate adjusted widths
        let totalAdjustedPct = 0;
        const adjustedSegments = segments.map(seg => {
            const isImportantCategory = ['na', 'failed'].includes(seg.type);
            const minWidth = isImportantCategory && seg.count > 0 ? Math.max(minVisiblePct, 3) : minVisiblePct;
            const adjustedPct = seg.pct < minWidth && seg.count > 0 ? minWidth : seg.pct;
            totalAdjustedPct += adjustedPct;
            return { ...seg, adjustedPct };
        });
        
        // Scale down if total exceeds 100%
        const scaleFactor = totalAdjustedPct > 100 ? 100 / totalAdjustedPct : 1;
        
        // Generate unique ID for this chart
        const chartId = 'chart_' + Math.random().toString(36).substr(2, 9);
        
        let html = '<div class="single-bar-chart">';
        html += '<div class="single-stacked-bar">';
        
        adjustedSegments.forEach((seg, index) => {
            const finalWidth = seg.adjustedPct * scaleFactor;
            const label = seg.type.charAt(0).toUpperCase() + seg.type.slice(1).replace('_', ' ');
            const segmentId = `${chartId}_${index}`;
            
            html += `<div class="bar-segment ${seg.class}" style="width: ${finalWidth}%" 
                          data-samples="${encodeURIComponent(JSON.stringify(seg.samples))}"
                          data-category="${seg.type}"
                          data-count="${seg.count}"
                          onmouseover="showSpeciesTooltip(event, this)"
                          onmouseout="hideSpeciesTooltip()">`;
            
            // Show number for important categories or larger segments
            const isImportantCategory = ['na', 'failed'].includes(seg.type);
            if (finalWidth > 4 || seg.count >= 10 || isImportantCategory) {
                html += `<span class="bar-number">${seg.count}</span>`;
            }
            
            html += `</div>`;
        });
        
        html += '</div>';
        html += '</div>';
        
        return html;
    }
    
    let speciestooltip = null;
    
    function showSpeciesTooltip(event, element) {
        const samples = JSON.parse(decodeURIComponent(element.getAttribute('data-samples')));
        const category = element.getAttribute('data-category');
        const count = element.getAttribute('data-count');
        
        // Hide any existing tooltip
        hideSpeciesTooltip();
        
        // Create tooltip
        speciestooltip = document.createElement('div');
        speciestooltip.className = 'species-tooltip';
        
        // Get color class based on category
        let colorClass = '';
        switch(category) {
            case 'limited': colorClass = 'tooltip-limited'; break;
            case 'moderate': colorClass = 'tooltip-moderate'; break;
            case 'extensive': colorClass = 'tooltip-extensive'; break;
            case 'na': colorClass = 'tooltip-na'; break;
            case 'failed': colorClass = 'tooltip-failed'; break;
        }
        
        // Create content - show up to 10 species names
        const maxShow = 10;
        const speciesToShow = samples.slice(0, maxShow);
        const remaining = samples.length - maxShow;
        
        let html = `<div class="species-tooltip-content ${colorClass}">`;
        html += `<div class="species-tooltip-header">${category.charAt(0).toUpperCase() + category.slice(1).replace('_', ' ')} (${count})</div>`;
        html += '<div class="species-tooltip-list">';
        
        speciesToShow.forEach(sample => {
            html += `<div class="species-tooltip-item">${sample.species}</div>`;
        });
        
        if (remaining > 0) {
            html += `<div class="species-tooltip-more">... and ${remaining} more</div>`;
        }
        
        html += '</div></div>';
        
        speciestooltip.innerHTML = html;
        document.body.appendChild(speciestooltip);
        
        // Position tooltip
        const rect = element.getBoundingClientRect();
        const tooltipRect = speciestooltip.getBoundingClientRect();
        
        let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);
        let top = rect.top - tooltipRect.height - 10;
        
        // Ensure tooltip stays on screen
        if (left < 10) left = 10;
        if (left + tooltipRect.width > window.innerWidth - 10) {
            left = window.innerWidth - tooltipRect.width - 10;
        }
        
        // If tooltip would go above screen, show below
        if (top < 10) {
            top = rect.bottom + 10;
        }
        
        speciestooltip.style.left = left + 'px';
        speciestooltip.style.top = top + 'px';
    }
    
    function hideSpeciesTooltip() {
        if (speciestooltip) {
            speciestooltip.remove();
            speciestooltip = null;
        }
    }
    
    let scoreTooltip = null;
    
    function showScoreTooltip(event, element) {
        const data = JSON.parse(decodeURIComponent(element.getAttribute('data-breakdown')));
        
        // Hide any existing tooltip
        hideScoreTooltip();
        
        // Create tooltip
        scoreTooltip = document.createElement('div');
        scoreTooltip.className = 'score-tooltip';
        
        let html = '<div class="score-tooltip-content">';
        html += '<div class="score-tooltip-header">Quality Score Calculation</div>';
        html += '<div class="score-tooltip-breakdown">';
        
        let totalScore = 0;
        
        data.inputTypes.forEach(inputType => {
            const typeData = data.templates[inputType];
            if (typeData) {
                const naFailedCount = (typeData.NA || 0) + (typeData.no_result || 0) + (typeData.inference_failed || 0);
                const limitedCount = typeData.limited || 0;
                const moderateCount = typeData.moderate || 0;
                const extensiveCount = typeData.extensive || 0;
                
                html += `<div class="score-type-section">`;
                html += `<div class="score-type-name">${inputType.replace(/_/g, ' ')}:</div>`;
                
                if (naFailedCount > 0) {
                    const points = 3 * naFailedCount;
                    totalScore += points;
                    html += `<div class="score-item score-na">3 × ${naFailedCount} <span class="score-label">(NA/Failed)</span> = ${points}</div>`;
                }
                if (limitedCount > 0) {
                    const points = 2 * limitedCount;
                    totalScore += points;
                    html += `<div class="score-item score-limited">2 × ${limitedCount} <span class="score-label">(Limited)</span> = ${points}</div>`;
                }
                if (moderateCount > 0) {
                    const points = 1 * moderateCount;
                    totalScore += points;
                    html += `<div class="score-item score-moderate">1 × ${moderateCount} <span class="score-label">(Moderate)</span> = ${points}</div>`;
                }
                if (extensiveCount > 0) {
                    html += `<div class="score-item score-extensive">0 × ${extensiveCount} <span class="score-label">(Extensive)</span> = 0</div>`;
                }
                
                html += '</div>';
            }
        });
        
        html += `<div class="score-total">Total: ${totalScore} ÷ ${data.totalSamples} = ${data.averageScore.toFixed(2)}</div>`;
        html += '</div></div>';
        
        scoreTooltip.innerHTML = html;
        document.body.appendChild(scoreTooltip);
        
        // Position tooltip
        const rect = element.getBoundingClientRect();
        const tooltipRect = scoreTooltip.getBoundingClientRect();
        
        let left = rect.right + 10;
        let top = rect.top + (rect.height / 2) - (tooltipRect.height / 2);
        
        // If tooltip would go off right edge, show on left
        if (left + tooltipRect.width > window.innerWidth - 10) {
            left = rect.left - tooltipRect.width - 10;
        }
        
        // Ensure tooltip stays on screen vertically
        if (top < 10) top = 10;
        if (top + tooltipRect.height > window.innerHeight - 10) {
            top = window.innerHeight - tooltipRect.height - 10;
        }
        
        scoreTooltip.style.left = left + 'px';
        scoreTooltip.style.top = top + 'px';
    }
    
    function hideScoreTooltip() {
        if (scoreTooltip) {
            scoreTooltip.remove();
            scoreTooltip = null;
        }
    }
    
    function scrollToTemplate(templateName) {
        // Store the template name to scroll to after page loads
        sessionStorage.setItem('scrollToTemplate', templateName);
    }
</script>
{% endblock %} 