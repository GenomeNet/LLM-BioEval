{% extends "base.html" %}

{% block title %}Compare Model Results - MicrobeBench{% endblock %}

{% block content %}
<h1>Compare Model Results</h1>

<div class="dashboard-controls">
    <a href="/export" class="btn btn-success">
        <i class="fas fa-download"></i> Export Results
    </a>
    <a href="/import" class="btn btn-warning">
        <i class="fas fa-upload"></i> Import Results
    </a>
</div>

<div class="compare-filters">
    <div class="filter-group">
        <label for="templateFilter">Template:</label>
        <select id="templateFilter" class="form-control" onchange="updateComparison()">
            <option value="">All Templates</option>
            {% for template in templates %}
                <option value="{{ template }}">{{ template }}</option>
            {% endfor %}
        </select>
    </div>
    
    <div class="filter-group">
        <label for="speciesFileFilter">Species File:</label>
        <select id="speciesFileFilter" class="form-control" onchange="updateComparison()">
            <option value="">All Species Files</option>
            {% for file in species_files %}
                <option value="{{ file }}">{{ file }}</option>
            {% endfor %}
        </select>
    </div>
    
    <div class="filter-group">
        <label for="phenotypeFilter">Phenotype:</label>
        <select id="phenotypeFilter" class="form-control" onchange="updateComparison()">
            <option value="">All Phenotypes</option>
            <option value="gram_staining">Gram Staining</option>
            <option value="motility">Motility</option>
            <option value="aerophilicity">Aerophilicity</option>
            <option value="extreme_environment_tolerance">Extreme Environment Tolerance</option>
            <option value="biofilm_formation">Biofilm Formation</option>
            <option value="animal_pathogenicity">Animal Pathogenicity</option>
            <option value="biosafety_level">Biosafety Level</option>
            <option value="health_association">Health Association</option>
            <option value="host_association">Host Association</option>
            <option value="plant_pathogenicity">Plant Pathogenicity</option>
            <option value="spore_formation">Spore Formation</option>
            <option value="hemolysis">Hemolysis</option>
            <option value="cell_shape">Cell Shape</option>
        </select>
    </div>
    
    <div class="filter-group">
        <label for="agreementFilter">Agreement Level:</label>
        <select id="agreementFilter" class="form-control" onchange="updateComparison()">
            <option value="">All</option>
            <option value="full">Full Agreement</option>
            <option value="partial">Partial Agreement</option>
            <option value="disagreement">Disagreement</option>
        </select>
    </div>
</div>



<div id="comparisonContent">
    <div class="loading-container">
        <div class="loading-spinner"></div>
        <div class="loading-progress">
            <div class="loading-progress-bar"></div>
        </div>
        <div class="loading-text">Loading comparison data...</div>
    </div>
</div>



<style>
    .compare-filters {
        display: flex;
        gap: 15px;
        margin-bottom: 25px;
        padding: 20px;
        background-color: #f8f9fa;
        border-radius: 8px;
        flex-wrap: wrap;
    }
    
    .filter-group {
        flex: 1;
        min-width: 200px;
    }
    
    .filter-group label {
        display: block;
        margin-bottom: 5px;
        font-weight: 600;
        color: #495057;
        font-size: 14px;
    }
    

    
    .comparison-table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        margin-top: 20px;
        background: white;
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    
    .comparison-table th {
        background-color: #f8f9fa;
        padding: 12px;
        text-align: left;
        font-weight: 600;
        color: #495057;
        border-bottom: 2px solid #dee2e6;
        position: sticky;
        top: 0;
        z-index: 10;
    }
    
    .comparison-table td {
        padding: 10px 12px;
        border-bottom: 1px solid #f0f0f0;
    }
    
    .comparison-table tr:hover {
        background-color: #f8f9fa;
    }
    
    .species-name-cell {
        font-weight: 600;
        font-style: italic;
        color: #2c3e50;
    }
    
    .model-result {
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        display: inline-block;
        margin: 2px;
    }
    
    .agreement-indicator {
        display: inline-block;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        margin-right: 8px;
        vertical-align: middle;
    }
    
    .agreement-indicator.full {
        background-color: #28a745;
    }
    
    .agreement-indicator.partial {
        background-color: #ffc107;
    }
    
    .agreement-indicator.none {
        background-color: #dc3545;
    }
    
    .phenotype-comparison {
        margin-bottom: 30px;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        overflow: hidden;
        background: white;
    }
    
    .phenotype-header {
        background-color: #e9ecef;
        padding: 15px 20px;
        margin-bottom: 0;
        font-weight: 600;
        color: #495057;
        border-bottom: 1px solid #dee2e6;
    }
    
    .phenotype-comparison .comparison-table {
        margin-top: 0;
        border-radius: 0;
        box-shadow: none;
        border: none;
    }
    
    .species-comparison-row {
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        margin-bottom: 10px;
        overflow: hidden;
    }
    
    .species-comparison-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 15px;
        background-color: #f8f9fa;
        cursor: pointer;
        transition: background-color 0.2s ease;
    }
    
    .species-comparison-header:hover {
        background-color: #e9ecef;
    }
    
    .species-info {
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    .model-predictions {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        padding: 15px;
        background-color: white;
    }
    
    .model-prediction {
        background-color: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        padding: 8px 12px;
        min-width: 150px;
    }
    
    .model-name {
        font-weight: 600;
        color: #495057;
        font-size: 12px;
        margin-bottom: 4px;
    }
    
    .prediction-value {
        font-size: 14px;
        color: #2c3e50;
    }
    
    .prediction-value.missing {
        color: #6c757d;
        font-style: italic;
    }
    
    .loading-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        padding: 60px 40px;
    }
    
    .loading-spinner {
        width: 40px;
        height: 40px;
        border: 4px solid #e9ecef;
        border-top: 4px solid #007bff;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }
    
    .loading-progress {
        width: 300px;
        height: 6px;
        background-color: #e9ecef;
        border-radius: 3px;
        overflow: hidden;
        position: relative;
    }
    
    .loading-progress-bar {
        height: 100%;
        background: linear-gradient(90deg, #007bff, #0056b3);
        border-radius: 3px;
        animation: progress-slide 2s ease-in-out infinite;
        width: 30%;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    @keyframes progress-slide {
        0% { transform: translateX(-100%); }
        50% { transform: translateX(250%); }
        100% { transform: translateX(-100%); }
    }
    
    .loading-text {
        font-size: 16px;
        color: #495057;
        font-weight: 500;
    }
    
    /* Hide API status indicator on compare page */
    .status-indicator {
        display: none !important;
    }
    
    .empty-state {
        text-align: center;
        padding: 60px;
        color: #6c757d;
    }
    
    .empty-state h3 {
        color: #495057;
        margin-bottom: 10px;
    }
    
    .comparison-mode-tabs {
        display: flex;
        gap: 4px;
        margin-bottom: 20px;
        border-bottom: 2px solid #dee2e6;
    }
    
    .mode-tab {
        padding: 10px 20px;
        background: none;
        border: none;
        border-bottom: 3px solid transparent;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
        color: #6c757d;
        transition: all 0.2s ease;
    }
    
    .mode-tab:hover {
        color: #495057;
        background-color: #f8f9fa;
    }
    
    .mode-tab.active {
        color: #007bff;
        border-bottom-color: #007bff;
    }
    
    .clickable-cell {
        cursor: pointer;
        transition: all 0.2s ease;
    }
    
    .clickable-cell:hover {
        transform: scale(1.05);
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        z-index: 1;
        position: relative;
    }
    
    .type-section {
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 20px;
    }
    
    .type-header {
        margin-top: 0;
        margin-bottom: 20px;
        color: #2c3e50;
        border-bottom: 2px solid #dee2e6;
        padding-bottom: 10px;
    }
    
    .type-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 15px;
        margin-bottom: 20px;
    }
    
    .type-stat {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        padding: 15px;
        text-align: center;
    }
    
    .type-stat.agreement {
        border-color: #28a745;
        background-color: #f8fff9;
    }
    
    .type-stat.disagreement {
        border-color: #dc3545;
        background-color: #fff8f8;
    }
    
    .type-stat .stat-value {
        font-size: 24px;
        font-weight: 700;
        color: #2c3e50;
        margin-bottom: 5px;
    }
    
    .type-stat .stat-label {
        font-size: 12px;
        color: #6c757d;
        font-weight: 500;
    }
    
    .type-disagreements {
        background: #fff3cd;
        border: 1px solid #ffeaa7;
        border-radius: 6px;
        padding: 15px;
        margin-bottom: 20px;
    }
    
    .type-disagreements h5 {
        margin-top: 0;
        margin-bottom: 10px;
        color: #856404;
    }
    
    .type-disagreements ul {
        margin: 0;
        padding-left: 20px;
    }
    
    .type-disagreements li {
        margin-bottom: 5px;
        color: #856404;
    }
    
    .type-species-toggle {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        padding: 10px 15px;
        cursor: pointer;
        margin-bottom: 10px;
        transition: background-color 0.2s ease;
    }
    
    .type-species-toggle:hover {
        background-color: #e9ecef;
    }
    
    .type-species-toggle .toggle-icon {
        display: inline-block;
        width: 20px;
        transition: transform 0.2s ease;
    }
    
    .type-species-list {
        margin-top: 10px;
    }
    
    /* Knowledge Analysis Chart Styles - Compact Layout */
    .knowledge-analysis-container {
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 20px;
    }
    
    .knowledge-analysis-table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        font-size: 12px;
    }
    
    .knowledge-analysis-table th {
        background-color: #f8f9fa;
        padding: 8px 12px;
        text-align: center;
        font-weight: 600;
        color: #495057;
        border: 1px solid #dee2e6;
        border-bottom: 2px solid #007bff;
        font-size: 11px;
        white-space: nowrap;
    }
    
    .knowledge-analysis-table td {
        padding: 4px 8px;
        border: 1px solid #e9ecef;
        vertical-align: middle;
        text-align: center;
    }
    
    .model-name-cell {
        background-color: #f8f9fa;
        font-weight: 600;
        color: #495057;
        text-align: right;
        padding-right: 10px;
        font-size: 11px;
        white-space: nowrap;
        min-width: 120px;
        max-width: 140px;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    
    .chart-cell {
        width: 150px;
        padding: 2px;
    }
    
    .knowledge-type-header {
        margin-top: 0;
        margin-bottom: 20px;
        color: #2c3e50;
        border-bottom: 2px solid #9b59b6;
        padding-bottom: 10px;
        display: flex;
        align-items: center;
    }
    
    .knowledge-type-header::before {
        content: "";
        margin-right: 0px;
        font-size: 0px;
    }
    
    .knowledge-template-section {
        background: #f8f9fa;
        border: 1px solid #e9ecef;
        border-radius: 6px;
        padding: 15px;
        margin-bottom: 15px;
    }
    
    .knowledge-template-header {
        margin-top: 0;
        margin-bottom: 15px;
        color: #495057;
        font-size: 16px;
        font-weight: 600;
        display: flex;
        align-items: center;
    }
    
    .knowledge-template-header::before {
        content: "";
        margin-right: 0px;
    }
    
    .knowledge-bar-chart {
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        padding: 15px;
    }
    
    .chart-header {
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 1px solid #e9ecef;
    }
    
    .chart-legend {
        display: flex;
        gap: 20px;
        flex-wrap: wrap;
    }
    
    .legend-item {
        display: flex;
        align-items: center;
        font-size: 12px;
        color: #495057;
    }
    
    .legend-color {
        width: 16px;
        height: 16px;
        border-radius: 3px;
        margin-right: 6px;
        display: inline-block;
    }
    
    .legend-color.knowledge-limited {
        background-color: #fff3cd;
        border: 1px solid #ffeaa7;
    }
    
    .legend-color.knowledge-moderate {
        background-color: #d1ecf1;
        border: 1px solid #bee5eb;
    }
    
    .legend-color.knowledge-extensive {
        background-color: #d4edda;
        border: 1px solid #c3e6cb;
    }
    
    .legend-color.knowledge-na {
        background-color: #e2e3e5;
        border: 1px solid #d6d8db;
    }
    
    .legend-color.knowledge-no-result {
        background-color: #f8d7da;
        border: 1px solid #f5c6cb;
    }
    
    .legend-color.knowledge-inference-failed {
        background-color: #495057;
        border: 1px solid #343a40;
    }
    
    /* Correlation analysis styles */
    .strong-positive {
        color: #28a745 !important;
    }
    
    .moderate-positive {
        color: #17a2b8 !important;
    }
    
    .weak {
        color: #6c757d !important;
    }
    
    .moderate-negative {
        color: #fd7e14 !important;
    }
    
    .strong-negative {
        color: #dc3545 !important;
    }
    
    .chart-container {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }
    
    .chart-row {
        display: flex;
        align-items: center;
        gap: 10px;
        min-height: 32px;
    }
    
    .chart-y-label {
        width: 200px;
        font-size: 12px;
        font-weight: 500;
        color: #495057;
        text-align: right;
        padding-right: 10px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    
    .chart-bar-container {
        flex: 1;
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    .stacked-bar {
        flex: 1;
        height: 24px;
        display: flex;
        border: 1px solid #dee2e6;
        border-radius: 4px;
        overflow: hidden;
        background: #f8f9fa;
    }
    
    .bar-segment {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        font-weight: 600;
        cursor: help;
        transition: opacity 0.2s ease;
        position: relative;
        min-width: 16px; /* Minimum width to show at least the number */
    }
    
    .bar-segment:hover {
        opacity: 0.8;
    }
    
    .bar-number {
        font-size: 11px;
        font-weight: 700;
        text-shadow: 0 0 2px rgba(255,255,255,0.8);
        z-index: 1;
        pointer-events: none;
    }
    
    .bar-segment.knowledge-limited {
        background-color: #fff3cd;
        color: #856404;
    }
    
    .bar-segment.knowledge-moderate {
        background-color: #d1ecf1;
        color: #0c5460;
    }
    
    .bar-segment.knowledge-extensive {
        background-color: #d4edda;
        color: #155724;
    }
    
    .bar-segment.knowledge-na {
        background-color: #e2e3e5;
        color: #6c757d;
    }
    
    .bar-segment.knowledge-no-result {
        background-color: #f8d7da;
        color: #721c24;
    }
    
    .bar-segment.knowledge-inference-failed {
        background-color: #495057;
        color: white;
    }
    
    .chart-total {
        width: 50px;
        text-align: center;
        font-size: 12px;
        font-weight: 600;
        color: #495057;
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 4px;
        padding: 4px 8px;
    }
    
    .single-bar-chart {
        width: 100%;
        height: 16px;
    }
    
    .single-stacked-bar {
        width: 100%;
        height: 16px;
        display: flex;
        border: 1px solid #dee2e6;
        border-radius: 2px;
        overflow: hidden;
        background: #f8f9fa;
    }
    

    
    .no-data {
        text-align: center;
        color: #6c757d;
        font-style: italic;
        font-size: 11px;
        padding: 8px;
    }
    
    /* Knowledge Tooltip Styles */
    .knowledge-tooltip {
        position: absolute;
        background: #2c3e50;
        color: white;
        padding: 12px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        font-size: 12px;
        max-width: 400px;
        z-index: 10000;
        display: none;
        border: 1px solid #34495e;
    }
    
    .tooltip-header {
        font-weight: bold;
        margin-bottom: 8px;
        font-size: 13px;
        color: #ecf0f1;
        border-bottom: 1px solid #34495e;
        padding-bottom: 6px;
    }
    
    .tooltip-samples {
        max-height: 300px;
        overflow-y: auto;
    }
    
    .tooltip-sample {
        margin: 8px 0;
        padding: 8px;
        background: rgba(52, 73, 94, 0.5);
        border-radius: 4px;
        border-left: 3px solid #3498db;
    }
    
    .tooltip-sample:last-child {
        margin-bottom: 0;
    }
    
    .sample-species {
        color: #3498db;
        font-size: 13px;
        margin-bottom: 4px;
    }
    
    .sample-parsed {
        color: #2ecc71;
        font-size: 11px;
        margin-bottom: 4px;
        font-family: monospace;
    }
    
    .sample-raw {
        color: #ecf0f1;
        font-size: 11px;
        line-height: 1.3;
        font-family: monospace;
        background: rgba(0,0,0,0.2);
        padding: 4px 6px;
        border-radius: 3px;
        word-break: break-word;
    }
    
    .tooltip-more {
        margin-top: 8px;
        font-style: italic;
        color: #bdc3c7;
        text-align: center;
        font-size: 11px;
    }
    
    /* Enhance bar segment hover effect */
    .bar-segment {
        cursor: pointer;
        transition: opacity 0.2s ease;
    }
    
    .bar-segment:hover {
        opacity: 0.8;
        box-shadow: inset 0 0 0 1px rgba(255,255,255,0.3);
    }
    
    /* Knowledge Modal Styles */
    .knowledge-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.5);
        z-index: 10001;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .knowledge-modal-content {
        background: white;
        border-radius: 12px;
        max-width: 90%;
        max-height: 85%;
        width: 800px;
        box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        display: flex;
        flex-direction: column;
    }
    
    .knowledge-modal-header {
        padding: 20px 24px;
        border-bottom: 1px solid #e9ecef;
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: #f8f9fa;
        border-radius: 12px 12px 0 0;
    }
    
    .knowledge-modal-header h3 {
        margin: 0;
        color: #2c3e50;
        font-size: 18px;
    }
    
    .knowledge-modal-close {
        background: none;
        border: none;
        font-size: 24px;
        cursor: pointer;
        color: #6c757d;
        padding: 0;
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: all 0.2s ease;
    }
    
    .knowledge-modal-close:hover {
        background: #e9ecef;
        color: #495057;
    }
    
    .knowledge-modal-body {
        padding: 20px 24px;
        overflow-y: auto;
        flex: 1;
    }
    
    .samples-list {
        display: flex;
        flex-direction: column;
        gap: 16px;
    }
    
    .sample-item {
        border: 1px solid #e9ecef;
        border-radius: 8px;
        overflow: hidden;
    }
    
    .sample-header {
        background: #f8f9fa;
        padding: 12px 16px;
        display: flex;
        align-items: center;
        gap: 12px;
        border-bottom: 1px solid #e9ecef;
    }
    
    .sample-number {
        background: #007bff;
        color: white;
        padding: 4px 8px;
        border-radius: 12px;
        font-size: 11px;
        font-weight: 600;
        min-width: 24px;
        text-align: center;
    }
    
    .sample-species {
        font-weight: 600;
        color: #2c3e50;
        flex: 1;
    }
    
    .sample-parsed-badge {
        background: #28a745;
        color: white;
        padding: 4px 10px;
        border-radius: 12px;
        font-size: 11px;
        font-weight: 500;
        text-transform: uppercase;
    }
    
    .sample-response {
        padding: 16px;
    }
    
    .sample-response strong {
        display: block;
        margin-bottom: 8px;
        color: #495057;
        font-size: 13px;
    }
    
    .sample-raw-full {
        background: #f8f9fa;
        border: 1px solid #e9ecef;
        border-radius: 6px;
        padding: 12px;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 12px;
        line-height: 1.4;
        color: #2c3e50;
        white-space: pre-wrap;
        word-wrap: break-word;
        margin: 0;
        max-height: 200px;
        overflow-y: auto;
    }
    

</style>
{% endblock %}

{% block scripts %}
<script>
    let comparisonData = null;
    
    // Load comparison data on page load
    loadComparisonData();
    
    function loadComparisonData() {
        fetch('/api/comparison_data')
            .then(response => response.json())
            .then(data => {
                comparisonData = data;
                updateComparison();
            })
            .catch(error => {
                console.error('Error loading comparison data:', error);
                document.getElementById('comparisonContent').innerHTML = 
                    '<div class="empty-state"><h3>Error loading data</h3><p>' + error.message + '</p></div>';
            });
    }
    
    function updateComparison() {
        if (!comparisonData) return;
        
        const templateFilter = document.getElementById('templateFilter').value;
        const speciesFileFilter = document.getElementById('speciesFileFilter').value;
        const phenotypeFilter = document.getElementById('phenotypeFilter').value;
        const agreementFilter = document.getElementById('agreementFilter').value;
        
        // Filter data based on selections
        let filteredData = filterComparisonData(comparisonData, {
            template: templateFilter,
            speciesFile: speciesFileFilter,
            phenotype: phenotypeFilter,
            agreement: agreementFilter
        });
        
        // Render comparison view
        renderComparison(filteredData);
    }
    
    function filterComparisonData(data, filters) {
        let filtered = { ...data };
        
        // Apply filters
        if (filters.template) {
            filtered.comparisons = filtered.comparisons.filter(c => c.template === filters.template);
        }
        
        if (filters.speciesFile) {
            filtered.comparisons = filtered.comparisons.filter(c => c.species_file === filters.speciesFile);
        }
        
        if (filters.phenotype) {
            // Filter to show only the selected phenotype
            filtered.comparisons = filtered.comparisons.map(comp => ({
                ...comp,
                phenotypes: { [filters.phenotype]: comp.phenotypes[filters.phenotype] }
            }));
        }
        
        if (filters.agreement) {
            filtered.comparisons = filtered.comparisons.filter(comp => {
                const agreementLevel = calculateAgreementLevel(comp);
                return agreementLevel === filters.agreement;
            });
        }
        
        return filtered;
    }
    
    function calculateAgreementLevel(comparison) {
        let fullAgreement = 0;
        let partialAgreement = 0;
        let disagreement = 0;
        
        Object.values(comparison.phenotypes).forEach(phenotype => {
            const values = Object.values(phenotype.predictions).filter(v => v !== null);
            const uniqueValues = [...new Set(values)];
            
            if (values.length > 1) {
                if (uniqueValues.length === 1) {
                    fullAgreement++;
                } else if (uniqueValues.length === values.length) {
                    disagreement++;
                } else {
                    partialAgreement++;
                }
            }
        });
        
        if (disagreement > 0) return 'disagreement';
        if (partialAgreement > 0) return 'partial';
        if (fullAgreement > 0) return 'full';
        return 'none';
    }
    

    
    function renderComparison(data) {
        const container = document.getElementById('comparisonContent');
        
        if (!data.comparisons || data.comparisons.length === 0) {
            container.innerHTML = '<div class="empty-state"><h3>No comparison data available</h3><p>Process some species with multiple models to see comparisons.</p></div>';
            return;
        }
        
        let html = '<div class="comparison-mode-tabs">';
        html += '<button class="mode-tab" onclick="showComparisonMode(\'overview\')">Overview</button>';
        html += '<button class="mode-tab" onclick="showComparisonMode(\'detailed\')">Detailed</button>';
        html += '<button class="mode-tab active" onclick="showComparisonMode(\'matrix\')">Agreement Matrix</button>';
        html += '<button class="mode-tab" onclick="showComparisonMode(\'na_analysis\')">NA Analysis</button>';
        html += '<button class="mode-tab" onclick="showComparisonMode(\'knowledge_analysis\')">Knowledge Analysis</button>';
        html += '<button class="mode-tab" onclick="showComparisonMode(\'search_correlation\')">Search Count Correlation</button>';
        
        // Check if we have type data
        const hasTypes = data.comparisons.some(c => c.type && c.type !== 'unclassified');
        if (hasTypes) {
            html += '<button class="mode-tab" onclick="showComparisonMode(\'by_type\')">By Type</button>';
        }
        
        html += '</div>';
        
        html += '<div id="comparisonView">';
        html += renderMatrixMode(data);
        html += '</div>';
        
        container.innerHTML = html;
    }
    
    function showComparisonMode(mode) {
        // Update tab states
        document.querySelectorAll('.mode-tab').forEach(tab => tab.classList.remove('active'));
        
        // Find and activate the correct tab
        const tabs = document.querySelectorAll('.mode-tab');
        tabs.forEach(tab => {
            if (tab.textContent.includes(getTabDisplayName(mode))) {
                tab.classList.add('active');
            }
        });
        
        // Get current filtered data
        const templateFilter = document.getElementById('templateFilter').value;
        const speciesFileFilter = document.getElementById('speciesFileFilter').value;
        const phenotypeFilter = document.getElementById('phenotypeFilter').value;
        const agreementFilter = document.getElementById('agreementFilter').value;
        
        let filteredData = filterComparisonData(comparisonData, {
            template: templateFilter,
            speciesFile: speciesFileFilter,
            phenotype: phenotypeFilter,
            agreement: agreementFilter
        });
        
        // Render the selected mode
        const viewContainer = document.getElementById('comparisonView');
        
        switch(mode) {
            case 'overview':
                viewContainer.innerHTML = renderOverviewMode(filteredData);
                break;
            case 'detailed':
                viewContainer.innerHTML = renderDetailedMode(filteredData);
                break;
            case 'matrix':
                viewContainer.innerHTML = renderMatrixMode(filteredData);
                break;
            case 'na_analysis':
                viewContainer.innerHTML = renderNAAnalysisMode(filteredData);
                break;
            case 'knowledge_analysis':
                renderKnowledgeAnalysisMode();
                break;
            case 'search_correlation':
                renderSearchCorrelationMode();
                break;
            case 'by_type':
                viewContainer.innerHTML = renderByTypeMode(filteredData);
                break;
        }
    }
    
    function getTabDisplayName(mode) {
        const modeNames = {
            'overview': 'Overview',
            'detailed': 'Detailed',
            'matrix': 'Agreement Matrix',
            'na_analysis': 'NA Analysis',
            'knowledge_analysis': 'Knowledge Analysis',
            'search_correlation': 'Search Count Correlation',
            'by_type': 'By Type'
        };
        return modeNames[mode] || mode;
    }
    
    function renderOverviewMode(data) {
        let html = '<table class="comparison-table">';
        html += '<thead><tr>';
        html += '<th>Species</th>';
        html += '<th>Agreement Level</th>';
        html += '<th>Models Compared</th>';
        html += '<th>Conflicting Phenotypes</th>';
        html += '</tr></thead><tbody>';
        
        data.comparisons.forEach(comp => {
            const agreementLevel = calculateAgreementLevel(comp);
            const conflicts = getConflictingPhenotypes(comp);
            
            html += '<tr>';
            html += `<td class="species-name-cell">${comp.species}</td>`;
            html += `<td><span class="agreement-indicator ${agreementLevel}"></span>${agreementLevel.replace('_', ' ')}</td>`;
            html += `<td>${comp.models.join(', ')}</td>`;
            html += `<td>${conflicts.length > 0 ? conflicts.join(', ') : 'None'}</td>`;
            html += '</tr>';
        });
        
        html += '</tbody></table>';
        return html;
    }
    
    function renderDetailedMode(data) {
        let html = '';
        
        // Group by phenotype
        const phenotypes = [...new Set(data.comparisons.flatMap(c => Object.keys(c.phenotypes)))];
        
        phenotypes.forEach(phenotype => {
            html += `<div class="phenotype-comparison">`;
            html += `<div class="phenotype-header">${phenotype.replace(/_/g, ' ').toUpperCase()}</div>`;
            
            data.comparisons.forEach(comp => {
                if (!comp.phenotypes[phenotype]) return;
                
                const phenotypeData = comp.phenotypes[phenotype];
                const hasConflict = Object.keys(phenotypeData.conflicts).length > 0;
                
                html += `<div class="species-comparison-row">`;
                html += `<div class="species-comparison-header" onclick="toggleDetails(this)">`;
                html += `<div class="species-info">`;
                html += `<span class="agreement-indicator ${hasConflict ? 'none' : 'full'}"></span>`;
                html += `<span class="species-name-cell">${comp.species}</span>`;
                html += `</div>`;
                html += `<span class="toggle-icon">[+]</span>`;
                html += `</div>`;
                
                html += `<div class="model-predictions" style="display: none;">`;
                Object.entries(phenotypeData.predictions).forEach(([model, value]) => {
                    html += `<div class="model-prediction">`;
                    html += `<div class="model-name">${model}</div>`;
                    html += `<div class="prediction-value ${value ? '' : 'missing'}">${value || 'No data'}</div>`;
                    html += `</div>`;
                });
                html += `</div>`;
                html += `</div>`;
            });
            
            html += `</div>`;
        });
        
        return html;
    }
    
    function renderMatrixMode(data) {
        // Get all models and phenotypes
        const models = [...new Set(data.comparisons.flatMap(c => c.models))];
        const phenotypes = [...new Set(data.comparisons.flatMap(c => Object.keys(c.phenotypes)))];
        
        let html = '<h3>Model Agreement Matrices by Phenotype</h3>';
        html += '<p style="color: #6c757d; font-style: italic; margin-bottom: 20px;">Click on any cell with data to see detailed predictions for each species.</p>';
        
        // Create a matrix for each phenotype
        phenotypes.forEach(phenotypeName => {
            const matrix = {};
            
            // Initialize matrix for this phenotype
            models.forEach(m1 => {
                matrix[m1] = {};
                models.forEach(m2 => {
                    matrix[m1][m2] = { agree: 0, disagree: 0, total: 0 };
                });
            });
            
            // Calculate agreements for this phenotype only
            data.comparisons.forEach(comp => {
                const phenotype = comp.phenotypes[phenotypeName];
                if (phenotype) {
                    comp.models.forEach(m1 => {
                        comp.models.forEach(m2 => {
                            if (m1 !== m2) {
                                const v1 = phenotype.predictions[m1];
                                const v2 = phenotype.predictions[m2];
                                if (v1 !== null && v2 !== null) {
                                    matrix[m1][m2].total++;
                                    if (v1 === v2) {
                                        matrix[m1][m2].agree++;
                                    } else {
                                        matrix[m1][m2].disagree++;
                                    }
                                }
                            }
                        });
                    });
                }
            });
            
            // Check if this phenotype has any data
            const hasData = models.some(m1 => 
                models.some(m2 => m1 !== m2 && matrix[m1][m2].total > 0)
            );
            
            if (hasData) {
                html += '<div class="phenotype-comparison">';
                html += `<div class="phenotype-header">${phenotypeName.replace(/_/g, ' ').toUpperCase()}</div>`;
                html += '<table class="comparison-table">';
                html += '<thead><tr><th></th>';
                models.forEach(model => {
                    html += `<th>${model}</th>`;
                });
                html += '</tr></thead><tbody>';
                
                models.forEach(m1 => {
                    html += `<tr><th>${m1}</th>`;
                    models.forEach(m2 => {
                        if (m1 === m2) {
                            html += '<td style="background-color: #e9ecef; text-align: center;">-</td>';
                        } else {
                            const stats = matrix[m1][m2];
                            const agreementRate = stats.total > 0 ? (stats.agree / stats.total * 100).toFixed(1) : 0;
                            let color = '#f8f9fa'; // Default light gray for no data
                            if (stats.total > 0) {
                                color = agreementRate > 80 ? '#d4edda' : agreementRate > 60 ? '#fff3cd' : '#f8d7da';
                            }
                            if (stats.total > 0) {
                                html += `<td class="clickable-cell" style="background-color: ${color}; text-align: center;" 
                                         onclick="showPredictionDetails('${m1}', '${m2}', '${phenotypeName}', '${encodeURIComponent(JSON.stringify(data))}')"
                                         title="Click to see detailed predictions">`;
                                html += `<strong>${agreementRate}%</strong><br>`;
                                html += `<small>${stats.agree}/${stats.total}</small>`;
                            } else {
                                html += `<td style="background-color: ${color}; text-align: center;">`;
                                html += '<span style="color: #6c757d; font-style: italic;">No data</span>';
                            }
                            html += '</td>';
                        }
                    });
                    html += '</tr>';
                });
                
                html += '</tbody></table>';
                html += '</div>';
            }
        });
        
        // If no phenotypes have data, show a message
        if (!phenotypes.some(phenotypeName => {
            return data.comparisons.some(comp => {
                const phenotype = comp.phenotypes[phenotypeName];
                return phenotype && comp.models.some(m1 => 
                    comp.models.some(m2 => {
                        const v1 = phenotype.predictions[m1];
                        const v2 = phenotype.predictions[m2];
                        return m1 !== m2 && v1 !== null && v2 !== null;
                    })
                );
            });
        })) {
            html += '<div class="empty-state">';
            html += '<h3>No comparison data available</h3>';
            html += '<p>Need at least 2 models with predictions for the same phenotypes to show agreement matrices.</p>';
            html += '</div>';
        }
        
        return html;
    }
    
    function getConflictingPhenotypes(comparison) {
        const conflicts = [];
        Object.entries(comparison.phenotypes).forEach(([phenotype, data]) => {
            if (Object.keys(data.conflicts).length > 0) {
                conflicts.push(phenotype.replace(/_/g, ' '));
            }
        });
        return conflicts;
    }
    
    function toggleDetails(header) {
        const details = header.nextElementSibling;
        const icon = header.querySelector('.toggle-icon');
        
        if (details.style.display === 'none') {
            details.style.display = 'flex';
            icon.textContent = '[-]';
        } else {
            details.style.display = 'none';
            icon.textContent = '[+]';
        }
    }
    
    function renderNAAnalysisMode(data) {
        let html = '<h3>NA (Missing Data) Analysis</h3>';
        
        if (!data.comparisons || data.comparisons.length === 0) {
            html += '<div class="empty-state">';
            html += '<h3>No data available for NA analysis</h3>';
            html += '<p>Process some species to see NA statistics.</p>';
            html += '</div>';
            return html;
        }
        
        // Calculate NA statistics by model and phenotype
        const naStats = calculateNAStatistics(data);
        
        // Render NA statistics by model
        html += '<div class="phenotype-comparison">';
        html += '<div class="phenotype-header">NA Statistics by Model</div>';
        html += '<table class="comparison-table">';
        html += '<thead><tr>';
        html += '<th>Model</th>';
        html += '<th>Total Predictions</th>';
        html += '<th>NA Count</th>';
        html += '<th>NA Fraction</th>';
        html += '</tr></thead><tbody>';
        
        Object.entries(naStats.byModel).forEach(([model, stats]) => {
            const naFraction = (stats.naCount / stats.totalPredictions * 100).toFixed(1);
            html += '<tr>';
            html += `<td class="species-name-cell">${model}</td>`;
            html += `<td>${stats.totalPredictions}</td>`;
            html += `<td>${stats.naCount}</td>`;
            html += `<td><strong>${naFraction}%</strong></td>`;
            html += '</tr>';
        });
        
        html += '</tbody></table>';
        html += '</div>';
        
        // Render NA statistics by phenotype
        html += '<div class="phenotype-comparison">';
        html += '<div class="phenotype-header">NA Statistics by Phenotype</div>';
        html += '<table class="comparison-table">';
        html += '<thead><tr>';
        html += '<th>Phenotype</th>';
        html += '<th>Total Predictions</th>';
        html += '<th>NA Count</th>';
        html += '<th>NA Fraction</th>';
        html += '</tr></thead><tbody>';
        
        Object.entries(naStats.byPhenotype).forEach(([phenotype, stats]) => {
            const naFraction = (stats.naCount / stats.totalPredictions * 100).toFixed(1);
            const phenotypeName = phenotype.replace(/_/g, ' ').toUpperCase();
            html += '<tr>';
            html += `<td class="species-name-cell">${phenotypeName}</td>`;
            html += `<td>${stats.totalPredictions}</td>`;
            html += `<td>${stats.naCount}</td>`;
            html += `<td><strong>${naFraction}%</strong></td>`;
            html += '</tr>';
        });
        
        html += '</tbody></table>';
        html += '</div>';
        
        return html;
    }
    
    function calculateNAStatistics(data) {
        const stats = {
            byModel: {},
            byPhenotype: {},
            overall: { totalPredictions: 0, naCount: 0 }
        };
        
        data.comparisons.forEach(comp => {
            Object.entries(comp.phenotypes).forEach(([phenotype, phenotypeData]) => {
                Object.entries(phenotypeData.predictions).forEach(([model, value]) => {
                    // Initialize model stats
                    if (!stats.byModel[model]) {
                        stats.byModel[model] = { totalPredictions: 0, naCount: 0 };
                    }
                    
                    // Initialize phenotype stats
                    if (!stats.byPhenotype[phenotype]) {
                        stats.byPhenotype[phenotype] = { totalPredictions: 0, naCount: 0 };
                    }
                    
                    // Count total predictions
                    stats.byModel[model].totalPredictions++;
                    stats.byPhenotype[phenotype].totalPredictions++;
                    stats.overall.totalPredictions++;
                    
                    // Count NA values (null, empty, or common NA patterns)
                    if (value === null || value === '' || isNAValue(value)) {
                        stats.byModel[model].naCount++;
                        stats.byPhenotype[phenotype].naCount++;
                        stats.overall.naCount++;
                    }
                });
            });
        });
        
        return stats;
    }
    
    function isNAValue(value) {
        if (!value) return true;
        const valueStr = String(value).toLowerCase().trim();
        const naPatterns = ['na', 'n/a', 'n.a.', 'null', 'none', 'unknown', 'not available', 'not applicable', 'missing', 'no data', 'unavailable', '-', '?', 'nd', 'n.d.', 'not determined', 'not specified', 'unspecified'];
        return naPatterns.includes(valueStr);
    }
    
    function showPredictionDetails(model1, model2, phenotypeName, encodedData) {
        // Navigate to the new detailed comparison page
        const url = `/compare_details?model1=${encodeURIComponent(model1)}&model2=${encodeURIComponent(model2)}&phenotype=${encodeURIComponent(phenotypeName)}`;
        window.location.href = url;
    }
    
    function renderByTypeMode(data) {
        let html = '<h3>Comparison Results by Type</h3>';
        
        if (!data.comparisons || data.comparisons.length === 0) {
            html += '<div class="empty-state">';
            html += '<h3>No type data available</h3>';
            html += '<p>Add a "type" column to your species CSV file to see results grouped by type.</p>';
            html += '</div>';
            return html;
        }
        
        // Group comparisons by type
        const byType = {};
        data.comparisons.forEach(comp => {
            const type = comp.type || 'unclassified';
            if (!byType[type]) {
                byType[type] = [];
            }
            byType[type].push(comp);
        });
        
        // Sort types alphabetically (but put 'unclassified' last)
        const sortedTypes = Object.keys(byType).sort((a, b) => {
            if (a === 'unclassified') return 1;
            if (b === 'unclassified') return -1;
            return a.localeCompare(b);
        });
        
        // Render each type group
        sortedTypes.forEach(type => {
            const typeComparisons = byType[type];
            
            html += '<div class="type-section">';
            html += `<h4 class="type-header">${type} (${typeComparisons.length} species)</h4>`;
            
            // Calculate statistics for this type
            const typeStats = calculateTypeStatistics(typeComparisons);
            
            html += '<div class="type-stats">';
            html += `<div class="type-stat">`;
            html += `<div class="stat-value">${typeStats.totalPhenotypes}</div>`;
            html += `<div class="stat-label">Total Comparisons</div>`;
            html += `</div>`;
            html += `<div class="type-stat agreement">`;
            html += `<div class="stat-value">${typeStats.agreementRate.toFixed(1)}%</div>`;
            html += `<div class="stat-label">Agreement Rate</div>`;
            html += `</div>`;
            html += `<div class="type-stat disagreement">`;
            html += `<div class="stat-value">${typeStats.conflicts}</div>`;
            html += `<div class="stat-label">Conflicts</div>`;
            html += `</div>`;
            html += '</div>';
            
            // Show top disagreements for this type
            if (typeStats.topDisagreements.length > 0) {
                html += '<div class="type-disagreements">';
                html += '<h5>Top Disagreements:</h5>';
                html += '<ul>';
                typeStats.topDisagreements.forEach(([phenotype, count]) => {
                    html += `<li><strong>${phenotype.replace(/_/g, ' ')}:</strong> ${count} species</li>`;
                });
                html += '</ul>';
                html += '</div>';
            }
            
            // Expandable species list
            html += `<div class="type-species-toggle" onclick="toggleTypeSpecies('${type}')">`;
            html += `<span class="toggle-icon">[+]</span> View species in this type`;
            html += '</div>';
            html += `<div id="type-species-${type}" class="type-species-list" style="display: none;">`;
            html += '<table class="comparison-table">';
            html += '<thead><tr>';
            html += '<th>Species</th>';
            html += '<th>Models Compared</th>';
            html += '<th>Agreement Level</th>';
            html += '<th>Conflicts</th>';
            html += '</tr></thead><tbody>';
            
            typeComparisons.forEach(comp => {
                const agreementLevel = calculateAgreementLevel(comp);
                const conflicts = getConflictingPhenotypes(comp);
                
                html += '<tr>';
                html += `<td class="species-name-cell">${comp.species}</td>`;
                html += `<td>${comp.models.join(' vs ')}</td>`;
                html += `<td><span class="agreement-indicator ${agreementLevel}"></span>${agreementLevel}</td>`;
                html += `<td>${conflicts.length > 0 ? conflicts.join(', ') : 'None'}</td>`;
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            html += '</div>';
            html += '</div>';
        });
        
        return html;
    }
    
    function calculateTypeStatistics(typeComparisons) {
        let totalPhenotypes = 0;
        let agreements = 0;
        let conflicts = 0;
        const disagreementCounts = {};
        
        typeComparisons.forEach(comp => {
            Object.entries(comp.phenotypes).forEach(([phenotype, data]) => {
                const values = Object.values(data.predictions).filter(v => v !== null);
                if (values.length > 1) {
                    totalPhenotypes++;
                    const uniqueValues = [...new Set(values)];
                    if (uniqueValues.length === 1) {
                        agreements++;
                    } else {
                        conflicts++;
                        disagreementCounts[phenotype] = (disagreementCounts[phenotype] || 0) + 1;
                    }
                }
            });
        });
        
        const agreementRate = totalPhenotypes > 0 ? (agreements / totalPhenotypes * 100) : 0;
        
        // Get top 5 disagreements
        const topDisagreements = Object.entries(disagreementCounts)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 5);
        
        return {
            totalPhenotypes,
            agreements,
            conflicts,
            agreementRate,
            topDisagreements
        };
    }
    
    function toggleTypeSpecies(type) {
        const listDiv = document.getElementById(`type-species-${type}`);
        const icon = event.target.querySelector('.toggle-icon');
        
        if (listDiv.style.display === 'none') {
            listDiv.style.display = 'block';
            icon.textContent = '[-]';
        } else {
            listDiv.style.display = 'none';
            icon.textContent = '[+]';
        }
    }
    
    function calculateAgreementLevel(comparison) {
        let total = 0;
        let agreements = 0;
        
        Object.values(comparison.phenotypes).forEach(phenotypeData => {
            const predictions = Object.values(phenotypeData.predictions).filter(v => v !== null);
            if (predictions.length > 1) {
                total++;
                const uniqueValues = [...new Set(predictions)];
                if (uniqueValues.length === 1) {
                    agreements++;
                }
            }
        });
        
        if (total === 0) return 'No data';
        
        const agreementRate = agreements / total;
        if (agreementRate === 1) return 'Full Agreement';
        if (agreementRate >= 0.8) return 'High Agreement';
        if (agreementRate >= 0.5) return 'Moderate Agreement';
        return 'Low Agreement';
    }
    
    function getConflictingPhenotypes(comparison) {
        const conflicts = [];
        
        Object.entries(comparison.phenotypes).forEach(([phenotype, data]) => {
            const predictions = Object.values(data.predictions).filter(v => v !== null);
            if (predictions.length > 1) {
                const uniqueValues = [...new Set(predictions)];
                if (uniqueValues.length > 1) {
                    conflicts.push(phenotype.replace(/_/g, ' '));
                }
            }
        });
        
        return conflicts;
    }
    
    function renderKnowledgeAnalysisMode() {
        const viewContainer = document.getElementById('comparisonView');
        viewContainer.innerHTML = '<div class="loading-container"><div class="loading-spinner"></div><div class="loading-progress"><div class="loading-progress-bar"></div></div><div class="loading-text">Loading knowledge analysis data...</div></div>';
        
        // Fetch knowledge analysis data
        fetch('/api/knowledge_analysis_data')
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    viewContainer.innerHTML = `<div class="empty-state"><h3>Error loading knowledge analysis</h3><p>${data.error}</p></div>`;
                    return;
                }
                
                const knowledgeData = data.knowledge_analysis;
                
                if (Object.keys(knowledgeData).length === 0) {
                    viewContainer.innerHTML = '<div class="empty-state"><h3>No knowledge level data available</h3><p>Process some species with knowledge templates to see the analysis.</p></div>';
                    return;
                }
                
                // Store data globally for dataset switching
                window.knowledgeAnalysisData = data;
                
                // Render the interface with dataset selector
                renderKnowledgeAnalysisInterface(data);
            })
            .catch(error => {
                console.error('Error loading knowledge analysis:', error);
                viewContainer.innerHTML = `<div class="empty-state"><h3>Error loading knowledge analysis</h3><p>${error.message}</p></div>`;
            });
    }
    
    function renderKnowledgeAnalysisInterface(data) {
        const viewContainer = document.getElementById('comparisonView');
        const knowledgeData = data.knowledge_analysis;
        const fileList = data.file_list || Object.keys(knowledgeData);
        
        let html = '<h3>Knowledge Level Analysis by Model</h3>';
        
        // Dataset and sorting selectors
        html += '<div class="knowledge-controls" style="display: flex; gap: 20px; margin-bottom: 20px; flex-wrap: wrap;">';
        
        // Dataset selector - always show if multiple datasets available
        if (fileList.length > 1) {
            html += '<div class="filter-group" style="min-width: 300px; flex: 1;">';
            html += '<label for="knowledgeDatasetSelector" style="display: block; margin-bottom: 5px; font-weight: 600; color: #495057;">Select Dataset:</label>';
            html += '<select id="knowledgeDatasetSelector" class="form-control" onchange="switchKnowledgeDataset()">';
            fileList.forEach(filename => {
                const displayName = filename.replace(/\.(txt|csv)$/i, '');
                html += `<option value="${filename}">${displayName}</option>`;
            });
            html += '</select>';
            html += '</div>';
        } else if (fileList.length === 1) {
            // Show current dataset name even if only one
            html += '<div class="filter-group" style="min-width: 300px; flex: 1;">';
            html += '<label style="display: block; margin-bottom: 5px; font-weight: 600; color: #495057;">Dataset:</label>';
            const displayName = fileList[0].replace(/\.(txt|csv)$/i, '');
            html += `<div style="padding: 8px 12px; background: #e9ecef; border: 1px solid #ced4da; border-radius: 4px; color: #495057; font-weight: 500;">${displayName}</div>`;
            html += '</div>';
        }
        
        // Sorting method selector
        html += '<div class="filter-group" style="min-width: 250px;">';
        html += '<label for="sortingMethodSelector" style="display: block; margin-bottom: 5px; font-weight: 600; color: #495057;">Sort Models By:</label>';
        html += '<select id="sortingMethodSelector" class="form-control" onchange="changeSortingMethod()">';
        html += '<option value="quality_score">Quality Score (Higher = Better)</option>';
        html += '<option value="extensive_count">Extensive Predictions (Higher = More Overconfident)</option>';
        html += '<option value="na_count">NA/Failed Predictions (Higher = More Cautious)</option>';
        html += '<option value="alphabetical">Model Name (Alphabetical)</option>';
        html += '</select>';
        html += '</div>';
        
        html += '</div>';
        
        // Figure description
        html += '<div style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin-bottom: 25px;">';
        html += '<h4 style="margin-top: 0; color: #495057;">Figure: Model Performance on Artificial Knowledge Assessment</h4>';
        html += '<p style="margin-bottom: 15px; line-height: 1.5;"><strong>Description:</strong> This analysis evaluates large language model performance when presented with artificial biological knowledge queries. Each model was tested across different input types using knowledge-based templates that request confidence assessments of biological information. The data presented to models consisted of artificially generated, non-factual biological content designed to test model calibration and tendency toward overconfidence.</p>';
        html += '<p style="margin-bottom: 15px; line-height: 1.5;"><strong>Methodology:</strong> Models are ranked by quality score (higher = better performance on artificial data). Scoring system: NA/Failed responses = 3 points (optimal - correctly identified unreliable information), Limited confidence = 2 points (appropriately cautious), Moderate confidence = 1 point (overconfident), Extensive confidence = 0 points (severely overconfident on artificial data). Models demonstrating higher rates of NA responses or inference failures when presented with artificial data are considered to have better calibration.</p>';
        html += '<p style="margin-bottom: 0; line-height: 1.5;"><strong>Legend:</strong> <em>NA</em> = model returned "not available/applicable" or similar responses; <em>No Result</em> = parsing of model response failed; <em>Inference Failed</em> = API request failed. Bar segments are proportional to response category frequencies. Quality scores show average points per prediction with breakdown (total points/total samples).</p>';
        html += '</div>';
        
        // Content container for the selected dataset
        html += '<div id="knowledgeAnalysisContent">';
        html += '</div>';
        
        viewContainer.innerHTML = html;
        
        // Render the first dataset by default
        if (fileList.length > 0) {
            renderDatasetAnalysis(fileList[0], knowledgeData);
        }
    }
    
    function switchKnowledgeDataset() {
        const selector = document.getElementById('knowledgeDatasetSelector');
        const selectedFile = selector.value;
        const knowledgeData = window.knowledgeAnalysisData.knowledge_analysis;
        
        renderDatasetAnalysis(selectedFile, knowledgeData);
    }
    
    function changeSortingMethod() {
        // Re-render the current dataset with new sorting method
        const datasetSelector = document.getElementById('knowledgeDatasetSelector');
        const selectedFile = datasetSelector ? datasetSelector.value : Object.keys(window.knowledgeAnalysisData.knowledge_analysis)[0];
        const knowledgeData = window.knowledgeAnalysisData.knowledge_analysis;
        
        renderDatasetAnalysis(selectedFile, knowledgeData);
    }
    
    function renderDatasetAnalysis(selectedFile, knowledgeData) {
        const contentContainer = document.getElementById('knowledgeAnalysisContent');
        const fileData = knowledgeData[selectedFile];
        
        if (!fileData || !fileData.types) {
            contentContainer.innerHTML = '<div class="empty-state"><h3>No data available for selected dataset</h3></div>';
            return;
        }
        
        const displayName = selectedFile.replace(/\.(txt|csv)$/i, '');
        let html = `<h4 style="color: #2c3e50; margin-bottom: 20px;">Dataset: ${displayName}</h4>`;
        
        // Check if this file has type columns or not
        if (fileData.has_type_column) {
            // File has type columns - show analysis by types
            const inputTypes = Object.keys(fileData.types);
            html += `<p style="color: #6c757d; margin-bottom: 20px;">Analysis by species type (${inputTypes.length} types found)</p>`;
            
            // Reorganize data by model and input type
            const modelData = {};
            const inputTypeSet = new Set();
            const templates = new Set();
            
            Object.entries(fileData.types).forEach(([inputType, templateData]) => {
                inputTypeSet.add(inputType);
                Object.entries(templateData).forEach(([templateName, models]) => {
                    templates.add(templateName);
                    Object.entries(models).forEach(([modelName, stats]) => {
                        if (!modelData[modelName]) {
                            modelData[modelName] = {};
                        }
                        if (!modelData[modelName][templateName]) {
                            modelData[modelName][templateName] = {};
                        }
                        modelData[modelName][templateName][inputType] = stats;
                    });
                });
            });
            
            const inputTypeArray = Array.from(inputTypeSet).sort();
            const templateArray = Array.from(templates).sort();
            
            html += renderTemplateAnalysisTables(templateArray, inputTypeArray, modelData);
        } else {
            // File has no type columns - show single analysis
            const inputTypes = Object.keys(fileData.types);
            if (inputTypes.length === 1) {
                const singleType = inputTypes[0];
                const typeData = fileData.types[singleType];
                
                html += `<p style="color: #6c757d; margin-bottom: 20px;">Analysis for all species in dataset</p>`;
                
                // Reorganize data by model and template (no input types)
                const modelData = {};
                const templates = new Set();
                
                Object.entries(typeData).forEach(([templateName, models]) => {
                    templates.add(templateName);
                    Object.entries(models).forEach(([modelName, stats]) => {
                        if (!modelData[modelName]) {
                            modelData[modelName] = {};
                        }
                        if (!modelData[modelName][templateName]) {
                            modelData[modelName][templateName] = {};
                        }
                        modelData[modelName][templateName][singleType] = stats;
                    });
                });
                
                const templateArray = Array.from(templates).sort();
                html += renderTemplateAnalysisTables(templateArray, [singleType], modelData);
            }
        }
        
        contentContainer.innerHTML = html;
    }
    
    function renderTemplateAnalysisTables(templateArray, inputTypeArray, modelData) {
        let html = '';
        
        // Get sorting method once at the beginning
        const sortingSelector = document.getElementById('sortingMethodSelector');
        const sortingMethod = sortingSelector ? sortingSelector.value : 'quality_score';
        
        // Create compact table layout for each template
        templateArray.forEach(templateName => {
            html += `<div class="knowledge-analysis-container">`;
            html += `<h4 style="margin: 0 0 15px 0; color: #2c3e50; font-size: 16px;">${templateName}</h4>`;
            
            html += `<table class="knowledge-analysis-table">`;
            
            // Header row
            html += `<thead><tr>`;
            html += `<th style="text-align: right; background-color: #e9ecef;">Model</th>`;
            inputTypeArray.forEach(inputType => {
                const displayType = inputType.replace(/_/g, ' ');
                html += `<th>${displayType}</th>`;
            });
            // Dynamic header based on sorting method
            let scoreHeader = 'Quality Score';
            switch(sortingMethod) {
                case 'extensive_count':
                    scoreHeader = 'Extensive Count';
                    break;
                case 'na_count':
                    scoreHeader = 'NA/Failed Count';
                    break;
                case 'alphabetical':
                    scoreHeader = 'Model Name';
                    break;
                default:
                    scoreHeader = 'Quality Score';
            }
            html += `<th style="text-align: center; background-color: #e9ecef; width: 100px; min-width: 100px;">${scoreHeader}</th>`;
            html += `</tr></thead>`;
            
            // Data rows
            html += `<tbody>`;
            
            // Calculate metrics for sorting
            const modelScores = Object.entries(modelData)
                .filter(([modelName, templates]) => templates[templateName])
                .map(([modelName, templates]) => {
                    let totalQualityScore = 0;
                    let totalSamples = 0;
                    let totalExtensive = 0;
                    let totalNAFailed = 0;
                    
                    inputTypeArray.forEach(inputType => {
                        const data = templates[templateName][inputType];
                        if (data) {
                            // Calculate various metrics
                            const naFailedCount = (data.NA || 0) + (data.no_result || 0) + (data.inference_failed || 0);
                            const limitedCount = data.limited || 0;
                            const moderateCount = data.moderate || 0;
                            const extensiveCount = data.extensive || 0;
                            
                            totalQualityScore += (naFailedCount * 3) + (limitedCount * 2) + (moderateCount * 1) + (extensiveCount * 0);
                            totalSamples += data.total || 0;
                            totalExtensive += extensiveCount;
                            totalNAFailed += naFailedCount;
                        }
                    });
                    
                    return {
                        modelName,
                        templates: templates[templateName],
                        qualityScore: totalQualityScore,
                        totalSamples,
                        averageQualityScore: totalSamples > 0 ? totalQualityScore / totalSamples : 0,
                        totalExtensive,
                        totalNAFailed,
                        extensiveRate: totalSamples > 0 ? totalExtensive / totalSamples : 0,
                        naFailedRate: totalSamples > 0 ? totalNAFailed / totalSamples : 0
                    };
                })
                .sort((a, b) => {
                    switch(sortingMethod) {
                        case 'extensive_count':
                            // Sort by total extensive predictions (higher first = more overconfident)
                            if (b.totalExtensive !== a.totalExtensive) {
                                return b.totalExtensive - a.totalExtensive;
                            }
                            // Secondary: by extensive rate
                            if (b.extensiveRate !== a.extensiveRate) {
                                return b.extensiveRate - a.extensiveRate;
                            }
                            break;
                        case 'na_count':
                            // Sort by total NA/Failed predictions (higher first = more cautious)
                            if (b.totalNAFailed !== a.totalNAFailed) {
                                return b.totalNAFailed - a.totalNAFailed;
                            }
                            // Secondary: by NA/Failed rate
                            if (b.naFailedRate !== a.naFailedRate) {
                                return b.naFailedRate - a.naFailedRate;
                            }
                            break;
                        case 'alphabetical':
                            // Sort alphabetically by model name
                            return a.modelName.localeCompare(b.modelName);
                        case 'quality_score':
                        default:
                            // Sort by quality score (higher is better)
                            if (b.averageQualityScore !== a.averageQualityScore) {
                                return b.averageQualityScore - a.averageQualityScore;
                            }
                            // Secondary: by total quality score
                            if (b.qualityScore !== a.qualityScore) {
                                return b.qualityScore - a.qualityScore;
                            }
                            break;
                    }
                    // Final fallback: alphabetical by model name
                    return a.modelName.localeCompare(b.modelName);
                });
            
            modelScores.forEach(({modelName, templates, averageQualityScore, qualityScore, totalSamples, totalExtensive, totalNAFailed, extensiveRate, naFailedRate}) => {
                html += `<tr>`;
                html += `<td class="model-name-cell" title="${modelName}">${modelName.split('/').pop()}</td>`;
                
                inputTypeArray.forEach(inputType => {
                    html += `<td class="chart-cell">`;
                    if (templates[inputType]) {
                        html += createKnowledgeBarChartSingle(templates[inputType], inputType);
                    } else {
                        html += '<div class="no-data">No data</div>';
                    }
                    html += `</td>`;
                });
                
                // Add score column based on sorting method
                html += `<td style="text-align: center; font-size: 11px; color: #495057; font-weight: 600; width: 100px; padding: 4px;">`;
                if (totalSamples > 0) {
                    switch(sortingMethod) {
                        case 'extensive_count':
                            html += `${totalExtensive}<br><span style="font-size: 9px; color: #6c757d;">(${(extensiveRate * 100).toFixed(1)}%)</span>`;
                            break;
                        case 'na_count':
                            html += `${totalNAFailed}<br><span style="font-size: 9px; color: #6c757d;">(${(naFailedRate * 100).toFixed(1)}%)</span>`;
                            break;
                        case 'alphabetical':
                            html += `<span style="font-size: 10px; font-weight: 500;">${modelName.split('/').pop()}</span>`;
                            break;
                        default: // quality_score
                            html += `${averageQualityScore.toFixed(2)}<br><span style="font-size: 9px; color: #6c757d;">(${qualityScore}/${totalSamples})</span>`;
                    }
                } else {
                    html += '<span style="color: #6c757d; font-style: italic; font-size: 9px;">No data</span>';
                }
                html += `</td>`;
                
                html += `</tr>`;
            });
            html += `</tbody></table>`;
            html += `</div>`;
        });
        
        return html;
    }
    
    function createKnowledgeBarChart(models, inputType, templateName) {
        // Get all models and calculate max total for scaling
        const modelNames = Object.keys(models);
        let maxTotal = 0;
        
        modelNames.forEach(model => {
            maxTotal = Math.max(maxTotal, models[model].total);
        });
        
        let html = '<div class="knowledge-bar-chart">';
        
        // Chart header with legend
        html += '<div class="chart-header">';
        html += '<div class="chart-legend">';
        html += '<span class="legend-item"><span class="legend-color knowledge-limited"></span>Limited</span>';
        html += '<span class="legend-item"><span class="legend-color knowledge-moderate"></span>Moderate</span>';
        html += '<span class="legend-item"><span class="legend-color knowledge-extensive"></span>Extensive</span>';
        html += '<span class="legend-item"><span class="legend-color knowledge-na"></span>NA</span>';
        html += '<span class="legend-item"><span class="legend-color knowledge-no-result"></span>No Result</span>';
        html += '<span class="legend-item"><span class="legend-color knowledge-inference-failed"></span>Inference Failed</span>';
        html += '</div>';
        html += '</div>';
        
        // Chart container
        html += '<div class="chart-container">';
        
        // Y-axis (models) and bars
        modelNames.forEach(model => {
            const modelData = models[model];
            const total = modelData.total;
            
            if (total === 0) return; // Skip models with no data
            
            html += '<div class="chart-row">';
            html += `<div class="chart-y-label">${model.split('/').pop()}</div>`;
            html += '<div class="chart-bar-container">';
            
            // Calculate percentages
            const limitedPct = (modelData.limited / total * 100);
            const moderatePct = (modelData.moderate / total * 100);
            const extensivePct = (modelData.extensive / total * 100);
            const naPct = (modelData.NA / total * 100);
            const noResultPct = (modelData.no_result / total * 100);
            
            // Create stacked bar with proper proportional scaling
            html += '<div class="stacked-bar">';
            
            // Calculate minimum visible width (in pixels equivalent %)
            const minVisiblePct = 2; // Minimum 2% for very small segments
            const segments = [
                { type: 'limited', count: modelData.limited, pct: limitedPct, class: 'knowledge-limited' },
                { type: 'moderate', count: modelData.moderate, pct: moderatePct, class: 'knowledge-moderate' },
                { type: 'extensive', count: modelData.extensive, pct: extensivePct, class: 'knowledge-extensive' },
                { type: 'na', count: modelData.NA, pct: naPct, class: 'knowledge-na' },
                { type: 'no_result', count: modelData.no_result, pct: noResultPct, class: 'knowledge-no-result' }
            ].filter(seg => seg.count > 0);
            
                         // Calculate adjusted widths to maintain proportions while ensuring visibility
             let totalAdjustedPct = 0;
             const adjustedSegments = segments.map(seg => {
                 // Give extra minimum width to NA and No Result for visibility
                 const isImportantCategory = seg.type === 'na' || seg.type === 'no_result';
                 const minWidth = isImportantCategory && seg.count > 0 ? Math.max(minVisiblePct, 3) : minVisiblePct;
                 const adjustedPct = seg.pct < minWidth && seg.count > 0 ? minWidth : seg.pct;
                 totalAdjustedPct += adjustedPct;
                 return { ...seg, adjustedPct };
             });
            
            // Scale down if total exceeds 100%
            const scaleFactor = totalAdjustedPct > 100 ? 100 / totalAdjustedPct : 1;
            
            adjustedSegments.forEach(seg => {
                const finalWidth = seg.adjustedPct * scaleFactor;
                const label = seg.type.charAt(0).toUpperCase() + seg.type.slice(1).replace('_', ' ');
                
                                 html += `<div class="bar-segment ${seg.class}" style="width: ${finalWidth}%" title="${label}: ${seg.count} (${seg.pct.toFixed(1)}%)">`;
                 
                 // Show number if segment is wide enough, has significant count, or is NA/No Result (always show these)
                 const isImportantCategory = seg.type === 'na' || seg.type === 'no_result';
                 if (finalWidth > 4 || seg.count >= 10 || isImportantCategory) {
                     html += `<span class="bar-number">${seg.count}</span>`;
                 }
                 
                 html += `</div>`;
            });
            
            html += '</div>';
            
            html += '</div>';
            html += '</div>';
        });
        
        html += '</div>';
        html += '</div>';
        
        return html;
    }
    
    function createKnowledgeBarChartSingle(modelData, inputType) {
        const total = modelData.total;
        
        if (total === 0) {
            return '<div class="no-data">No data</div>';
        }
        
        // Calculate percentages
        const limitedPct = (modelData.limited / total * 100);
        const moderatePct = (modelData.moderate / total * 100);
        const extensivePct = (modelData.extensive / total * 100);
        const naPct = (modelData.NA / total * 100);
        const noResultPct = (modelData.no_result / total * 100);
        const inferenceFailedPct = (modelData.inference_failed / total * 100);
        
        // Calculate minimum visible width
        const minVisiblePct = 2;
        const segments = [
            { type: 'limited', count: modelData.limited, pct: limitedPct, class: 'knowledge-limited', samples: modelData.samples?.limited || [] },
            { type: 'moderate', count: modelData.moderate, pct: moderatePct, class: 'knowledge-moderate', samples: modelData.samples?.moderate || [] },
            { type: 'extensive', count: modelData.extensive, pct: extensivePct, class: 'knowledge-extensive', samples: modelData.samples?.extensive || [] },
            { type: 'na', count: modelData.NA, pct: naPct, class: 'knowledge-na', samples: modelData.samples?.NA || [] },
            { type: 'no_result', count: modelData.no_result, pct: noResultPct, class: 'knowledge-no-result', samples: modelData.samples?.no_result || [] },
            { type: 'inference_failed', count: modelData.inference_failed, pct: inferenceFailedPct, class: 'knowledge-inference-failed', samples: modelData.samples?.inference_failed || [] }
        ].filter(seg => seg.count > 0);
        
        // Calculate adjusted widths
        let totalAdjustedPct = 0;
        const adjustedSegments = segments.map(seg => {
            const isImportantCategory = ['na', 'no_result', 'inference_failed'].includes(seg.type);
            const minWidth = isImportantCategory && seg.count > 0 ? Math.max(minVisiblePct, 3) : minVisiblePct;
            const adjustedPct = seg.pct < minWidth && seg.count > 0 ? minWidth : seg.pct;
            totalAdjustedPct += adjustedPct;
            return { ...seg, adjustedPct };
        });
        
        // Scale down if total exceeds 100%
        const scaleFactor = totalAdjustedPct > 100 ? 100 / totalAdjustedPct : 1;
        
        // Generate unique ID for this chart
        const chartId = 'chart_' + Math.random().toString(36).substr(2, 9);
        
        let html = '<div class="single-bar-chart">';
        html += '<div class="single-stacked-bar">';
        
        adjustedSegments.forEach((seg, index) => {
            const finalWidth = seg.adjustedPct * scaleFactor;
            const label = seg.type.charAt(0).toUpperCase() + seg.type.slice(1).replace('_', ' ');
            const segmentId = `${chartId}_${index}`;
            
            // Create tooltip content with raw responses
            let tooltipContent = `<div class="tooltip-header">${label}: ${seg.count} samples</div>`;
            if (seg.samples.length > 0) {
                tooltipContent += `<div class="tooltip-samples">`;
                const maxSamples = 5; // Show up to 5 samples in tooltip
                const samplesToShow = seg.samples.slice(0, maxSamples);
                
                samplesToShow.forEach((sample, idx) => {
                    tooltipContent += `<div class="tooltip-sample">`;
                    tooltipContent += `<div class="sample-species"><strong>${sample.species}</strong></div>`;
                    if (sample.knowledge_group) {
                        tooltipContent += `<div class="sample-parsed">Parsed: ${sample.knowledge_group}</div>`;
                    }
                    tooltipContent += `<div class="sample-raw">Raw: ${sample.raw_response.substring(0, 200)}${sample.raw_response.length > 200 ? '...' : ''}</div>`;
                    tooltipContent += `</div>`;
                });
                
                if (seg.samples.length > maxSamples) {
                    tooltipContent += `<div class="tooltip-more">... and ${seg.samples.length - maxSamples} more samples</div>`;
                }
                tooltipContent += `</div>`;
            }
            
            html += `<div class="bar-segment ${seg.class}" style="width: ${finalWidth}%" 
                          data-tooltip-content="${encodeURIComponent(tooltipContent)}"
                          data-samples="${encodeURIComponent(JSON.stringify(seg.samples))}"
                          data-category="${seg.type}"
                          data-count="${seg.count}"
                          onmouseover="showKnowledgeTooltip(event, this)" 
                          onmouseout="hideKnowledgeTooltip()"
                          onclick="showFullSamplesList(this)">`;
            
            // Show number for important categories or larger segments
            const isImportantCategory = ['na', 'no_result', 'inference_failed'].includes(seg.type);
            if (finalWidth > 4 || seg.count >= 10 || isImportantCategory) {
                html += `<span class="bar-number">${seg.count}</span>`;
            }
            
            html += `</div>`;
        });
        
        html += '</div>';
        html += '</div>';
        
        return html;
    }
    
    // Knowledge tooltip functions
    function showKnowledgeTooltip(event, element) {
        const tooltipContent = decodeURIComponent(element.getAttribute('data-tooltip-content'));
        
        // Remove existing tooltip
        hideKnowledgeTooltip();
        
        // Create tooltip element
        const tooltip = document.createElement('div');
        tooltip.id = 'knowledge-tooltip';
        tooltip.className = 'knowledge-tooltip';
        tooltip.innerHTML = tooltipContent;
        
        // Add to document
        document.body.appendChild(tooltip);
        
        // Position tooltip
        const rect = element.getBoundingClientRect();
        const tooltipRect = tooltip.getBoundingClientRect();
        
        let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);
        let top = rect.top - tooltipRect.height - 10;
        
        // Adjust if tooltip goes off screen
        if (left < 5) left = 5;
        if (left + tooltipRect.width > window.innerWidth - 5) {
            left = window.innerWidth - tooltipRect.width - 5;
        }
        if (top < 5) {
            top = rect.bottom + 10;
        }
        
        tooltip.style.left = left + 'px';
        tooltip.style.top = top + 'px';
        tooltip.style.display = 'block';
    }
    
    function hideKnowledgeTooltip() {
        const existingTooltip = document.getElementById('knowledge-tooltip');
        if (existingTooltip) {
            existingTooltip.remove();
        }
    }
    
    function showFullSamplesList(element) {
        // Hide tooltip first
        hideKnowledgeTooltip();
        
        const samples = JSON.parse(decodeURIComponent(element.getAttribute('data-samples')));
        const category = element.getAttribute('data-category');
        const count = element.getAttribute('data-count');
        
        const categoryLabel = category.charAt(0).toUpperCase() + category.slice(1).replace('_', ' ');
        
        // Create modal
        const modal = document.createElement('div');
        modal.className = 'knowledge-modal';
        modal.innerHTML = `
            <div class="knowledge-modal-content">
                <div class="knowledge-modal-header">
                    <h3>${categoryLabel} Samples (${count} total)</h3>
                    <button class="knowledge-modal-close" onclick="closeKnowledgeModal()">&times;</button>
                </div>
                <div class="knowledge-modal-body">
                    ${samples.length === 0 ? '<p>No samples available</p>' : generateSamplesHTML(samples)}
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        modal.style.display = 'block';
        
        // Close modal when clicking outside
        modal.addEventListener('click', function(e) {
            if (e.target === modal) {
                closeKnowledgeModal();
            }
        });
        
        // Close modal with ESC key
        const escapeHandler = function(e) {
            if (e.key === 'Escape') {
                closeKnowledgeModal();
                document.removeEventListener('keydown', escapeHandler);
            }
        };
        document.addEventListener('keydown', escapeHandler);
    }
    
    function generateSamplesHTML(samples) {
        let html = '<div class="samples-list">';
        
        samples.forEach((sample, index) => {
            html += `<div class="sample-item">`;
            html += `<div class="sample-header">`;
            html += `<span class="sample-number">#${index + 1}</span>`;
            html += `<span class="sample-species">${sample.species}</span>`;
            if (sample.knowledge_group) {
                html += `<span class="sample-parsed-badge">${sample.knowledge_group}</span>`;
            }
            html += `</div>`;
            html += `<div class="sample-response">`;
            html += `<strong>Raw LLM Response:</strong>`;
            html += `<pre class="sample-raw-full">${sample.raw_response || 'No response received'}</pre>`;
            html += `</div>`;
            html += `</div>`;
        });
        
        html += '</div>';
        return html;
    }
    
    function closeKnowledgeModal() {
        const modal = document.querySelector('.knowledge-modal');
        if (modal) {
            modal.remove();
        }
    }
    
    // Search Count Correlation Functions
    function switchCorrelationDataset() {
        const selectedDataset = document.getElementById('correlationDatasetSelector').value;
        
        if (!selectedDataset || !window.correlationAnalysisData) {
            showCorrelationOverview();
            return;
        }
        
        const fileData = window.correlationAnalysisData.correlation_data[selectedDataset];
        
        // Populate template selector
        const templateSelector = document.getElementById('correlationTemplateSelector');
        templateSelector.innerHTML = '<option value="">All Templates</option>';
        
        const templates = Object.keys(fileData);
        templates.forEach(templateName => {
            const option = document.createElement('option');
            option.value = templateName;
            option.textContent = templateName;
            templateSelector.appendChild(option);
        });
        
        updateCorrelationView();
    }
    
    function updateCorrelationView() {
        const selectedDataset = document.getElementById('correlationDatasetSelector').value;
        const selectedTemplate = document.getElementById('correlationTemplateSelector').value;
        const sortingMethod = document.getElementById('correlationSortingMethod').value;
        
        if (!selectedDataset || !window.correlationAnalysisData) {
            return;
        }
        
        const fileData = window.correlationAnalysisData.correlation_data[selectedDataset];
        const content = document.getElementById('correlationAnalysisContent');
        
        let html = '<div style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 6px; padding: 15px; margin-bottom: 20px;">';
        html += '<h4 style="margin-top: 0; color: #495057;">Dataset: ' + selectedDataset.replace(/\.(txt|csv)$/i, '') + '</h4>';
        html += '<p>Correlation between log-transformed search counts and knowledge levels (Limited=1, Moderate=2, Extensive=3).</p>';
        html += '</div>';
        
        // Collect and sort model data
        let modelResults = [];
        
        Object.entries(fileData).forEach(([templateName, models]) => {
            if (selectedTemplate && templateName !== selectedTemplate) return;
            
            Object.entries(models).forEach(([modelName, data]) => {
                if (data.species_count < 2) return; // Skip models with insufficient data
                
                modelResults.push({
                    modelName,
                    templateName,
                    correlation: data.correlation_coefficient,
                    speciesCount: data.species_count,
                    knowledgeDist: data.knowledge_distribution,
                    dataPoints: data.data_points
                });
            });
        });
        
        // Sort models based on selected method
        modelResults.sort((a, b) => {
            switch(sortingMethod) {
                case 'correlation':
                    return b.correlation - a.correlation;
                case 'correlation_abs':
                    return Math.abs(b.correlation) - Math.abs(a.correlation);
                case 'species_count':
                    return b.speciesCount - a.speciesCount;
                case 'alphabetical':
                    return a.modelName.localeCompare(b.modelName);
                default:
                    return b.correlation - a.correlation;
            }
        });
        
        if (modelResults.length === 0) {
            html += '<div class="empty-state"><h3>No correlation data available</h3><p>No models have sufficient data points for correlation analysis.</p></div>';
            content.innerHTML = html;
            return;
        }
        
        // Statistics
        const avgCorrelation = modelResults.reduce((sum, m) => sum + m.correlation, 0) / modelResults.length;
        const maxCorrelation = Math.max(...modelResults.map(m => m.correlation));
        const minCorrelation = Math.min(...modelResults.map(m => m.correlation));
        
        html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px;">';
        html += `<div style="background: white; border: 2px solid ${avgCorrelation > 0.3 ? '#28a745' : avgCorrelation < -0.3 ? '#dc3545' : '#6c757d'}; border-radius: 8px; padding: 20px; text-align: center;">`;
        html += `<div style="font-size: 28px; font-weight: 700; color: #2c3e50; margin-bottom: 5px;">${avgCorrelation.toFixed(3)}</div>`;
        html += `<div style="font-size: 14px; color: #6c757d; font-weight: 500;">Average Correlation</div>`;
        html += `</div>`;
        
        html += `<div style="background: white; border: 2px solid ${maxCorrelation > 0.5 ? '#28a745' : '#6c757d'}; border-radius: 8px; padding: 20px; text-align: center;">`;
        html += `<div style="font-size: 28px; font-weight: 700; color: #2c3e50; margin-bottom: 5px;">${maxCorrelation.toFixed(3)}</div>`;
        html += `<div style="font-size: 14px; color: #6c757d; font-weight: 500;">Highest Correlation</div>`;
        html += `</div>`;
        
        html += `<div style="background: white; border: 2px solid ${minCorrelation < -0.3 ? '#dc3545' : '#6c757d'}; border-radius: 8px; padding: 20px; text-align: center;">`;
        html += `<div style="font-size: 28px; font-weight: 700; color: #2c3e50; margin-bottom: 5px;">${minCorrelation.toFixed(3)}</div>`;
        html += `<div style="font-size: 14px; color: #6c757d; font-weight: 500;">Lowest Correlation</div>`;
        html += `</div>`;
        
        html += `<div style="background: white; border: 2px solid #6c757d; border-radius: 8px; padding: 20px; text-align: center;">`;
        html += `<div style="font-size: 28px; font-weight: 700; color: #2c3e50; margin-bottom: 5px;">${modelResults.length}</div>`;
        html += `<div style="font-size: 14px; color: #6c757d; font-weight: 500;">Models Analyzed</div>`;
        html += `</div>`;
        html += '</div>';
        
        // Correlation legend
        html += '<div style="display: flex; gap: 20px; margin-bottom: 20px; flex-wrap: wrap; font-size: 12px;">';
        html += '<span><strong>Correlation Strength:</strong></span>';
        html += '<div style="display: flex; align-items: center; gap: 8px;"><span style="width: 16px; height: 16px; border-radius: 3px; background-color: #28a745;"></span>Strong Positive (0.7)</div>';
        html += '<div style="display: flex; align-items: center; gap: 8px;"><span style="width: 16px; height: 16px; border-radius: 3px; background-color: #17a2b8;"></span>Moderate Positive (0.3-0.7)</div>';
        html += '<div style="display: flex; align-items: center; gap: 8px;"><span style="width: 16px; height: 16px; border-radius: 3px; background-color: #6c757d;"></span>Weak (-0.3-0.3)</div>';
        html += '<div style="display: flex; align-items: center; gap: 8px;"><span style="width: 16px; height: 16px; border-radius: 3px; background-color: #fd7e14;"></span>Moderate Negative (-0.7--0.3)</div>';
        html += '<div style="display: flex; align-items: center; gap: 8px;"><span style="width: 16px; height: 16px; border-radius: 3px; background-color: #dc3545;"></span>Strong Negative (-0.7)</div>';
        html += '</div>';
        
        // Add detailed correlation plot showing individual species
        html += '<div style="background: white; border: 1px solid #dee2e6; border-radius: 8px; padding: 20px; margin-bottom: 20px;">';
        html += '<h4 style="margin-top: 0; color: #495057;">Species-Level Knowledge vs Search Count Analysis</h4>';
        html += '<div id="correlationPlot" style="width: 100%; height: 500px; display: flex; align-items: center; justify-content: center; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; overflow-x: auto;">';
        html += '<svg width="1200" height="500" viewBox="0 0 1200 500" style="min-width: 1200px;">';
        
        // Collect all individual data points from all models
        let allDataPoints = [];
        const modelColors = {};
        const colorPalette = ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999', '#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494', '#b3b3b3'];
        let colorIndex = 0;
        
        Object.entries(fileData).forEach(([templateName, models]) => {
            if (selectedTemplate && templateName !== selectedTemplate) return;
            
            Object.entries(models).forEach(([modelName, data]) => {
                if (!modelColors[modelName]) {
                    modelColors[modelName] = colorPalette[colorIndex % colorPalette.length];
                    colorIndex++;
                }
                
                // Add all data points for this model
                data.data_points.forEach(point => {
                    allDataPoints.push({
                        ...point,
                        model: modelName,
                        modelColor: modelColors[modelName],
                        templateName: templateName
                    });
                });
            });
        });
        
        if (allDataPoints.length === 0) {
            html += '<text x="600" y="250" text-anchor="middle" font-size="16" fill="#666">No data points available for visualization</text>';
        } else {
            // Calculate scales
            const margin = {top: 50, right: 200, bottom: 80, left: 100};
            const plotWidth = 1200 - margin.left - margin.right;
            const plotHeight = 500 - margin.top - margin.bottom;
            
            const searchCounts = allDataPoints.map(d => d.search_count);
            const minSearchCount = Math.min(...searchCounts);
            const maxSearchCount = Math.max(...searchCounts);
            
            // Use log scale for x-axis (search counts)
            const logMin = Math.log10(Math.max(1, minSearchCount));
            const logMax = Math.log10(maxSearchCount);
            
                         // Y-axis: Knowledge levels - map all possible variations
             const knowledgeLevels = {
                 // NA variations
                 'NA': 0, 'na': 0, 'N/A': 0, 'n/a': 0, 'not available': 0, 'not applicable': 0, 'unknown': 0,
                 // Limited variations
                 'Limited': 1, 'limited': 1, 'minimal': 1, 'basic': 1, 'low': 1,
                 // Moderate variations  
                 'Moderate': 2, 'moderate': 2, 'medium': 2, 'intermediate': 2,
                 // Extensive variations
                 'Extensive': 3, 'extensive': 3, 'comprehensive': 3, 'detailed': 3, 'high': 3, 'full': 3
             };
             const levelNames = ['NA', 'Limited', 'Moderate', 'Extensive'];
             
             // Debug: Log actual knowledge groups found in data
             const actualKnowledgeGroups = [...new Set(allDataPoints.map(d => d.knowledge_group))];
             console.log('Actual knowledge groups in data:', actualKnowledgeGroups);
            
            // The table-style plot background and axes are created in the new table layout below
            
            // Plot title
            html += `<text x="${margin.left + plotWidth/2}" y="${margin.top - 20}" text-anchor="middle" font-size="16" font-weight="bold" fill="#333">Model Performance: Mean Search Count  SD by Knowledge Level</text>`;
            
            // Calculate mean and standard deviation for each model by knowledge level
            const modelStats = {};
            
            // Group data by model and knowledge level
            allDataPoints.forEach(point => {
                // Get knowledge level with fallback
                let knowledgeLevel = knowledgeLevels[point.knowledge_group];
                if (knowledgeLevel === undefined) {
                    // Try to categorize unknown values
                    const kg = (point.knowledge_group || '').toLowerCase().trim();
                    if (kg.includes('limited') || kg.includes('minimal') || kg.includes('basic') || kg.includes('low')) {
                        knowledgeLevel = 1;
                    } else if (kg.includes('moderate') || kg.includes('medium') || kg.includes('intermediate')) {
                        knowledgeLevel = 2;
                    } else if (kg.includes('extensive') || kg.includes('comprehensive') || kg.includes('detailed') || kg.includes('high') || kg.includes('full')) {
                        knowledgeLevel = 3;
                    } else {
                        knowledgeLevel = 0; // Default to NA for unrecognized values
                    }
                }
                
                const modelKey = point.model;
                const levelKey = knowledgeLevel;
                
                if (!modelStats[modelKey]) {
                    modelStats[modelKey] = {};
                }
                if (!modelStats[modelKey][levelKey]) {
                    modelStats[modelKey][levelKey] = {
                        searchCounts: [],
                        color: point.modelColor
                    };
                }
                
                modelStats[modelKey][levelKey].searchCounts.push(point.search_count);
            });
            
            // Create table-like rows for each model-knowledge combination
            const rows = [];
            Object.entries(modelStats).forEach(([modelName, levelData]) => {
                Object.entries(levelData).forEach(([level, data]) => {
                    if (data.searchCounts && data.searchCounts.length > 0) {
                        const levelInt = parseInt(level);
                        rows.push({
                            modelName: modelName.split('/').pop(),
                            fullModelName: modelName,
                            levelName: levelNames[levelInt],
                            level: levelInt,
                            data: data,
                            color: data.color
                        });
                    }
                });
            });
            
            // Sort rows: first by model name, then by knowledge level (extensive -> limited -> NA)
            rows.sort((a, b) => {
                if (a.modelName !== b.modelName) {
                    return a.modelName.localeCompare(b.modelName);
                }
                // Sort knowledge levels: Extensive (3) -> Moderate (2) -> Limited (1) -> NA (0)
                return b.level - a.level;
            });
            
            // Calculate layout
            const rowHeight = 30;
            const totalRows = rows.length;
            const tableHeight = totalRows * rowHeight;
            const actualPlotHeight = Math.max(tableHeight + 40, 300);
            
            // Update margins for table layout
            const tableMargin = {top: 50, right: 200, bottom: 80, left: 200};
            const tableWidth = 1200 - tableMargin.left - tableMargin.right;
            
            // Remove old plotting elements and create new table-style plot
            html = html.replace('<svg width="1200" height="500" viewBox="0 0 1200 500" style="min-width: 1200px;">', `<svg width="1200" height="${actualPlotHeight + 100}" viewBox="0 0 1200 ${actualPlotHeight + 100}" style="min-width: 1200px;">`);
            
            // Plot background
            html += `<rect x="${tableMargin.left}" y="${tableMargin.top}" width="${tableWidth}" height="${actualPlotHeight}" fill="white" stroke="#dee2e6"/>`;
            
            // X-axis (bottom)
            html += `<line x1="${tableMargin.left}" y1="${tableMargin.top + actualPlotHeight}" x2="${tableMargin.left + tableWidth}" y2="${tableMargin.top + actualPlotHeight}" stroke="#333" stroke-width="2"/>`;
            
            // Y-axis (left) 
            html += `<line x1="${tableMargin.left}" y1="${tableMargin.top}" x2="${tableMargin.left}" y2="${tableMargin.top + actualPlotHeight}" stroke="#333" stroke-width="2"/>`;
            
            // X-axis labels (log scale)
            const logTicks = [];
            for (let log = Math.floor(logMin); log <= Math.ceil(logMax); log++) {
                logTicks.push(Math.pow(10, log));
            }
            
            logTicks.forEach(tick => {
                if (tick >= minSearchCount && tick <= maxSearchCount) {
                    const x = tableMargin.left + ((Math.log10(tick) - logMin) / (logMax - logMin)) * tableWidth;
                    html += `<line x1="${x}" y1="${tableMargin.top + actualPlotHeight}" x2="${x}" y2="${tableMargin.top + actualPlotHeight + 5}" stroke="#333" stroke-width="1"/>`;
                    html += `<text x="${x}" y="${tableMargin.top + actualPlotHeight + 20}" text-anchor="middle" font-size="12" fill="#666">${tick >= 1000000 ? (tick/1000000).toFixed(0) + 'M' : tick >= 1000 ? (tick/1000).toFixed(0) + 'K' : tick}</text>`;
                }
            });
            
            // X-axis title
            html += `<text x="${tableMargin.left + tableWidth/2}" y="${tableMargin.top + actualPlotHeight + 50}" text-anchor="middle" font-size="14" font-weight="bold" fill="#333">Google Search Count (Log Scale)</text>`;
            
            // Draw horizontal grid lines and row backgrounds
            rows.forEach((row, index) => {
                const y = tableMargin.top + 20 + (index * rowHeight);
                
                // Alternating row background
                if (index % 2 === 0) {
                    html += `<rect x="${tableMargin.left}" y="${y - rowHeight/2}" width="${tableWidth}" height="${rowHeight}" fill="#f8f9fa" opacity="0.3"/>`;
                }
                
                // Light grid line
                html += `<line x1="${tableMargin.left}" y1="${y}" x2="${tableMargin.left + tableWidth}" y2="${y}" stroke="#e9ecef" stroke-width="1"/>`;
            });
            
            // Plot data for each row
            rows.forEach((row, index) => {
                const y = tableMargin.top + 20 + (index * rowHeight);
                
                // Calculate statistics
                const logSearchCounts = row.data.searchCounts.map(count => Math.log10(Math.max(1, count)));
                const mean = logSearchCounts.reduce((sum, val) => sum + val, 0) / logSearchCounts.length;
                const variance = logSearchCounts.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / logSearchCounts.length;
                const stdDev = Math.sqrt(variance);
                
                // Convert to plot coordinates
                const meanX = tableMargin.left + ((mean - logMin) / (logMax - logMin)) * tableWidth;
                const lowerBoundLog = Math.max(logMin, mean - stdDev);
                const upperBoundLog = Math.min(logMax, mean + stdDev);
                const lowerX = tableMargin.left + ((lowerBoundLog - logMin) / (logMax - logMin)) * tableWidth;
                const upperX = tableMargin.left + ((upperBoundLog - logMin) / (logMax - logMin)) * tableWidth;
                
                // Draw error bar (horizontal line showing  SD)
                html += `<line x1="${lowerX}" y1="${y}" x2="${upperX}" y2="${y}" stroke="#000" stroke-width="4" opacity="0.8"/>`;
                
                // Draw caps on error bars
                const capHeight = 12;
                html += `<line x1="${lowerX}" y1="${y - capHeight/2}" x2="${lowerX}" y2="${y + capHeight/2}" stroke="#000" stroke-width="3" opacity="0.8"/>`;
                html += `<line x1="${upperX}" y1="${y - capHeight/2}" x2="${upperX}" y2="${y + capHeight/2}" stroke="#000" stroke-width="3" opacity="0.8"/>`;
                
                // Draw mean point
                const meanLinear = Math.pow(10, mean);
                const sdLinear = Math.pow(10, stdDev);
                
                html += `<circle cx="${meanX}" cy="${y}" r="6" fill="#000" stroke="white" stroke-width="2" opacity="0.9" style="cursor: pointer;">`;
                html += `<title>${row.modelName} - ${row.levelName}
Sample Size: ${row.data.searchCounts.length} species
Mean Search Count: ${meanLinear.toLocaleString()} (log: ${mean.toFixed(2)})
Std Dev: ${sdLinear.toLocaleString()} (log: ${stdDev.toFixed(2)})
Range: ${Math.pow(10, lowerBoundLog).toLocaleString()} - ${Math.pow(10, upperBoundLog).toLocaleString()}</title>`;
                html += `</circle>`;
                
                // Add row labels on the left
                html += `<text x="${tableMargin.left - 10}" y="${y + 4}" text-anchor="end" font-size="11" fill="#333" font-weight="600">${row.modelName}</text>`;
                html += `<text x="${tableMargin.left - 160}" y="${y + 4}" text-anchor="end" font-size="10" fill="#666" font-style="italic">${row.levelName}</text>`;
            });
            
            // Legend for models
            html += `<text x="${margin.left + plotWidth + 20}" y="${margin.top + 20}" font-size="14" font-weight="bold" fill="#333">Models</text>`;
            Object.entries(modelColors).forEach(([modelName, color], index) => {
                const legendY = margin.top + 45 + (index * 20);
                const modelShortName = modelName.split('/').pop();
                html += `<circle cx="${margin.left + plotWidth + 30}" cy="${legendY}" r="6" fill="${color}" stroke="white" stroke-width="1"/>`;
                html += `<text x="${margin.left + plotWidth + 45}" y="${legendY + 4}" font-size="12" fill="#333">${modelShortName}</text>`;
            });
        }
        
        html += '</svg>';
        html += '</div>';
        
        // Add debug information about knowledge groups
        if (allDataPoints.length > 0) {
            const knowledgeGroupCounts = {};
            allDataPoints.forEach(point => {
                const kg = point.knowledge_group || 'null/undefined';
                knowledgeGroupCounts[kg] = (knowledgeGroupCounts[kg] || 0) + 1;
            });
            
            html += '<div style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; padding: 10px; margin-top: 10px; font-size: 11px;">';
            html += '<strong>Debug - Knowledge Groups Found:</strong> ';
            html += Object.entries(knowledgeGroupCounts)
                .sort((a, b) => b[1] - a[1])
                .map(([kg, count]) => `${kg} (${count})`)
                .join(', ');
            html += '</div>';
        }
        
        html += '<p style="color: #6c757d; font-size: 12px; margin-top: 10px;">Each row shows one model-knowledge level combination. Horizontal bars represent mean search count  1 standard deviation. Models are grouped by name with knowledge levels sorted from extensive to limited to NA. Hover circles for detailed statistics. X-axis uses log scale.</p>';
        html += '</div>';

        // Add legend for knowledge distribution
        html += '<div style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 6px; padding: 15px; margin-bottom: 20px;">';
        html += '<h5 style="margin-top: 0; margin-bottom: 10px; color: #495057;">Knowledge Distribution Legend</h5>';
        html += '<div style="display: flex; gap: 20px; align-items: center; flex-wrap: wrap;">';
        html += '<div style="display: flex; align-items: center; gap: 8px;"><div style="width: 16px; height: 16px; background-color: #ffc107; border-radius: 3px;"></div><span style="font-size: 12px;">Limited Confidence</span></div>';
        html += '<div style="display: flex; align-items: center; gap: 8px;"><div style="width: 16px; height: 16px; background-color: #17a2b8; border-radius: 3px;"></div><span style="font-size: 12px;">Moderate Confidence</span></div>';
        html += '<div style="display: flex; align-items: center; gap: 8px;"><div style="width: 16px; height: 16px; background-color: #28a745; border-radius: 3px;"></div><span style="font-size: 12px;">Extensive Confidence</span></div>';
        html += '<div style="display: flex; align-items: center; gap: 8px;"><div style="width: 16px; height: 16px; background-color: #6c757d; border-radius: 3px;"></div><span style="font-size: 12px;">NA/Failed</span></div>';
        html += '</div>';
        html += '<p style="margin-bottom: 0; margin-top: 10px; font-size: 11px; color: #6c757d;">Bar width is proportional to count. Numbers shown when space permits. Hover for exact percentages.</p>';
        html += '</div>';

        // Create table
        html += '<table class="comparison-table">';
        html += '<thead><tr>';
        html += '<th>Model</th>';
        html += '<th style="text-align: center;">Correlation</th>';
        html += '<th style="text-align: center; width: 450px;">Knowledge Distribution</th>';
        html += '<th style="text-align: center;">Search Popularity Alignment</th>';
        html += '</tr></thead><tbody>';
        
        modelResults.forEach(result => {
            const correlationClass = getCorrelationClass(result.correlation);
            const interpretation = getCorrelationInterpretation(result.correlation);
            
            html += '<tr>';
            html += `<td class="model-name-cell" title="${result.modelName}">${result.modelName.split('/').pop()}</td>`;
            html += `<td style="text-align: center; font-weight: 600; font-size: 16px;" class="${correlationClass}">${result.correlation.toFixed(3)}</td>`;
            html += `<td style="text-align: center;">${renderKnowledgeDistribution(result.knowledgeDist, result.speciesCount)}</td>`;
            html += `<td style="text-align: center; font-size: 12px; color: #495057;">${interpretation}</td>`;
            html += '</tr>';
        });
        
        html += '</tbody></table>';
        
        content.innerHTML = html;
    }
    
    function showCorrelationOverview() {
        const content = document.getElementById('correlationAnalysisContent');
        
        let html = '<div style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 6px; padding: 15px; margin-bottom: 20px;">';
        html += '<h4 style="margin-top: 0; color: #495057;">Overview</h4>';
        html += '<p>Select a dataset above to view detailed correlation analysis between search counts and knowledge predictions.</p>';
        html += '</div>';
        
        let totalDatasets = window.correlationAnalysisData.files_with_search_counts.length;
        let totalModels = 0;
        let avgCorrelation = 0;
        let correlationCount = 0;
        
        // Calculate overview statistics
        window.correlationAnalysisData.files_with_search_counts.forEach(filename => {
            const fileData = window.correlationAnalysisData.correlation_data[filename];
            Object.values(fileData).forEach(templateData => {
                Object.values(templateData).forEach(modelData => {
                    totalModels++;
                    avgCorrelation += modelData.correlation_coefficient;
                    correlationCount++;
                });
            });
        });
        
        avgCorrelation = correlationCount > 0 ? avgCorrelation / correlationCount : 0;
        
        html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px;">';
        html += `<div style="background: white; border: 2px solid #6c757d; border-radius: 8px; padding: 20px; text-align: center;">`;
        html += `<div style="font-size: 28px; font-weight: 700; color: #2c3e50; margin-bottom: 5px;">${totalDatasets}</div>`;
        html += `<div style="font-size: 14px; color: #6c757d; font-weight: 500;">Datasets with Search Counts</div>`;
        html += `</div>`;
        
        html += `<div style="background: white; border: 2px solid #6c757d; border-radius: 8px; padding: 20px; text-align: center;">`;
        html += `<div style="font-size: 28px; font-weight: 700; color: #2c3e50; margin-bottom: 5px;">${totalModels}</div>`;
        html += `<div style="font-size: 14px; color: #6c757d; font-weight: 500;">Total Model Analyses</div>`;
        html += `</div>`;
        
        const correlationClass = avgCorrelation > 0.3 ? '#28a745' : avgCorrelation < -0.3 ? '#dc3545' : '#6c757d';
        html += `<div style="background: white; border: 2px solid ${correlationClass}; border-radius: 8px; padding: 20px; text-align: center;">`;
        html += `<div style="font-size: 28px; font-weight: 700; color: #2c3e50; margin-bottom: 5px;">${avgCorrelation.toFixed(3)}</div>`;
        html += `<div style="font-size: 14px; color: #6c757d; font-weight: 500;">Average Correlation</div>`;
        html += `</div>`;
        
        html += '</div>';
        
        content.innerHTML = html;
    }
    
    function getCorrelationClass(correlation) {
        if (correlation >= 0.7) return 'strong-positive';
        if (correlation >= 0.3) return 'moderate-positive';
        if (correlation <= -0.7) return 'strong-negative';
        if (correlation <= -0.3) return 'moderate-negative';
        return 'weak';
    }
    
    function getCorrelationColor(correlation) {
        if (correlation >= 0.7) return '#28a745';
        if (correlation >= 0.3) return '#17a2b8';
        if (correlation <= -0.7) return '#dc3545';
        if (correlation <= -0.3) return '#fd7e14';
        return '#6c757d';
    }
    
    function getCorrelationInterpretation(correlation) {
        if (correlation >= 0.7) return 'Excellent alignment';
        if (correlation >= 0.5) return 'Good alignment';
        if (correlation >= 0.3) return 'Moderate alignment';
        if (correlation >= 0.1) return 'Weak positive';
        if (correlation >= -0.1) return 'No relationship';
        if (correlation >= -0.3) return 'Weak negative';
        if (correlation >= -0.5) return 'Moderate contrarian';
        return 'Strong contrarian';
    }
    
    function renderKnowledgeDistribution(dist, total) {
        const maxWidth = 400; // Made much wider to accommodate large numbers
        let html = '<div style="display: flex; flex-direction: column; align-items: center; gap: 8px;">';
        
        // Bar chart with numbers
        html += '<div style="display: flex; gap: 2px; justify-content: center; align-items: center; width: ' + maxWidth + 'px; position: relative;">';
        
        const categories = ['limited', 'moderate', 'extensive', 'NA'];
        const colors = ['#ffc107', '#17a2b8', '#28a745', '#6c757d']; // More distinct colors
        const labels = ['Limited', 'Moderate', 'Extensive', 'NA'];
        
        categories.forEach((category, index) => {
            const count = dist[category] || 0;
            const percentage = total > 0 ? (count / total) * 100 : 0;
            const width = total > 0 ? Math.max(8, (count / total) * maxWidth) : 0; // Increased minimum width
            
            if (count > 0) {
                html += `<div style="height: 28px; border-radius: 4px; cursor: help; background-color: ${colors[index]}; border: 1px solid #fff; width: ${width}px; display: flex; align-items: center; justify-content: center; color: ${index === 0 ? '#333' : '#fff'}; font-size: 11px; font-weight: 600; position: relative; min-width: 40px;" title="${labels[index]}: ${count} species (${percentage.toFixed(1)}%)">`;
                
                // Show number if there's enough space or if it's a significant count
                if (width > 30 || count >= 5) {
                    html += `${count}`;
                }
                
                html += `</div>`;
            }
        });
        
        html += '</div>';
        
        // Summary text below the bar
        html += '<div style="font-size: 10px; color: #6c757d; text-align: center; line-height: 1.2;">';
        const summary = [];
        categories.forEach((category, index) => {
            const count = dist[category] || 0;
            if (count > 0) {
                summary.push(`${labels[index]}: ${count}`);
            }
        });
        html += summary.join(' | ');
        html += '</div>';
        
        html += '</div>';
        return html;
    }
    
    function renderSearchCorrelationMode() {
        // Fetch correlation data and render
        fetch('/api/search_count_correlation')
            .then(response => response.json())
            .then(data => {
                window.correlationAnalysisData = data;
                const viewContainer = document.getElementById('comparisonView');
                
                let html = '<div style="margin-bottom: 20px;">';
                html += '<h3>Search Count Correlation Analysis</h3>';
                html += '<p style="color: #6c757d; margin-bottom: 20px;">Analyze the correlation between Google search result counts and LLM knowledge predictions.</p>';
                
                // Check if we have search count data
                if (!data.files_with_search_counts || data.files_with_search_counts.length === 0) {
                    html += '<div class="empty-state">';
                    html += '<h3>No search count data available</h3>';
                    html += '<p>No CSV/TSV files with search count columns were found in the data directory.</p>';
                    html += '</div>';
                    viewContainer.innerHTML = html;
                    return;
                }
                
                // Dataset selector
                html += '<div style="display: flex; gap: 15px; margin-bottom: 20px; padding: 15px; background-color: #f8f9fa; border-radius: 8px; flex-wrap: wrap;">';
                html += '<div style="flex: 1; min-width: 200px;">';
                html += '<label for="correlationDatasetSelector" style="display: block; margin-bottom: 5px; font-weight: 600; color: #495057; font-size: 14px;">Dataset:</label>';
                html += '<select id="correlationDatasetSelector" class="form-control" onchange="switchCorrelationDataset()">';
                html += '<option value="">Select a dataset...</option>';
                data.files_with_search_counts.forEach(filename => {
                    html += `<option value="${filename}">${filename.replace(/\.(txt|csv)$/i, '')}</option>`;
                });
                html += '</select>';
                html += '</div>';
                
                html += '<div style="flex: 1; min-width: 200px;">';
                html += '<label for="correlationTemplateSelector" style="display: block; margin-bottom: 5px; font-weight: 600; color: #495057; font-size: 14px;">Template:</label>';
                html += '<select id="correlationTemplateSelector" class="form-control" onchange="updateCorrelationView()">';
                html += '<option value="">All Templates</option>';
                html += '</select>';
                html += '</div>';
                
                html += '<div style="flex: 1; min-width: 200px;">';
                html += '<label for="correlationSortingMethod" style="display: block; margin-bottom: 5px; font-weight: 600; color: #495057; font-size: 14px;">Sort by:</label>';
                html += '<select id="correlationSortingMethod" class="form-control" onchange="updateCorrelationView()">';
                html += '<option value="correlation">Correlation (highest first)</option>';
                html += '<option value="correlation_abs">Absolute correlation</option>';
                html += '<option value="species_count">Species count</option>';
                html += '<option value="alphabetical">Model name (A-Z)</option>';
                html += '</select>';
                html += '</div>';
                html += '</div>';
                
                html += '<div id="correlationAnalysisContent">';
                html += '</div>';
                html += '</div>';
                
                viewContainer.innerHTML = html;
                showCorrelationOverview();
            })
            .catch(error => {
                console.error('Error fetching correlation data:', error);
                const viewContainer = document.getElementById('comparisonView');
                viewContainer.innerHTML = '<div class="empty-state"><h3>Error loading correlation data</h3><p>Failed to fetch search count correlation data. Please try again.</p></div>';
            });
    }

</script>
{% endblock %} 