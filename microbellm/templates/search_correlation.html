{% extends "base.html" %}

{% block title %}Knowledge-Web Alignment - MicrobeBench{% endblock %}

{% block content %}
<h1>Knowledge-Web Alignment Analysis</h1>

<div class="explanation-section">
    <div class="explanation-grid">
        <div class="explanation-box purpose-box">
            <h3><i class="fas fa-bullseye"></i> Purpose</h3>
            <p>We analyze how well LLM knowledge aligns with information availability on the internet. For thousands of real bacterial species (e.g., <em>E. coli</em>, <em>Bacillus subtilis</em>, <em>Mycobacterium tuberculosis</em>), we:</p>
            <ol class="purpose-steps">
                <li>Asked LLMs about their knowledge level (Limited, Moderate, or Extensive)</li>
                <li>Counted Google search results for each species</li>
                <li>Calculated correlation between LLM confidence and web presence</li>
            </ol>
            <p><strong>Key Insight:</strong> Models that claim more knowledge about well-documented species (and less about obscure ones) are better aligned with real-world information availability.</p>
        </div>
        
        <div class="explanation-box interpretation-box">
            <h3><i class="fas fa-chart-bar"></i> How to Interpret Results</h3>
            
            <div class="correlation-interpretation">
                <h4>Correlation Values:</h4>
                <div class="correlation-row excellent">
                    <span class="correlation-range">≥ 0.7</span>
                    <span class="correlation-label">Excellent Alignment</span>
                    <span class="interpretation">Model knowledge matches web presence very well</span>
                </div>
                
                <div class="correlation-row good">
                    <span class="correlation-range">0.3 to 0.7</span>
                    <span class="correlation-label">Good Alignment</span>
                    <span class="interpretation">Model generally aligns with available information</span>
                </div>
                
                <div class="correlation-row neutral">
                    <span class="correlation-range">-0.3 to 0.3</span>
                    <span class="correlation-label">Weak/No Alignment</span>
                    <span class="interpretation">Model shows little connection to web presence</span>
                </div>
                
                <div class="correlation-row poor">
                    <span class="correlation-range">< -0.3</span>
                    <span class="correlation-label">Inverse Alignment</span>
                    <span class="interpretation">Model claims knowledge opposite to availability</span>
                </div>
            </div>
            
            <div class="interpretation-note">
                <strong>What this means:</strong> A high positive correlation indicates the model appropriately claims more knowledge about well-documented species and less about obscure ones. This suggests better calibration and reliability.
            </div>
        </div>
    </div>
</div>

<div id="correlationContent">
    <div class="loading-container">
        <div class="loading-spinner"></div>
        <div class="loading-progress">
            <div class="loading-progress-bar"></div>
        </div>
        <div class="loading-text">Loading correlation analysis data...</div>
    </div>
</div>

<style>
    /* Explanation Section Styles */
    .explanation-section {
        margin-bottom: 30px;
    }
    
    .explanation-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-bottom: 20px;
    }
    
    @media (max-width: 1024px) {
        .explanation-grid {
            grid-template-columns: 1fr;
        }
    }
    
    .explanation-box {
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    
    .explanation-box h3 {
        margin: 0 0 15px 0;
        color: #2c3e50;
        font-size: 18px;
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    .explanation-box h3 i {
        font-size: 20px;
        opacity: 0.7;
    }
    
    .purpose-box {
        background: #f0f7ff;
        border-color: #b3d9ff;
    }
    
    .purpose-box h3 {
        color: #0056b3;
    }
    
    .interpretation-box {
        background: #f8f9fa;
    }
    
    .explanation-box p {
        margin: 0 0 10px 0;
        line-height: 1.6;
        color: #495057;
        font-size: 14px;
    }
    
    .explanation-box p:last-child {
        margin-bottom: 0;
    }
    
    .purpose-steps {
        margin: 10px 0;
        padding-left: 20px;
    }
    
    .purpose-steps li {
        margin-bottom: 8px;
        color: #495057;
        font-size: 14px;
        line-height: 1.5;
    }
    
    .correlation-interpretation {
        margin: 15px 0;
    }
    
    .correlation-interpretation h4 {
        margin: 0 0 10px 0;
        color: #495057;
        font-size: 15px;
        font-weight: 600;
    }
    
    .correlation-row {
        display: grid;
        grid-template-columns: 100px 150px 1fr;
        align-items: center;
        padding: 10px 12px;
        margin-bottom: 8px;
        border-radius: 6px;
        gap: 15px;
        font-size: 13px;
    }
    
    .correlation-row.excellent {
        background: #d4edda;
        border: 1px solid #c3e6cb;
    }
    
    .correlation-row.good {
        background: #d1ecf1;
        border: 1px solid #bee5eb;
    }
    
    .correlation-row.neutral {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
    }
    
    .correlation-row.poor {
        background: #f8d7da;
        border: 1px solid #f5c6cb;
    }
    
    .correlation-range {
        font-weight: 700;
        font-family: monospace;
        font-size: 14px;
    }
    
    .correlation-label {
        font-weight: 600;
        color: #2c3e50;
    }
    
    .interpretation {
        color: #495057;
        font-style: italic;
    }
    
    .interpretation-note {
        margin-top: 20px;
        padding: 15px;
        background: #e3f2fd;
        border: 1px solid #bbdefb;
        border-radius: 6px;
        font-size: 13px;
        line-height: 1.6;
        color: #0c5460;
    }
    
    /* Search Correlation Chart Styles - Matching Artificial Dataset Design */
    .correlation-analysis-container {
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 20px;
    }
    
    .correlation-analysis-table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        font-size: 12px;
    }
    
    .correlation-analysis-table th {
        background-color: #f8f9fa;
        padding: 8px 12px;
        text-align: center;
        font-weight: 600;
        color: #495057;
        border: 1px solid #dee2e6;
        border-bottom: 2px solid #007bff;
        font-size: 11px;
        white-space: nowrap;
    }
    
    .correlation-analysis-table td {
        padding: 4px 8px;
        border: 1px solid #e9ecef;
        vertical-align: middle;
        text-align: center;
    }
    
    .model-name-cell {
        background-color: #f8f9fa;
        font-weight: 600;
        color: #495057;
        text-align: left;
        padding-left: 10px;
        font-size: 11px;
        white-space: nowrap;
        min-width: 80px;
        max-width: 100px;
        overflow: hidden;
        text-overflow: ellipsis;
        cursor: default;
    }
    
    .chart-cell {
        width: 400px;
        padding: 2px;
    }
    
    .correlation-template-section {
        background: #f8f9fa;
        border: 1px solid #e9ecef;
        border-radius: 6px;
        padding: 15px;
        margin-bottom: 15px;
    }
    
    .correlation-template-header {
        margin-top: 0;
        margin-bottom: 15px;
        color: #495057;
        font-size: 16px;
        font-weight: 600;
        display: flex;
        align-items: center;
    }
    
    .correlation-bar-chart {
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        padding: 15px;
    }
    
    .chart-header {
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 1px solid #e9ecef;
    }
    
    .chart-legend {
        display: flex;
        gap: 20px;
        flex-wrap: wrap;
    }
    
    .legend-item {
        display: flex;
        align-items: center;
        font-size: 12px;
        color: #495057;
    }
    
    .legend-color {
        width: 16px;
        height: 16px;
        border-radius: 3px;
        margin-right: 6px;
        display: inline-block;
    }
    
    .legend-color.knowledge-limited {
        background-color: #fff3cd;
        border: 1px solid #ffeaa7;
    }
    
    .legend-color.knowledge-moderate {
        background-color: #d1ecf1;
        border: 1px solid #bee5eb;
    }
    
    .legend-color.knowledge-extensive {
        background-color: #d4edda;
        border: 1px solid #c3e6cb;
    }
    
    .legend-color.knowledge-na {
        background-color: #e2e3e5;
        border: 1px solid #d6d8db;
    }
    
    .single-bar-chart {
        width: 100%;
        height: 16px;
    }
    
    .single-stacked-bar {
        width: 100%;
        height: 16px;
        display: flex;
        border: 1px solid #dee2e6;
        border-radius: 2px;
        overflow: hidden;
        background: #f8f9fa;
    }
    
    .bar-segment {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        font-weight: 600;
        position: relative;
        min-width: 16px;
    }
    
    .chart-cell {
        cursor: help;
        transition: background-color 0.2s;
    }
    
    .chart-cell:hover {
        background-color: #f8f9fa;
    }
    
    .bar-number {
        font-size: 11px;
        font-weight: 700;
        text-shadow: 0 0 2px rgba(255,255,255,0.8);
        z-index: 1;
        pointer-events: none;
    }
    
    .bar-segment.knowledge-limited {
        background-color: #fff3cd;
        color: #856404;
    }
    
    .bar-segment.knowledge-moderate {
        background-color: #d1ecf1;
        color: #0c5460;
    }
    
    .bar-segment.knowledge-extensive {
        background-color: #d4edda;
        color: #155724;
    }
    
    .bar-segment.knowledge-na {
        background-color: #e2e3e5;
        color: #6c757d;
    }
    
    .correlation-value-cell {
        text-align: center;
        font-weight: 600;
        font-size: 11px;
        width: 80px;
        padding: 4px;
    }
    
    .correlation-value.strong-positive {
        color: #28a745;
    }
    
    .correlation-value.moderate-positive {
        color: #17a2b8;
    }
    
    .correlation-value.weak {
        color: #6c757d;
    }
    
    .correlation-value.moderate-negative {
        color: #fd7e14;
    }
    
    .correlation-value.strong-negative {
        color: #dc3545;
    }
    
    .no-data {
        text-align: center;
        color: #6c757d;
        font-style: italic;
        font-size: 11px;
        padding: 8px;
    }
    
    .loading-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        padding: 60px 40px;
    }
    
    .loading-spinner {
        width: 40px;
        height: 40px;
        border: 4px solid #e9ecef;
        border-top: 4px solid #007bff;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }
    
    .loading-progress {
        width: 300px;
        height: 6px;
        background-color: #e9ecef;
        border-radius: 3px;
        overflow: hidden;
        position: relative;
    }
    
    .loading-progress-bar {
        height: 100%;
        background: linear-gradient(90deg, #007bff, #0056b3);
        border-radius: 3px;
        animation: progress-slide 2s ease-in-out infinite;
        width: 30%;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    @keyframes progress-slide {
        0% { transform: translateX(-100%); }
        50% { transform: translateX(250%); }
        100% { transform: translateX(-100%); }
    }
    
    .loading-text {
        font-size: 16px;
        color: #495057;
        font-weight: 500;
    }
    
    .empty-state {
        text-align: center;
        padding: 60px;
        color: #6c757d;
    }
    
    .empty-state h3 {
        color: #495057;
        margin-bottom: 10px;
    }
    
    .template-section {
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        margin-bottom: 20px;
        overflow: hidden;
    }
    
    .template-header {
        background-color: #f8f9fa;
        padding: 15px 20px;
        border-bottom: 1px solid #dee2e6;
        font-weight: 600;
        color: #495057;
    }
    
    .template-content {
        padding: 0;
    }
    
    .correlation-legend {
        display: flex;
        gap: 20px;
        margin-bottom: 20px;
        flex-wrap: wrap;
        font-size: 12px;
    }
    
    .method-description {
        background: #e3f2fd;
        border: 1px solid #bbdefb;
        border-radius: 6px;
        padding: 15px;
        margin-bottom: 20px;
    }
    
    .method-description h4 {
        margin-top: 0;
        color: #1976d2;
    }
    
    /* Statistics cards styles */
    .correlation-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
    }
    
    .stat-card {
        background: white;
        border: 2px solid #e9ecef;
        border-radius: 8px;
        padding: 20px;
        text-align: center;
    }
    
    .stat-card.positive {
        border-color: #28a745;
        background-color: #f8fff9;
    }
    
    .stat-card.negative {
        border-color: #dc3545;
        background-color: #fff8f8;
    }
    
    .stat-card.neutral {
        border-color: #6c757d;
        background-color: #f8f9fa;
    }
    
    .stat-number {
        font-size: 28px;
        font-weight: 700;
        color: #2c3e50;
        margin-bottom: 5px;
    }
    
    .stat-label {
        font-size: 14px;
        color: #6c757d;
        font-weight: 500;
    }
    
    /* Species Distribution Tooltip Styles */
    .species-tooltip {
        position: fixed;
        z-index: 1000;
        pointer-events: none;
        filter: drop-shadow(0 2px 8px rgba(0,0,0,0.15));
    }
    
    .species-tooltip-content {
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        padding: 8px 12px;
        font-size: 11px;
        max-width: 250px;
    }
    
    .species-tooltip-header {
        font-weight: 600;
        margin-bottom: 6px;
        padding-bottom: 4px;
        border-bottom: 1px solid #e9ecef;
    }
    
    .species-tooltip-list {
        max-height: 200px;
        overflow-y: auto;
    }
    
    .species-tooltip-item {
        padding: 2px 0;
        color: #495057;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 10px;
    }
    
    .species-tooltip-item em {
        font-style: italic;
        font-family: inherit;
    }
    
    .species-tooltip-more {
        margin-top: 4px;
        padding-top: 4px;
        border-top: 1px solid #e9ecef;
        font-style: italic;
        color: #6c757d;
    }
    
    /* Tooltip color themes */
    .tooltip-limited .species-tooltip-header {
        color: #856404;
        background: #fff3cd;
        padding: 4px 8px;
        margin: -8px -12px 6px;
        border-radius: 5px 5px 0 0;
    }
    
    .tooltip-moderate .species-tooltip-header {
        color: #0c5460;
        background: #d1ecf1;
        padding: 4px 8px;
        margin: -8px -12px 6px;
        border-radius: 5px 5px 0 0;
    }
    
    .tooltip-extensive .species-tooltip-header {
        color: #155724;
        background: #d4edda;
        padding: 4px 8px;
        margin: -8px -12px 6px;
        border-radius: 5px 5px 0 0;
    }
    
    .tooltip-na .species-tooltip-header {
        color: #383d41;
        background: #e2e3e5;
        padding: 4px 8px;
        margin: -8px -12px 6px;
        border-radius: 5px 5px 0 0;
    }
    
    /* Correlation Visualization Tooltip */
    .correlation-tooltip {
        position: fixed;
        z-index: 1000;
        pointer-events: none;
        filter: drop-shadow(0 2px 12px rgba(0,0,0,0.15));
    }
    
    .correlation-tooltip-content {
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 12px;
        font-size: 11px;
        width: 280px;
    }
    
    .correlation-tooltip-header {
        font-weight: 700;
        margin-bottom: 10px;
        padding-bottom: 8px;
        border-bottom: 2px solid #e9ecef;
        color: #2c3e50;
        font-size: 12px;
    }
    
    .scatter-plot-container {
        width: 256px;
        height: 180px;
        position: relative;
        margin: 8px 0;
    }
    
    .scatter-plot-canvas {
        width: 256px;
        height: 180px;
    }
    
    .correlation-stats {
        display: flex;
        justify-content: space-between;
        margin-top: 10px;
        font-size: 11px;
    }
    
    .correlation-stat {
        text-align: center;
    }
    
    .correlation-stat-value {
        font-weight: 600;
        color: #2c3e50;
        font-size: 13px;
    }
    
    .correlation-stat-label {
        color: #6c757d;
        font-size: 10px;
    }
    
    .correlation-value {
        cursor: help;
        position: relative;
        display: inline-block;
        padding: 2px 6px;
        border-radius: 3px;
        transition: background-color 0.2s;
    }
    
    .correlation-value:hover {
        background: #e3f2fd;
    }
</style>
{% endblock %}

{% block scripts %}
<script>
    let correlationData = null;
    
    // Format model name with provider
    function formatModelName(modelName) {
        if (!modelName.includes('/')) {
            return modelName;
        }
        
        const [provider, model] = modelName.split('/');
        const providerMap = {
            'anthropic': 'Anthropic',
            'openai': 'OpenAI',
            'google': 'Google',
            'meta-llama': 'Meta',
            'mistralai': 'Mistral',
            'cohere': 'Cohere',
            'x-ai': 'xAI'
        };
        
        const displayProvider = providerMap[provider] || provider.charAt(0).toUpperCase() + provider.slice(1);
        return `${displayProvider} ${model}`;
    }
    
    // Load correlation data on page load
    loadCorrelationData();
    
    function loadCorrelationData() {
        fetch('/api/search_count_correlation')
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    document.getElementById('correlationContent').innerHTML = 
                        `<div class="empty-state"><h3>Error loading correlation data</h3><p>${data.error}</p></div>`;
                    return;
                }
                
                correlationData = data;
                
                if (data.files_with_search_counts.length === 0) {
                    document.getElementById('correlationContent').innerHTML = 
                        '<div class="empty-state"><h3>No datasets with search counts found</h3><p>Upload a CSV file with a "Search Count" column to see correlation analysis.</p></div>';
                    return;
                }
                
                // Auto-select first dataset
                if (data.files_with_search_counts.length > 0) {
                    const firstDataset = data.files_with_search_counts[0];
                    showDatasetAnalysis(firstDataset);
                } else {
                    showOverviewContent();
                }
            })
            .catch(error => {
                console.error('Error loading correlation data:', error);
                document.getElementById('correlationContent').innerHTML = 
                    '<div class="empty-state"><h3>Error loading data</h3><p>' + error.message + '</p></div>';
            });
    }
    
    function showOverviewContent() {
        const content = document.getElementById('correlationContent');
        
        let html = '<div class="empty-state">';
        html += '<h3>No correlation data available</h3>';
        html += '<p>Upload a dataset with search counts to see the knowledge-web alignment analysis.</p>';
        html += '</div>';
        
        content.innerHTML = html;
    }
    
    function showDatasetAnalysis(selectedDataset) {
        if (!selectedDataset || !correlationData) {
            showOverviewContent();
            return;
        }
        
        const fileData = correlationData.correlation_data[selectedDataset];
        updateCorrelationView(selectedDataset, '', 'correlation');
    }
    
    function updateCorrelationView(selectedDataset, selectedTemplate = '', sortingMethod = 'correlation') {
        if (!selectedDataset || !correlationData) {
            return;
        }
        
        const fileData = correlationData.correlation_data[selectedDataset];
        const content = document.getElementById('correlationContent');
        
        let html = '<h3>Model Performance Analysis</h3>';
        
        // Collect and sort model data
        let modelResults = [];
        
        Object.entries(fileData).forEach(([templateName, models]) => {
            if (selectedTemplate && templateName !== selectedTemplate) return;
            
            Object.entries(models).forEach(([modelName, data]) => {
                if (data.species_count < 2) return; // Skip models with insufficient data
                
                modelResults.push({
                    modelName,
                    templateName,
                    correlation: data.correlation_coefficient,
                    speciesCount: data.species_count,
                    knowledgeDist: data.knowledge_distribution,
                    dataPoints: data.data_points
                });
            });
        });
        
        // Sort models based on selected method
        modelResults.sort((a, b) => {
            switch(sortingMethod) {
                case 'correlation':
                    return b.correlation - a.correlation;
                case 'correlation_abs':
                    return Math.abs(b.correlation) - Math.abs(a.correlation);
                case 'species_count':
                    return b.speciesCount - a.speciesCount;
                case 'alphabetical':
                    return a.modelName.localeCompare(b.modelName);
                default:
                    return b.correlation - a.correlation;
            }
        });
        
        if (modelResults.length === 0) {
            html += '<div class="empty-state"><h3>No correlation data available</h3><p>No models have sufficient data points for correlation analysis.</p></div>';
            content.innerHTML = html;
            return;
        }
        
        // Statistics
        const avgCorrelation = modelResults.reduce((sum, m) => sum + m.correlation, 0) / modelResults.length;
        const maxCorrelation = Math.max(...modelResults.map(m => m.correlation));
        const minCorrelation = Math.min(...modelResults.map(m => m.correlation));
        const bestModel = modelResults.find(m => m.correlation === maxCorrelation);
        
        html += '<div class="correlation-stats">';
        html += `<div class="stat-card ${avgCorrelation > 0.3 ? 'positive' : avgCorrelation < -0.3 ? 'negative' : 'neutral'}">`;
        html += `<div class="stat-number">${avgCorrelation.toFixed(3)}</div>`;
        html += `<div class="stat-label">Average Correlation</div>`;
        html += `</div>`;
        
        html += `<div class="stat-card ${maxCorrelation > 0.5 ? 'positive' : 'neutral'}">`;
        html += `<div class="stat-number">${maxCorrelation.toFixed(3)}</div>`;
        html += `<div class="stat-label">Best Alignment</div>`;
        html += `</div>`;
        
        html += `<div class="stat-card positive">`;
        html += `<div class="stat-number">${bestModel ? bestModel.modelName.split('/').pop() : 'N/A'}</div>`;
        html += `<div class="stat-label">Top Aligned Model</div>`;
        html += `</div>`;
        
        html += `<div class="stat-card neutral">`;
        html += `<div class="stat-number">${modelResults.length}</div>`;
        html += `<div class="stat-label">Models Analyzed</div>`;
        html += `</div>`;
        html += '</div>';
        
        // Group by template if showing all templates
        if (!selectedTemplate) {
            const byTemplate = {};
            modelResults.forEach(result => {
                if (!byTemplate[result.templateName]) {
                    byTemplate[result.templateName] = [];
                }
                byTemplate[result.templateName].push(result);
            });
            
            Object.entries(byTemplate).forEach(([templateName, results]) => {
                html += renderTemplateCorrelationTable(templateName, results);
            });
        } else {
            html += renderTemplateCorrelationTable(selectedTemplate, modelResults);
        }
        
        content.innerHTML = html;
    }
    
    function renderTemplateCorrelationTable(templateName, modelResults) {
        let html = `<div class="correlation-analysis-container">`;
        html += `<h4 style="margin: 0 0 15px 0; color: #2c3e50; font-size: 16px;">${templateName}</h4>`;
        
        html += `<table class="correlation-analysis-table">`;
        
        // Header row
        html += `<thead><tr>`;
        html += `<th style="text-align: left; background-color: #e9ecef;">Model</th>`;
        html += `<th style="text-align: center; background-color: #e9ecef; width: 80px;">Correlation</th>`;
        html += `<th style="text-align: center; background-color: #e9ecef; width: 400px;">Knowledge Distribution</th>`;
        html += `<th style="text-align: center; background-color: #e9ecef; width: 100px;">Alignment</th>`;
        html += `</tr></thead>`;
        
        // Data rows
        html += `<tbody>`;
        
        modelResults.forEach(result => {
            const correlationClass = getCorrelationClass(result.correlation);
            const interpretation = getCorrelationInterpretation(result.correlation);
            
            html += `<tr>`;
            html += `<td class="model-name-cell">${formatModelName(result.modelName)}</td>`;
            html += `<td class="correlation-value-cell">
                        <span class="correlation-value ${correlationClass}" 
                              data-model="${result.modelName}"
                              data-template="${result.templateName}"
                              data-correlation="${result.correlation}"
                              data-points='${JSON.stringify(result.dataPoints)}'
                              onmouseover="showCorrelationTooltip(event, this)"
                              onmouseout="hideCorrelationTooltip()">
                              ${result.correlation.toFixed(3)}
                        </span>
                     </td>`;
            html += `<td class="chart-cell"
                        data-model="${result.modelName}"
                        data-correlation="${result.correlation}"
                        data-points='${JSON.stringify(result.dataPoints)}'
                        onmouseover="showDistributionTooltip(event, this)"
                        onmouseout="hideDistributionTooltip()">
                        ${renderKnowledgeDistributionBar(result.knowledgeDist, result.speciesCount, result.dataPoints)}
                     </td>`;
            html += `<td style="text-align: center; font-size: 11px; color: #495057; padding: 4px;">${interpretation}</td>`;
            html += `</tr>`;
        });
        
        html += `</tbody></table>`;
        html += `</div>`;
        
        return html;
    }
    
    function getCorrelationClass(correlation) {
        if (correlation >= 0.7) return 'strong-positive';
        if (correlation >= 0.3) return 'moderate-positive';
        if (correlation <= -0.7) return 'strong-negative';
        if (correlation <= -0.3) return 'moderate-negative';
        return 'weak';
    }
    
    function getCorrelationInterpretation(correlation) {
        if (correlation >= 0.7) return 'Excellent';
        if (correlation >= 0.5) return 'Good';
        if (correlation >= 0.3) return 'Moderate';
        if (correlation >= 0.1) return 'Weak +';
        if (correlation >= -0.1) return 'None';
        if (correlation >= -0.3) return 'Weak -';
        if (correlation >= -0.5) return 'Inverse';
        return 'Strong -';
    }
    
    function renderKnowledgeDistributionBar(dist, total, dataPoints) {
        if (total === 0) {
            return '<div class="no-data">No data</div>';
        }
        
        // Group data points by knowledge level
        const pointsByLevel = {};
        if (dataPoints) {
            dataPoints.forEach(point => {
                const level = point.knowledge_group.toLowerCase();
                if (!pointsByLevel[level]) {
                    pointsByLevel[level] = [];
                }
                pointsByLevel[level].push(point);
            });
        }
        
        // Calculate percentages
        const limitedPct = ((dist.limited || 0) / total * 100);
        const moderatePct = ((dist.moderate || 0) / total * 100);
        const extensivePct = ((dist.extensive || 0) / total * 100);
        const naPct = ((dist.NA || 0) / total * 100);
        
        // Calculate minimum visible width
        const minVisiblePct = 2;
        const segments = [
            { type: 'limited', count: dist.limited || 0, pct: limitedPct, class: 'knowledge-limited', samples: pointsByLevel['limited'] || [] },
            { type: 'moderate', count: dist.moderate || 0, pct: moderatePct, class: 'knowledge-moderate', samples: pointsByLevel['moderate'] || [] },
            { type: 'extensive', count: dist.extensive || 0, pct: extensivePct, class: 'knowledge-extensive', samples: pointsByLevel['extensive'] || [] },
            { type: 'na', count: dist.NA || 0, pct: naPct, class: 'knowledge-na', samples: pointsByLevel['na'] || pointsByLevel['n/a'] || [] }
        ].filter(seg => seg.count > 0);
        
        // Calculate adjusted widths
        let totalAdjustedPct = 0;
        const adjustedSegments = segments.map(seg => {
            const minWidth = minVisiblePct;
            const adjustedPct = seg.pct < minWidth && seg.count > 0 ? minWidth : seg.pct;
            totalAdjustedPct += adjustedPct;
            return { ...seg, adjustedPct };
        });
        
        // Scale down if total exceeds 100%
        const scaleFactor = totalAdjustedPct > 100 ? 100 / totalAdjustedPct : 1;
        
        let html = '<div class="single-bar-chart">';
        html += '<div class="single-stacked-bar">';
        
        adjustedSegments.forEach((seg, index) => {
            const finalWidth = seg.adjustedPct * scaleFactor;
            
            html += `<div class="bar-segment ${seg.class}" style="width: ${finalWidth}%">`;
            
            // Show number for larger segments
            if (finalWidth > 4 || seg.count >= 10) {
                html += `<span class="bar-number">${seg.count}</span>`;
            }
            
            html += `</div>`;
        });
        
        html += '</div>';
        html += '</div>';
        
        return html;
    }
    
    // Tooltip functions
    let speciestooltip = null;
    let correlationTooltip = null;
    let distributionTooltip = null;
    
    function showSpeciesTooltip(event, element) {
        const samples = JSON.parse(element.getAttribute('data-samples'));
        const category = element.getAttribute('data-category');
        const count = element.getAttribute('data-count');
        
        // Hide any existing tooltip
        hideSpeciesTooltip();
        
        // Create tooltip
        speciestooltip = document.createElement('div');
        speciestooltip.className = 'species-tooltip';
        
        // Get color class based on category
        let colorClass = '';
        switch(category) {
            case 'limited': colorClass = 'tooltip-limited'; break;
            case 'moderate': colorClass = 'tooltip-moderate'; break;
            case 'extensive': colorClass = 'tooltip-extensive'; break;
            case 'na': colorClass = 'tooltip-na'; break;
        }
        
        // Create content - show up to 10 species names
        const maxShow = 10;
        const speciesToShow = samples.slice(0, maxShow);
        const remaining = samples.length - maxShow;
        
        let html = `<div class="species-tooltip-content ${colorClass}">`;
        html += `<div class="species-tooltip-header">${category.charAt(0).toUpperCase() + category.slice(1)} (${count})</div>`;
        html += '<div class="species-tooltip-list">';
        
        speciesToShow.forEach(sample => {
            html += `<div class="species-tooltip-item"><em>${sample.species}</em></div>`;
        });
        
        if (remaining > 0) {
            html += `<div class="species-tooltip-more">... and ${remaining} more</div>`;
        }
        
        html += '</div></div>';
        
        speciestooltip.innerHTML = html;
        document.body.appendChild(speciestooltip);
        
        // Position tooltip
        const rect = element.getBoundingClientRect();
        const tooltipRect = speciestooltip.getBoundingClientRect();
        
        let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);
        let top = rect.top - tooltipRect.height - 10;
        
        // Ensure tooltip stays on screen
        if (left < 10) left = 10;
        if (left + tooltipRect.width > window.innerWidth - 10) {
            left = window.innerWidth - tooltipRect.width - 10;
        }
        
        // If tooltip would go above screen, show below
        if (top < 10) {
            top = rect.bottom + 10;
        }
        
        speciestooltip.style.left = left + 'px';
        speciestooltip.style.top = top + 'px';
    }
    
    function hideSpeciesTooltip() {
        if (speciestooltip) {
            speciestooltip.remove();
            speciestooltip = null;
        }
    }
    
    function showCorrelationTooltip(event, element) {
        const model = element.getAttribute('data-model');
        const correlation = parseFloat(element.getAttribute('data-correlation'));
        const dataPoints = JSON.parse(element.getAttribute('data-points'));
        
        // Hide any existing tooltip
        hideCorrelationTooltip();
        
        // Create tooltip
        correlationTooltip = document.createElement('div');
        correlationTooltip.className = 'correlation-tooltip';
        
        let html = `<div class="correlation-tooltip-content">`;
        html += `<div class="correlation-tooltip-header">Correlation: ${correlation.toFixed(3)}</div>`;
        html += `<div class="scatter-plot-container">`;
        html += `<canvas id="correlationCanvas" class="scatter-plot-canvas"></canvas>`;
        html += `</div>`;
        html += `</div>`;
        
        correlationTooltip.innerHTML = html;
        document.body.appendChild(correlationTooltip);
        
        // Position tooltip
        const rect = element.getBoundingClientRect();
        const tooltipRect = correlationTooltip.getBoundingClientRect();
        
        let left = rect.right + 10;
        let top = rect.top + (rect.height / 2) - (tooltipRect.height / 2);
        
        // If tooltip would go off right edge, show on left
        if (left + tooltipRect.width > window.innerWidth - 10) {
            left = rect.left - tooltipRect.width - 10;
        }
        
        // Ensure tooltip stays on screen vertically
        if (top < 10) top = 10;
        if (top + tooltipRect.height > window.innerHeight - 10) {
            top = window.innerHeight - tooltipRect.height - 10;
        }
        
        correlationTooltip.style.left = left + 'px';
        correlationTooltip.style.top = top + 'px';
        
        // Draw scatter plot
        setTimeout(() => drawScatterPlot(dataPoints, correlation), 10);
    }
    
    function hideCorrelationTooltip() {
        if (correlationTooltip) {
            correlationTooltip.remove();
            correlationTooltip = null;
        }
    }
    
    function drawScatterPlot(dataPoints, correlation, highlightCategory = null) {
        const canvas = document.getElementById('correlationCanvas');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        const width = 256;
        const height = 180;
        
        // Set canvas size with device pixel ratio for crisp rendering
        const dpr = window.devicePixelRatio || 1;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
        ctx.scale(dpr, dpr);
        
        // Clear canvas
        ctx.clearRect(0, 0, width, height);
        
        // Calculate bounds
        const xValues = dataPoints.map(p => Math.log10(p.search_count || 1));
        const yValues = dataPoints.map(p => p.knowledge_score);
        
        const xMin = Math.min(...xValues);
        const xMax = Math.max(...xValues);
        const yMin = 0.5;
        const yMax = 3.5;
        
        const padding = 30;
        const plotWidth = width - 2 * padding;
        const plotHeight = height - 2 * padding;
        
        // Draw axes
        ctx.strokeStyle = '#dee2e6';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(padding, padding);
        ctx.lineTo(padding, height - padding);
        ctx.lineTo(width - padding, height - padding);
        ctx.stroke();
        
        // Draw grid lines
        ctx.strokeStyle = '#f0f0f0';
        ctx.lineWidth = 0.5;
        
        // Y grid lines (knowledge levels)
        [1, 2, 3].forEach(level => {
            const y = height - padding - ((level - yMin) / (yMax - yMin)) * plotHeight;
            ctx.beginPath();
            ctx.moveTo(padding, y);
            ctx.lineTo(width - padding, y);
            ctx.stroke();
        });
        
        // Group data by knowledge level for mean±SD visualization
        const levelData = { 1: [], 2: [], 3: [] };
        dataPoints.forEach(point => {
            if (levelData[point.knowledge_score]) {
                levelData[point.knowledge_score].push(Math.log10(point.search_count || 1));
            }
        });
        
        // Calculate mean and SD for each level
        Object.entries(levelData).forEach(([level, values]) => {
            if (values.length === 0) return;
            
            const levelNum = parseInt(level);
            const mean = values.reduce((a, b) => a + b, 0) / values.length;
            const sd = Math.sqrt(values.reduce((sum, x) => sum + Math.pow(x - mean, 2), 0) / values.length);
            
            const x = padding + ((mean - xMin) / (xMax - xMin)) * plotWidth;
            const y = height - padding - ((levelNum - yMin) / (yMax - yMin)) * plotHeight;
            const sdWidth = (sd / (xMax - xMin)) * plotWidth;
            
            // Draw SD error bar
            ctx.strokeStyle = '#6c757d';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(x - sdWidth, y);
            ctx.lineTo(x + sdWidth, y);
            ctx.stroke();
            
            // Draw caps
            ctx.beginPath();
            ctx.moveTo(x - sdWidth, y - 3);
            ctx.lineTo(x - sdWidth, y + 3);
            ctx.moveTo(x + sdWidth, y - 3);
            ctx.lineTo(x + sdWidth, y + 3);
            ctx.stroke();
            
            // Draw mean point
            const isHighlighted = highlightCategory && 
                ((highlightCategory === 'limited' && levelNum === 1) ||
                 (highlightCategory === 'moderate' && levelNum === 2) ||
                 (highlightCategory === 'extensive' && levelNum === 3));
            
            // Color based on knowledge level
            switch(levelNum) {
                case 1: ctx.fillStyle = isHighlighted ? '#ffc107' : '#fff3cd'; break;
                case 2: ctx.fillStyle = isHighlighted ? '#17a2b8' : '#d1ecf1'; break;
                case 3: ctx.fillStyle = isHighlighted ? '#28a745' : '#d4edda'; break;
            }
            
            ctx.beginPath();
            ctx.arc(x, y, isHighlighted ? 6 : 4, 0, 2 * Math.PI);
            ctx.fill();
            ctx.strokeStyle = isHighlighted ? '#212529' : '#6c757d';
            ctx.lineWidth = isHighlighted ? 2 : 1;
            ctx.stroke();
            
            // Add count label if highlighted
            if (isHighlighted) {
                ctx.fillStyle = '#212529';
                ctx.font = 'bold 11px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`n=${values.length}`, x, y - 10);
            }
        });
        
        // Draw trend line if positive correlation
        if (correlation > 0.1) {
            // Simple linear regression
            const n = xValues.length;
            const sumX = xValues.reduce((a, b) => a + b, 0);
            const sumY = yValues.reduce((a, b) => a + b, 0);
            const sumXY = xValues.reduce((sum, x, i) => sum + x * yValues[i], 0);
            const sumX2 = xValues.reduce((sum, x) => sum + x * x, 0);
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            ctx.strokeStyle = correlation > 0.5 ? '#28a745' : '#17a2b8';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            
            const x1 = padding;
            const y1 = height - padding - ((slope * xMin + intercept - yMin) / (yMax - yMin)) * plotHeight;
            const x2 = width - padding;
            const y2 = height - padding - ((slope * xMax + intercept - yMin) / (yMax - yMin)) * plotHeight;
            
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        // Add axis labels
        ctx.fillStyle = '#6c757d';
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Log(Search Count)', width / 2, height - 5);
        
        ctx.save();
        ctx.translate(10, height / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText('Knowledge Level', 0, 0);
        ctx.restore();
        
        // Add level labels
        ctx.textAlign = 'right';
        ctx.fillText('Limited', padding - 5, height - padding - (1 - yMin) / (yMax - yMin) * plotHeight);
        ctx.fillText('Moderate', padding - 5, height - padding - (2 - yMin) / (yMax - yMin) * plotHeight);
        ctx.fillText('Extensive', padding - 5, height - padding - (3 - yMin) / (yMax - yMin) * plotHeight);
    }
    
    function showDistributionTooltip(event, element) {
        const correlation = parseFloat(element.getAttribute('data-correlation'));
        const dataPoints = JSON.parse(element.getAttribute('data-points'));
        
        // Get which bar segment was hovered by checking mouse position
        const rect = element.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const barSegments = element.querySelectorAll('.bar-segment');
        
        let hoveredCategory = null;
        let currentX = 0;
        
        // Find which segment the mouse is over
        barSegments.forEach(segment => {
            const width = segment.offsetWidth;
            if (x >= currentX && x < currentX + width) {
                // Determine category from class
                if (segment.classList.contains('knowledge-limited')) hoveredCategory = 'limited';
                else if (segment.classList.contains('knowledge-moderate')) hoveredCategory = 'moderate';
                else if (segment.classList.contains('knowledge-extensive')) hoveredCategory = 'extensive';
                else if (segment.classList.contains('knowledge-na')) hoveredCategory = 'na';
            }
            currentX += width;
        });
        
        // Hide any existing tooltip
        hideDistributionTooltip();
        
        // Create tooltip
        distributionTooltip = document.createElement('div');
        distributionTooltip.className = 'correlation-tooltip';
        
        let html = `<div class="correlation-tooltip-content">`;
        html += `<div class="correlation-tooltip-header">Knowledge Distribution Analysis</div>`;
        html += `<div class="scatter-plot-container">`;
        html += `<canvas id="distributionCanvas" class="scatter-plot-canvas"></canvas>`;
        html += `</div>`;
        html += `</div>`;
        
        distributionTooltip.innerHTML = html;
        document.body.appendChild(distributionTooltip);
        
        // Position tooltip below the cell
        const tooltipRect = distributionTooltip.getBoundingClientRect();
        
        let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);
        let top = rect.bottom + 10;
        
        // If tooltip would go off bottom, show above
        if (top + tooltipRect.height > window.innerHeight - 10) {
            top = rect.top - tooltipRect.height - 10;
        }
        
        // Ensure tooltip stays on screen horizontally
        if (left < 10) left = 10;
        if (left + tooltipRect.width > window.innerWidth - 10) {
            left = window.innerWidth - tooltipRect.width - 10;
        }
        
        distributionTooltip.style.left = left + 'px';
        distributionTooltip.style.top = top + 'px';
        
        // Draw scatter plot with highlighted category
        setTimeout(() => {
            const canvas = document.getElementById('distributionCanvas');
            if (canvas) {
                canvas.id = 'correlationCanvas'; // Reuse existing draw function
                drawScatterPlot(dataPoints, correlation, hoveredCategory);
                canvas.id = 'distributionCanvas'; // Restore ID
            }
        }, 10);
    }
    
    function hideDistributionTooltip() {
        if (distributionTooltip) {
            distributionTooltip.remove();
            distributionTooltip = null;
        }
    }
</script>
{% endblock %} 